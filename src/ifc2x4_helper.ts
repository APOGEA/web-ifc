// This is a generated file, please see: gen_functional_types.js
export interface Handle<T> { expressID: number; }
export function Write<T>(obj: T): Handle<T> { return { expressID: 0 }; }
export function Value(type: string, value: any): any { return { t: type, v: value }; }
const UNKNOWN = 0;
const STRING = 1;
const LABEL = 2;
const ENUM = 3;
const REAL = 4;
const REF = 5;
const EMPTY = 6;
const SET_BEGIN = 7;
const SET_END = 8;
const LINE_END = 9;
export type IfcAbsorbedDoseMeasure = number;
export type IfcAccelerationMeasure = number;
export type IfcAmountOfSubstanceMeasure = number;
export type IfcAngularVelocityMeasure = number;
export type IfcArcIndex = Array<IfcPositiveInteger>;
export type IfcAreaDensityMeasure = number;
export type IfcAreaMeasure = number;
export type IfcBinary = number;
export type IfcBoolean = boolean;
export type IfcBoxAlignment = IfcLabel;
export type IfcCardinalPointReference = number;
export type IfcComplexNumber = Array<number>;
export type IfcCompoundPlaneAngleMeasure = Array<number>;
export type IfcContextDependentMeasure = number;
export type IfcCountMeasure = number;
export type IfcCurvatureMeasure = number;
export type IfcDate = string;
export type IfcDateTime = string;
export type IfcDayInMonthNumber = number;
export type IfcDayInWeekNumber = number;
export type IfcDescriptiveMeasure = string;
export type IfcDimensionCount = number;
export type IfcDoseEquivalentMeasure = number;
export type IfcDuration = string;
export type IfcDynamicViscosityMeasure = number;
export type IfcElectricCapacitanceMeasure = number;
export type IfcElectricChargeMeasure = number;
export type IfcElectricConductanceMeasure = number;
export type IfcElectricCurrentMeasure = number;
export type IfcElectricResistanceMeasure = number;
export type IfcElectricVoltageMeasure = number;
export type IfcEnergyMeasure = number;
export type IfcFontStyle = string;
export type IfcFontVariant = string;
export type IfcFontWeight = string;
export type IfcForceMeasure = number;
export type IfcFrequencyMeasure = number;
export type IfcGloballyUniqueId = string;
export type IfcHeatFluxDensityMeasure = number;
export type IfcHeatingValueMeasure = number;
export type IfcIdentifier = string;
export type IfcIlluminanceMeasure = number;
export type IfcInductanceMeasure = number;
export type IfcInteger = number;
export type IfcIntegerCountRateMeasure = number;
export type IfcIonConcentrationMeasure = number;
export type IfcIsothermalMoistureCapacityMeasure = number;
export type IfcKinematicViscosityMeasure = number;
export type IfcLabel = string;
export type IfcLanguageId = IfcIdentifier;
export type IfcLengthMeasure = number;
export type IfcLineIndex = Array<IfcPositiveInteger>;
export type IfcLinearForceMeasure = number;
export type IfcLinearMomentMeasure = number;
export type IfcLinearStiffnessMeasure = number;
export type IfcLinearVelocityMeasure = number;
export type IfcLogical = boolean;
export type IfcLuminousFluxMeasure = number;
export type IfcLuminousIntensityDistributionMeasure = number;
export type IfcLuminousIntensityMeasure = number;
export type IfcMagneticFluxDensityMeasure = number;
export type IfcMagneticFluxMeasure = number;
export type IfcMassDensityMeasure = number;
export type IfcMassFlowRateMeasure = number;
export type IfcMassMeasure = number;
export type IfcMassPerLengthMeasure = number;
export type IfcModulusOfElasticityMeasure = number;
export type IfcModulusOfLinearSubgradeReactionMeasure = number;
export type IfcModulusOfRotationalSubgradeReactionMeasure = number;
export type IfcModulusOfSubgradeReactionMeasure = number;
export type IfcMoistureDiffusivityMeasure = number;
export type IfcMolecularWeightMeasure = number;
export type IfcMomentOfInertiaMeasure = number;
export type IfcMonetaryMeasure = number;
export type IfcMonthInYearNumber = number;
export type IfcNonNegativeLengthMeasure = IfcLengthMeasure;
export type IfcNormalisedRatioMeasure = IfcRatioMeasure;
export type IfcNumericMeasure = number;
export type IfcPHMeasure = number;
export type IfcParameterValue = number;
export type IfcPlanarForceMeasure = number;
export type IfcPlaneAngleMeasure = number;
export type IfcPositiveInteger = IfcInteger;
export type IfcPositiveLengthMeasure = IfcLengthMeasure;
export type IfcPositivePlaneAngleMeasure = IfcPlaneAngleMeasure;
export type IfcPositiveRatioMeasure = IfcRatioMeasure;
export type IfcPowerMeasure = number;
export type IfcPresentableText = string;
export type IfcPressureMeasure = number;
export type IfcPropertySetDefinitionSet = Array<IfcPropertySetDefinition>;
export type IfcRadioActivityMeasure = number;
export type IfcRatioMeasure = number;
export type IfcReal = number;
export type IfcRotationalFrequencyMeasure = number;
export type IfcRotationalMassMeasure = number;
export type IfcRotationalStiffnessMeasure = number;
export type IfcSectionModulusMeasure = number;
export type IfcSectionalAreaIntegralMeasure = number;
export type IfcShearModulusMeasure = number;
export type IfcSolidAngleMeasure = number;
export type IfcSoundPowerLevelMeasure = number;
export type IfcSoundPowerMeasure = number;
export type IfcSoundPressureLevelMeasure = number;
export type IfcSoundPressureMeasure = number;
export type IfcSpecificHeatCapacityMeasure = number;
export type IfcSpecularExponent = number;
export type IfcSpecularRoughness = number;
export type IfcTemperatureGradientMeasure = number;
export type IfcTemperatureRateOfChangeMeasure = number;
export type IfcText = string;
export type IfcTextAlignment = string;
export type IfcTextDecoration = string;
export type IfcTextFontName = string;
export type IfcTextTransformation = string;
export type IfcThermalAdmittanceMeasure = number;
export type IfcThermalConductivityMeasure = number;
export type IfcThermalExpansionCoefficientMeasure = number;
export type IfcThermalResistanceMeasure = number;
export type IfcThermalTransmittanceMeasure = number;
export type IfcThermodynamicTemperatureMeasure = number;
export type IfcTime = string;
export type IfcTimeMeasure = number;
export type IfcTimeStamp = number;
export type IfcTorqueMeasure = number;
export type IfcURIReference = string;
export type IfcVaporPermeabilityMeasure = number;
export type IfcVolumeMeasure = number;
export type IfcVolumetricFlowRateMeasure = number;
export type IfcWarpingConstantMeasure = number;
export type IfcWarpingMomentMeasure = number;
export enum IfcActionRequestTypeEnum {
	EMAIL,
	FAX,
	PHONE,
	POST,
	VERBAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcActionSourceTypeEnum {
	DEAD_LOAD_G,
	COMPLETION_G1,
	LIVE_LOAD_Q,
	SNOW_S,
	WIND_W,
	PRESTRESSING_P,
	SETTLEMENT_U,
	TEMPERATURE_T,
	EARTHQUAKE_E,
	FIRE,
	IMPULSE,
	IMPACT,
	TRANSPORT,
	ERECTION,
	PROPPING,
	SYSTEM_IMPERFECTION,
	SHRINKAGE,
	CREEP,
	LACK_OF_FIT,
	BUOYANCY,
	ICE,
	CURRENT,
	WAVE,
	RAIN,
	BRAKES,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcActionTypeEnum {
	PERMANENT_G,
	VARIABLE_Q,
	EXTRAORDINARY_A,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcActuatorTypeEnum {
	ELECTRICACTUATOR,
	HANDOPERATEDACTUATOR,
	HYDRAULICACTUATOR,
	PNEUMATICACTUATOR,
	THERMOSTATICACTUATOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAddressTypeEnum {
	OFFICE,
	SITE,
	HOME,
	DISTRIBUTIONPOINT,
	USERDEFINED
};
export enum IfcAirTerminalBoxTypeEnum {
	CONSTANTFLOW,
	VARIABLEFLOWPRESSUREDEPENDANT,
	VARIABLEFLOWPRESSUREINDEPENDANT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAirTerminalTypeEnum {
	DIFFUSER,
	GRILLE,
	LOUVRE,
	REGISTER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAirToAirHeatRecoveryTypeEnum {
	FIXEDPLATECOUNTERFLOWEXCHANGER,
	FIXEDPLATECROSSFLOWEXCHANGER,
	FIXEDPLATEPARALLELFLOWEXCHANGER,
	ROTARYWHEEL,
	RUNAROUNDCOILLOOP,
	HEATPIPE,
	TWINTOWERENTHALPYRECOVERYLOOPS,
	THERMOSIPHONSEALEDTUBEHEATEXCHANGERS,
	THERMOSIPHONCOILTYPEHEATEXCHANGERS,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAlarmTypeEnum {
	BELL,
	BREAKGLASSBUTTON,
	LIGHT,
	MANUALPULLBOX,
	SIREN,
	WHISTLE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAlignmentTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAnalysisModelTypeEnum {
	IN_PLANE_LOADING_2D,
	OUT_PLANE_LOADING_2D,
	LOADING_3D,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcAnalysisTheoryTypeEnum {
	FIRST_ORDER_THEORY,
	SECOND_ORDER_THEORY,
	THIRD_ORDER_THEORY,
	FULL_NONLINEAR_THEORY,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcArithmeticOperatorEnum {
	ADD,
	DIVIDE,
	MULTIPLY,
	SUBTRACT
};
export enum IfcAssemblyPlaceEnum {
	SITE,
	FACTORY,
	NOTDEFINED
};
export enum IfcAudioVisualApplianceTypeEnum {
	AMPLIFIER,
	CAMERA,
	DISPLAY,
	MICROPHONE,
	PLAYER,
	PROJECTOR,
	RECEIVER,
	SPEAKER,
	SWITCHER,
	TELEPHONE,
	TUNER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBSplineCurveForm {
	POLYLINE_FORM,
	CIRCULAR_ARC,
	ELLIPTIC_ARC,
	PARABOLIC_ARC,
	HYPERBOLIC_ARC,
	UNSPECIFIED
};
export enum IfcBSplineSurfaceForm {
	PLANE_SURF,
	CYLINDRICAL_SURF,
	CONICAL_SURF,
	SPHERICAL_SURF,
	TOROIDAL_SURF,
	SURF_OF_REVOLUTION,
	RULED_SURF,
	GENERALISED_CONE,
	QUADRIC_SURF,
	SURF_OF_LINEAR_EXTRUSION,
	UNSPECIFIED
};
export enum IfcBeamTypeEnum {
	BEAM,
	JOIST,
	HOLLOWCORE,
	LINTEL,
	SPANDREL,
	T_BEAM,
	GIRDER_SEGMENT,
	DIAPHRAGM,
	PIERCAP,
	HATSTONE,
	CORNICE,
	EDGEBEAM,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBearingTypeDisplacementEnum {
	FIXED_MOVEMENT,
	GUIDED_LONGITUDINAL,
	GUIDED_TRANSVERSAL,
	FREE_MOVEMENT,
	NOTDEFINED
};
export enum IfcBearingTypeEnum {
	CYLINDRICAL,
	SPHERICAL,
	ELASTOMERIC,
	POT,
	GUIDE,
	ROCKER,
	ROLLER,
	DISK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBenchmarkEnum {
	GREATERTHAN,
	GREATERTHANOREQUALTO,
	LESSTHAN,
	LESSTHANOREQUALTO,
	EQUALTO,
	NOTEQUALTO,
	INCLUDES,
	NOTINCLUDES,
	INCLUDEDIN,
	NOTINCLUDEDIN
};
export enum IfcBoilerTypeEnum {
	WATER,
	STEAM,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBooleanOperator {
	UNION,
	INTERSECTION,
	DIFFERENCE
};
export enum IfcBridgePartTypeEnum {
	ABUTMENT,
	DECK,
	DECK_SEGMENT,
	FOUNDATION,
	PIER,
	PIER_SEGMENT,
	PYLON,
	SUBSTRUCTURE,
	SUPERSTRUCTURE,
	SURFACESTRUCTURE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBridgeTypeEnum {
	ARCHED,
	CABLE_STAYED,
	CANTILEVER,
	CULVERT,
	FRAMEWORK,
	GIRDER,
	SUSPENSION,
	TRUSS,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBuildingElementPartTypeEnum {
	INSULATION,
	PRECASTPANEL,
	APRON,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBuildingElementProxyTypeEnum {
	COMPLEX,
	ELEMENT,
	PARTIAL,
	PROVISIONFORVOID,
	PROVISIONFORSPACE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBuildingSystemTypeEnum {
	FENESTRATION,
	FOUNDATION,
	LOADBEARING,
	OUTERSHELL,
	SHADING,
	TRANSPORT,
	REINFORCING,
	PRESTRESSING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcBurnerTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCableCarrierFittingTypeEnum {
	BEND,
	CROSS,
	REDUCER,
	TEE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCableCarrierSegmentTypeEnum {
	CABLELADDERSEGMENT,
	CABLETRAYSEGMENT,
	CABLETRUNKINGSEGMENT,
	CONDUITSEGMENT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCableFittingTypeEnum {
	CONNECTOR,
	ENTRY,
	EXIT,
	JUNCTION,
	TRANSITION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCableSegmentTypeEnum {
	BUSBARSEGMENT,
	CABLESEGMENT,
	CONDUCTORSEGMENT,
	CORESEGMENT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCaissonFoundationTypeEnum {
	WELL,
	CAISSON,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcChangeActionEnum {
	NOCHANGE,
	MODIFIED,
	ADDED,
	DELETED,
	NOTDEFINED
};
export enum IfcChillerTypeEnum {
	AIRCOOLED,
	WATERCOOLED,
	HEATRECOVERY,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcChimneyTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCoilTypeEnum {
	DXCOOLINGCOIL,
	ELECTRICHEATINGCOIL,
	GASHEATINGCOIL,
	HYDRONICCOIL,
	STEAMHEATINGCOIL,
	WATERCOOLINGCOIL,
	WATERHEATINGCOIL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcColumnTypeEnum {
	COLUMN,
	PILASTER,
	PIERSTEM,
	PIERSTEM_SEGMENT,
	STANDCOLUMN,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCommunicationsApplianceTypeEnum {
	ANTENNA,
	COMPUTER,
	FAX,
	GATEWAY,
	MODEM,
	NETWORKAPPLIANCE,
	NETWORKBRIDGE,
	NETWORKHUB,
	PRINTER,
	REPEATER,
	ROUTER,
	SCANNER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcComplexPropertyTemplateTypeEnum {
	P_COMPLEX,
	Q_COMPLEX
};
export enum IfcCompressorTypeEnum {
	DYNAMIC,
	RECIPROCATING,
	ROTARY,
	SCROLL,
	TROCHOIDAL,
	SINGLESTAGE,
	BOOSTER,
	OPENTYPE,
	HERMETIC,
	SEMIHERMETIC,
	WELDEDSHELLHERMETIC,
	ROLLINGPISTON,
	ROTARYVANE,
	SINGLESCREW,
	TWINSCREW,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCondenserTypeEnum {
	AIRCOOLED,
	EVAPORATIVECOOLED,
	WATERCOOLED,
	WATERCOOLEDBRAZEDPLATE,
	WATERCOOLEDSHELLCOIL,
	WATERCOOLEDSHELLTUBE,
	WATERCOOLEDTUBEINTUBE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcConnectionTypeEnum {
	ATPATH,
	ATSTART,
	ATEND,
	NOTDEFINED
};
export enum IfcConstraintEnum {
	HARD,
	SOFT,
	ADVISORY,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcConstructionEquipmentResourceTypeEnum {
	DEMOLISHING,
	EARTHMOVING,
	ERECTING,
	HEATING,
	LIGHTING,
	PAVING,
	PUMPING,
	TRANSPORTING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcConstructionMaterialResourceTypeEnum {
	AGGREGATES,
	CONCRETE,
	DRYWALL,
	FUEL,
	GYPSUM,
	MASONRY,
	METAL,
	PLASTIC,
	WOOD,
	NOTDEFINED,
	USERDEFINED
};
export enum IfcConstructionProductResourceTypeEnum {
	ASSEMBLY,
	FORMWORK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcControllerTypeEnum {
	FLOATING,
	PROGRAMMABLE,
	PROPORTIONAL,
	MULTIPOSITION,
	TWOPOSITION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCooledBeamTypeEnum {
	ACTIVE,
	PASSIVE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCoolingTowerTypeEnum {
	NATURALDRAFT,
	MECHANICALINDUCEDDRAFT,
	MECHANICALFORCEDDRAFT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCostItemTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCostScheduleTypeEnum {
	BUDGET,
	COSTPLAN,
	ESTIMATE,
	TENDER,
	PRICEDBILLOFQUANTITIES,
	UNPRICEDBILLOFQUANTITIES,
	SCHEDULEOFRATES,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCoveringTypeEnum {
	CEILING,
	FLOORING,
	CLADDING,
	ROOFING,
	MOLDING,
	SKIRTINGBOARD,
	INSULATION,
	MEMBRANE,
	SLEEVING,
	WRAPPING,
	COPING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCrewResourceTypeEnum {
	OFFICE,
	SITE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCurtainWallTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcCurveInterpolationEnum {
	LINEAR,
	LOG_LINEAR,
	LOG_LOG,
	NOTDEFINED
};
export enum IfcDamperTypeEnum {
	BACKDRAFTDAMPER,
	BALANCINGDAMPER,
	BLASTDAMPER,
	CONTROLDAMPER,
	FIREDAMPER,
	FIRESMOKEDAMPER,
	FUMEHOODEXHAUST,
	GRAVITYDAMPER,
	GRAVITYRELIEFDAMPER,
	RELIEFDAMPER,
	SMOKEDAMPER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDataOriginEnum {
	MEASURED,
	PREDICTED,
	SIMULATED,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDerivedUnitEnum {
	ANGULARVELOCITYUNIT,
	AREADENSITYUNIT,
	COMPOUNDPLANEANGLEUNIT,
	DYNAMICVISCOSITYUNIT,
	HEATFLUXDENSITYUNIT,
	INTEGERCOUNTRATEUNIT,
	ISOTHERMALMOISTURECAPACITYUNIT,
	KINEMATICVISCOSITYUNIT,
	LINEARVELOCITYUNIT,
	MASSDENSITYUNIT,
	MASSFLOWRATEUNIT,
	MOISTUREDIFFUSIVITYUNIT,
	MOLECULARWEIGHTUNIT,
	SPECIFICHEATCAPACITYUNIT,
	THERMALADMITTANCEUNIT,
	THERMALCONDUCTANCEUNIT,
	THERMALRESISTANCEUNIT,
	THERMALTRANSMITTANCEUNIT,
	VAPORPERMEABILITYUNIT,
	VOLUMETRICFLOWRATEUNIT,
	ROTATIONALFREQUENCYUNIT,
	TORQUEUNIT,
	MOMENTOFINERTIAUNIT,
	LINEARMOMENTUNIT,
	LINEARFORCEUNIT,
	PLANARFORCEUNIT,
	MODULUSOFELASTICITYUNIT,
	SHEARMODULUSUNIT,
	LINEARSTIFFNESSUNIT,
	ROTATIONALSTIFFNESSUNIT,
	MODULUSOFSUBGRADEREACTIONUNIT,
	ACCELERATIONUNIT,
	CURVATUREUNIT,
	HEATINGVALUEUNIT,
	IONCONCENTRATIONUNIT,
	LUMINOUSINTENSITYDISTRIBUTIONUNIT,
	MASSPERLENGTHUNIT,
	MODULUSOFLINEARSUBGRADEREACTIONUNIT,
	MODULUSOFROTATIONALSUBGRADEREACTIONUNIT,
	PHUNIT,
	ROTATIONALMASSUNIT,
	SECTIONAREAINTEGRALUNIT,
	SECTIONMODULUSUNIT,
	SOUNDPOWERLEVELUNIT,
	SOUNDPOWERUNIT,
	SOUNDPRESSURELEVELUNIT,
	SOUNDPRESSUREUNIT,
	TEMPERATUREGRADIENTUNIT,
	TEMPERATURERATEOFCHANGEUNIT,
	THERMALEXPANSIONCOEFFICIENTUNIT,
	WARPINGCONSTANTUNIT,
	WARPINGMOMENTUNIT,
	USERDEFINED
};
export enum IfcDirectionSenseEnum {
	POSITIVE,
	NEGATIVE
};
export enum IfcDiscreteAccessoryTypeEnum {
	ANCHORPLATE,
	BRACKET,
	SHOE,
	EXPANSION_JOINT_DEVICE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDistributionChamberElementTypeEnum {
	FORMEDDUCT,
	INSPECTIONCHAMBER,
	INSPECTIONPIT,
	MANHOLE,
	METERCHAMBER,
	SUMP,
	TRENCH,
	VALVECHAMBER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDistributionPortTypeEnum {
	CABLE,
	CABLECARRIER,
	DUCT,
	PIPE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDistributionSystemEnum {
	AIRCONDITIONING,
	AUDIOVISUAL,
	CHEMICAL,
	CHILLEDWATER,
	COMMUNICATION,
	COMPRESSEDAIR,
	CONDENSERWATER,
	CONTROL,
	CONVEYING,
	DATA,
	DISPOSAL,
	DOMESTICCOLDWATER,
	DOMESTICHOTWATER,
	DRAINAGE,
	EARTHING,
	ELECTRICAL,
	ELECTROACOUSTIC,
	EXHAUST,
	FIREPROTECTION,
	FUEL,
	GAS,
	HAZARDOUS,
	HEATING,
	LIGHTING,
	LIGHTNINGPROTECTION,
	MUNICIPALSOLIDWASTE,
	OIL,
	OPERATIONAL,
	POWERGENERATION,
	RAINWATER,
	REFRIGERATION,
	SECURITY,
	SEWAGE,
	SIGNAL,
	STORMWATER,
	TELEPHONE,
	TV,
	VACUUM,
	VENT,
	VENTILATION,
	WASTEWATER,
	WATERSUPPLY,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDocumentConfidentialityEnum {
	PUBLIC,
	RESTRICTED,
	CONFIDENTIAL,
	PERSONAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDocumentStatusEnum {
	DRAFT,
	FINALDRAFT,
	FINAL,
	REVISION,
	NOTDEFINED
};
export enum IfcDoorPanelOperationEnum {
	SWINGING,
	DOUBLE_ACTING,
	SLIDING,
	FOLDING,
	REVOLVING,
	ROLLINGUP,
	FIXEDPANEL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDoorPanelPositionEnum {
	LEFT,
	MIDDLE,
	RIGHT,
	NOTDEFINED
};
export enum IfcDoorStyleConstructionEnum {
	ALUMINIUM,
	HIGH_GRADE_STEEL,
	STEEL,
	WOOD,
	ALUMINIUM_WOOD,
	ALUMINIUM_PLASTIC,
	PLASTIC,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDoorStyleOperationEnum {
	SINGLE_SWING_LEFT,
	SINGLE_SWING_RIGHT,
	DOUBLE_DOOR_SINGLE_SWING,
	DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT,
	DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT,
	DOUBLE_SWING_LEFT,
	DOUBLE_SWING_RIGHT,
	DOUBLE_DOOR_DOUBLE_SWING,
	SLIDING_TO_LEFT,
	SLIDING_TO_RIGHT,
	DOUBLE_DOOR_SLIDING,
	FOLDING_TO_LEFT,
	FOLDING_TO_RIGHT,
	DOUBLE_DOOR_FOLDING,
	REVOLVING,
	ROLLINGUP,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDoorTypeEnum {
	DOOR,
	GATE,
	TRAPDOOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDoorTypeOperationEnum {
	SINGLE_SWING_LEFT,
	SINGLE_SWING_RIGHT,
	DOUBLE_DOOR_SINGLE_SWING,
	DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT,
	DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT,
	DOUBLE_SWING_LEFT,
	DOUBLE_SWING_RIGHT,
	DOUBLE_DOOR_DOUBLE_SWING,
	SLIDING_TO_LEFT,
	SLIDING_TO_RIGHT,
	DOUBLE_DOOR_SLIDING,
	FOLDING_TO_LEFT,
	FOLDING_TO_RIGHT,
	DOUBLE_DOOR_FOLDING,
	REVOLVING,
	ROLLINGUP,
	SWING_FIXED_LEFT,
	SWING_FIXED_RIGHT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDuctFittingTypeEnum {
	BEND,
	CONNECTOR,
	ENTRY,
	EXIT,
	JUNCTION,
	OBSTRUCTION,
	TRANSITION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDuctSegmentTypeEnum {
	RIGIDSEGMENT,
	FLEXIBLESEGMENT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcDuctSilencerTypeEnum {
	FLATOVAL,
	RECTANGULAR,
	ROUND,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElectricApplianceTypeEnum {
	DISHWASHER,
	ELECTRICCOOKER,
	FREESTANDINGELECTRICHEATER,
	FREESTANDINGFAN,
	FREESTANDINGWATERHEATER,
	FREESTANDINGWATERCOOLER,
	FREEZER,
	FRIDGE_FREEZER,
	HANDDRYER,
	KITCHENMACHINE,
	MICROWAVE,
	PHOTOCOPIER,
	REFRIGERATOR,
	TUMBLEDRYER,
	VENDINGMACHINE,
	WASHINGMACHINE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElectricDistributionBoardTypeEnum {
	CONSUMERUNIT,
	DISTRIBUTIONBOARD,
	MOTORCONTROLCENTRE,
	SWITCHBOARD,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElectricFlowStorageDeviceTypeEnum {
	BATTERY,
	CAPACITORBANK,
	HARMONICFILTER,
	INDUCTORBANK,
	UPS,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElectricGeneratorTypeEnum {
	CHP,
	ENGINEGENERATOR,
	STANDALONE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElectricMotorTypeEnum {
	DC,
	INDUCTION,
	POLYPHASE,
	RELUCTANCESYNCHRONOUS,
	SYNCHRONOUS,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElectricTimeControlTypeEnum {
	TIMECLOCK,
	TIMEDELAY,
	RELAY,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElementAssemblyTypeEnum {
	ACCESSORY_ASSEMBLY,
	ARCH,
	BEAM_GRID,
	BRACED_FRAME,
	GIRDER,
	REINFORCEMENT_UNIT,
	RIGID_FRAME,
	SLAB_FIELD,
	TRUSS,
	ABUTMENT,
	PIER,
	PYLON,
	CROSS_BRACING,
	DECK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcElementCompositionEnum {
	COMPLEX,
	ELEMENT,
	PARTIAL
};
export enum IfcEngineTypeEnum {
	EXTERNALCOMBUSTION,
	INTERNALCOMBUSTION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcEvaporativeCoolerTypeEnum {
	DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER,
	DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER,
	DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER,
	DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER,
	DIRECTEVAPORATIVEAIRWASHER,
	INDIRECTEVAPORATIVEPACKAGEAIRCOOLER,
	INDIRECTEVAPORATIVEWETCOIL,
	INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER,
	INDIRECTDIRECTCOMBINATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcEvaporatorTypeEnum {
	DIRECTEXPANSION,
	DIRECTEXPANSIONSHELLANDTUBE,
	DIRECTEXPANSIONTUBEINTUBE,
	DIRECTEXPANSIONBRAZEDPLATE,
	FLOODEDSHELLANDTUBE,
	SHELLANDCOIL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcEventTriggerTypeEnum {
	EVENTRULE,
	EVENTMESSAGE,
	EVENTTIME,
	EVENTCOMPLEX,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcEventTypeEnum {
	STARTEVENT,
	ENDEVENT,
	INTERMEDIATEEVENT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcExternalSpatialElementTypeEnum {
	EXTERNAL,
	EXTERNAL_EARTH,
	EXTERNAL_WATER,
	EXTERNAL_FIRE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFanTypeEnum {
	CENTRIFUGALFORWARDCURVED,
	CENTRIFUGALRADIAL,
	CENTRIFUGALBACKWARDINCLINEDCURVED,
	CENTRIFUGALAIRFOIL,
	TUBEAXIAL,
	VANEAXIAL,
	PROPELLORAXIAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFastenerTypeEnum {
	GLUE,
	MORTAR,
	WELD,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFilterTypeEnum {
	AIRPARTICLEFILTER,
	COMPRESSEDAIRFILTER,
	ODORFILTER,
	OILFILTER,
	STRAINER,
	WATERFILTER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFireSuppressionTerminalTypeEnum {
	BREECHINGINLET,
	FIREHYDRANT,
	HOSEREEL,
	SPRINKLER,
	SPRINKLERDEFLECTOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFlowDirectionEnum {
	SOURCE,
	SINK,
	SOURCEANDSINK,
	NOTDEFINED
};
export enum IfcFlowInstrumentTypeEnum {
	PRESSUREGAUGE,
	THERMOMETER,
	AMMETER,
	FREQUENCYMETER,
	POWERFACTORMETER,
	PHASEANGLEMETER,
	VOLTMETER_PEAK,
	VOLTMETER_RMS,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFlowMeterTypeEnum {
	ENERGYMETER,
	GASMETER,
	OILMETER,
	WATERMETER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFootingTypeEnum {
	CAISSON_FOUNDATION,
	FOOTING_BEAM,
	PAD_FOOTING,
	PILE_CAP,
	STRIP_FOOTING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcFurnitureTypeEnum {
	CHAIR,
	TABLE,
	DESK,
	BED,
	FILECABINET,
	SHELF,
	SOFA,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcGeographicElementTypeEnum {
	TERRAIN,
	SOIL_BORING_POINT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcGeometricProjectionEnum {
	GRAPH_VIEW,
	SKETCH_VIEW,
	MODEL_VIEW,
	PLAN_VIEW,
	REFLECTED_PLAN_VIEW,
	SECTION_VIEW,
	ELEVATION_VIEW,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcGlobalOrLocalEnum {
	GLOBAL_COORDS,
	LOCAL_COORDS
};
export enum IfcGridTypeEnum {
	RECTANGULAR,
	RADIAL,
	TRIANGULAR,
	IRREGULAR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcHeatExchangerTypeEnum {
	PLATE,
	SHELLANDTUBE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcHumidifierTypeEnum {
	STEAMINJECTION,
	ADIABATICAIRWASHER,
	ADIABATICPAN,
	ADIABATICWETTEDELEMENT,
	ADIABATICATOMIZING,
	ADIABATICULTRASONIC,
	ADIABATICRIGIDMEDIA,
	ADIABATICCOMPRESSEDAIRNOZZLE,
	ASSISTEDELECTRIC,
	ASSISTEDNATURALGAS,
	ASSISTEDPROPANE,
	ASSISTEDBUTANE,
	ASSISTEDSTEAM,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcInterceptorTypeEnum {
	CYCLONIC,
	GREASE,
	OIL,
	PETROL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcInternalOrExternalEnum {
	INTERNAL,
	EXTERNAL,
	EXTERNAL_EARTH,
	EXTERNAL_WATER,
	EXTERNAL_FIRE,
	NOTDEFINED
};
export enum IfcInventoryTypeEnum {
	ASSETINVENTORY,
	SPACEINVENTORY,
	FURNITUREINVENTORY,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcJunctionBoxTypeEnum {
	DATA,
	POWER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcKnotType {
	UNIFORM_KNOTS,
	QUASI_UNIFORM_KNOTS,
	PIECEWISE_BEZIER_KNOTS,
	UNSPECIFIED
};
export enum IfcLaborResourceTypeEnum {
	ADMINISTRATION,
	CARPENTRY,
	CLEANING,
	CONCRETE,
	DRYWALL,
	ELECTRIC,
	FINISHING,
	FLOORING,
	GENERAL,
	HVAC,
	LANDSCAPING,
	MASONRY,
	PAINTING,
	PAVING,
	PLUMBING,
	ROOFING,
	SITEGRADING,
	STEELWORK,
	SURVEYING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcLampTypeEnum {
	COMPACTFLUORESCENT,
	FLUORESCENT,
	HALOGEN,
	HIGHPRESSUREMERCURY,
	HIGHPRESSURESODIUM,
	LED,
	METALHALIDE,
	OLED,
	TUNGSTENFILAMENT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcLayerSetDirectionEnum {
	AXIS1,
	AXIS2,
	AXIS3
};
export enum IfcLightDistributionCurveEnum {
	TYPE_A,
	TYPE_B,
	TYPE_C,
	NOTDEFINED
};
export enum IfcLightEmissionSourceEnum {
	COMPACTFLUORESCENT,
	FLUORESCENT,
	HIGHPRESSUREMERCURY,
	HIGHPRESSURESODIUM,
	LIGHTEMITTINGDIODE,
	LOWPRESSURESODIUM,
	LOWVOLTAGEHALOGEN,
	MAINVOLTAGEHALOGEN,
	METALHALIDE,
	TUNGSTENFILAMENT,
	NOTDEFINED
};
export enum IfcLightFixtureTypeEnum {
	POINTSOURCE,
	DIRECTIONSOURCE,
	SECURITYLIGHTING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcLoadGroupTypeEnum {
	LOAD_GROUP,
	LOAD_CASE,
	LOAD_COMBINATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcLogicalOperatorEnum {
	LOGICALAND,
	LOGICALOR,
	LOGICALXOR,
	LOGICALNOTAND,
	LOGICALNOTOR
};
export enum IfcMechanicalFastenerTypeEnum {
	ANCHORBOLT,
	BOLT,
	DOWEL,
	NAIL,
	NAILPLATE,
	RIVET,
	SCREW,
	SHEARCONNECTOR,
	STAPLE,
	STUDSHEARCONNECTOR,
	COUPLER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcMedicalDeviceTypeEnum {
	AIRSTATION,
	FEEDAIRUNIT,
	OXYGENGENERATOR,
	OXYGENPLANT,
	VACUUMSTATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcMemberTypeEnum {
	BRACE,
	CHORD,
	COLLAR,
	MEMBER,
	MULLION,
	PLATE,
	POST,
	PURLIN,
	RAFTER,
	STRINGER,
	STRUT,
	STUD,
	STIFFENING_RIB,
	ARCH_SEGMENT,
	SUSPENSION_CABLE,
	SUSPENDER,
	STAY_CABLE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcMotorConnectionTypeEnum {
	BELTDRIVE,
	COUPLING,
	DIRECTDRIVE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcNullStyle {
	NULL
};
export enum IfcObjectTypeEnum {
	PRODUCT,
	PROCESS,
	CONTROL,
	RESOURCE,
	ACTOR,
	GROUP,
	PROJECT,
	NOTDEFINED
};
export enum IfcObjectiveEnum {
	CODECOMPLIANCE,
	CODEWAIVER,
	DESIGNINTENT,
	EXTERNAL,
	HEALTHANDSAFETY,
	MERGECONFLICT,
	MODELVIEW,
	PARAMETER,
	REQUIREMENT,
	SPECIFICATION,
	TRIGGERCONDITION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcOccupantTypeEnum {
	ASSIGNEE,
	ASSIGNOR,
	LESSEE,
	LESSOR,
	LETTINGAGENT,
	OWNER,
	TENANT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcOpeningElementTypeEnum {
	OPENING,
	RECESS,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcOutletTypeEnum {
	AUDIOVISUALOUTLET,
	COMMUNICATIONSOUTLET,
	POWEROUTLET,
	DATAOUTLET,
	TELEPHONEOUTLET,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPerformanceHistoryTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPermeableCoveringOperationEnum {
	GRILL,
	LOUVER,
	SCREEN,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPermitTypeEnum {
	ACCESS,
	BUILDING,
	WORK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPhysicalOrVirtualEnum {
	PHYSICAL,
	VIRTUAL,
	NOTDEFINED
};
export enum IfcPileConstructionEnum {
	CAST_IN_PLACE,
	COMPOSITE,
	PRECAST_CONCRETE,
	PREFAB_STEEL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPileTypeEnum {
	BORED,
	DRIVEN,
	JETGROUTING,
	COHESION,
	FRICTION,
	SUPPORT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPipeFittingTypeEnum {
	BEND,
	CONNECTOR,
	ENTRY,
	EXIT,
	JUNCTION,
	OBSTRUCTION,
	TRANSITION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPipeSegmentTypeEnum {
	CULVERT,
	FLEXIBLESEGMENT,
	RIGIDSEGMENT,
	GUTTER,
	SPOOL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPlateTypeEnum {
	CURTAIN_PANEL,
	SHEET,
	FLANGE_PLATE,
	WEB_PLATE,
	STIFFENER_PLATE,
	GUSSET_PLATE,
	COVER_PLATE,
	SPLICE_PLATE,
	BASE_PLATE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPreferredSurfaceCurveRepresentation {
	CURVE3D,
	PCURVE_S1,
	PCURVE_S2
};
export enum IfcProcedureTypeEnum {
	ADVICE_CAUTION,
	ADVICE_NOTE,
	ADVICE_WARNING,
	CALIBRATION,
	DIAGNOSTIC,
	SHUTDOWN,
	STARTUP,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcProfileTypeEnum {
	CURVE,
	AREA
};
export enum IfcProjectOrderTypeEnum {
	CHANGEORDER,
	MAINTENANCEWORKORDER,
	MOVEORDER,
	PURCHASEORDER,
	WORKORDER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcProjectedOrTrueLengthEnum {
	PROJECTED_LENGTH,
	TRUE_LENGTH
};
export enum IfcProjectionElementTypeEnum {
	BLISTER,
	DEVIATOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPropertySetTemplateTypeEnum {
	PSET_TYPEDRIVENONLY,
	PSET_TYPEDRIVENOVERRIDE,
	PSET_OCCURRENCEDRIVEN,
	PSET_PERFORMANCEDRIVEN,
	QTO_TYPEDRIVENONLY,
	QTO_TYPEDRIVENOVERRIDE,
	QTO_OCCURRENCEDRIVEN,
	NOTDEFINED
};
export enum IfcProtectiveDeviceTrippingUnitTypeEnum {
	ELECTRONIC,
	ELECTROMAGNETIC,
	RESIDUALCURRENT,
	THERMAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcProtectiveDeviceTypeEnum {
	CIRCUITBREAKER,
	EARTHLEAKAGECIRCUITBREAKER,
	EARTHINGSWITCH,
	FUSEDISCONNECTOR,
	RESIDUALCURRENTCIRCUITBREAKER,
	RESIDUALCURRENTSWITCH,
	VARISTOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcPumpTypeEnum {
	CIRCULATOR,
	ENDSUCTION,
	SPLITCASE,
	SUBMERSIBLEPUMP,
	SUMPPUMP,
	VERTICALINLINE,
	VERTICALTURBINE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcRailingTypeEnum {
	HANDRAIL,
	GUARDRAIL,
	BALUSTRADE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcRampFlightTypeEnum {
	STRAIGHT,
	SPIRAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcRampTypeEnum {
	STRAIGHT_RUN_RAMP,
	TWO_STRAIGHT_RUN_RAMP,
	QUARTER_TURN_RAMP,
	TWO_QUARTER_TURN_RAMP,
	HALF_TURN_RAMP,
	SPIRAL_RAMP,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcRecurrenceTypeEnum {
	DAILY,
	WEEKLY,
	MONTHLY_BY_DAY_OF_MONTH,
	MONTHLY_BY_POSITION,
	BY_DAY_COUNT,
	BY_WEEKDAY_COUNT,
	YEARLY_BY_DAY_OF_MONTH,
	YEARLY_BY_POSITION
};
export enum IfcReferentTypeEnum {
	KILOPOINT,
	MILEPOINT,
	STATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcReflectanceMethodEnum {
	BLINN,
	FLAT,
	GLASS,
	MATT,
	METAL,
	MIRROR,
	PHONG,
	PLASTIC,
	STRAUSS,
	NOTDEFINED
};
export enum IfcReinforcingBarRoleEnum {
	MAIN,
	SHEAR,
	LIGATURE,
	STUD,
	PUNCHING,
	EDGE,
	RING,
	ANCHORING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcReinforcingBarSurfaceEnum {
	PLAIN,
	TEXTURED
};
export enum IfcReinforcingBarTypeEnum {
	ANCHORING,
	EDGE,
	LIGATURE,
	MAIN,
	PUNCHING,
	RING,
	SHEAR,
	STUD,
	SPACEBAR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcReinforcingMeshTypeEnum {
	USERDEFINED,
	NOTDEFINED
};
export enum IfcRoleEnum {
	SUPPLIER,
	MANUFACTURER,
	CONTRACTOR,
	SUBCONTRACTOR,
	ARCHITECT,
	STRUCTURALENGINEER,
	COSTENGINEER,
	CLIENT,
	BUILDINGOWNER,
	BUILDINGOPERATOR,
	MECHANICALENGINEER,
	ELECTRICALENGINEER,
	PROJECTMANAGER,
	FACILITIESMANAGER,
	CIVILENGINEER,
	COMMISSIONINGENGINEER,
	ENGINEER,
	OWNER,
	CONSULTANT,
	CONSTRUCTIONMANAGER,
	FIELDCONSTRUCTIONMANAGER,
	RESELLER,
	USERDEFINED
};
export enum IfcRoofTypeEnum {
	FLAT_ROOF,
	SHED_ROOF,
	GABLE_ROOF,
	HIP_ROOF,
	HIPPED_GABLE_ROOF,
	GAMBREL_ROOF,
	MANSARD_ROOF,
	BARREL_ROOF,
	RAINBOW_ROOF,
	BUTTERFLY_ROOF,
	PAVILION_ROOF,
	DOME_ROOF,
	FREEFORM,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSIPrefix {
	EXA,
	PETA,
	TERA,
	GIGA,
	MEGA,
	KILO,
	HECTO,
	DECA,
	DECI,
	CENTI,
	MILLI,
	MICRO,
	NANO,
	PICO,
	FEMTO,
	ATTO
};
export enum IfcSIUnitName {
	AMPERE,
	BECQUEREL,
	CANDELA,
	COULOMB,
	CUBIC_METRE,
	DEGREE_CELSIUS,
	FARAD,
	GRAM,
	GRAY,
	HENRY,
	HERTZ,
	JOULE,
	KELVIN,
	LUMEN,
	LUX,
	METRE,
	MOLE,
	NEWTON,
	OHM,
	PASCAL,
	RADIAN,
	SECOND,
	SIEMENS,
	SIEVERT,
	SQUARE_METRE,
	STERADIAN,
	TESLA,
	VOLT,
	WATT,
	WEBER
};
export enum IfcSanitaryTerminalTypeEnum {
	BATH,
	BIDET,
	CISTERN,
	SHOWER,
	SINK,
	SANITARYFOUNTAIN,
	TOILETPAN,
	URINAL,
	WASHHANDBASIN,
	WCSEAT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSectionTypeEnum {
	UNIFORM,
	TAPERED
};
export enum IfcSensorTypeEnum {
	COSENSOR,
	CO2SENSOR,
	CONDUCTANCESENSOR,
	CONTACTSENSOR,
	FIRESENSOR,
	FLOWSENSOR,
	FROSTSENSOR,
	GASSENSOR,
	HEATSENSOR,
	HUMIDITYSENSOR,
	IDENTIFIERSENSOR,
	IONCONCENTRATIONSENSOR,
	LEVELSENSOR,
	LIGHTSENSOR,
	MOISTURESENSOR,
	MOVEMENTSENSOR,
	PHSENSOR,
	PRESSURESENSOR,
	RADIATIONSENSOR,
	RADIOACTIVITYSENSOR,
	SMOKESENSOR,
	SOUNDSENSOR,
	TEMPERATURESENSOR,
	WINDSENSOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSequenceEnum {
	START_START,
	START_FINISH,
	FINISH_START,
	FINISH_FINISH,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcShadingDeviceTypeEnum {
	JALOUSIE,
	SHUTTER,
	AWNING,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSimplePropertyTemplateTypeEnum {
	P_SINGLEVALUE,
	P_ENUMERATEDVALUE,
	P_BOUNDEDVALUE,
	P_LISTVALUE,
	P_TABLEVALUE,
	P_REFERENCEVALUE,
	Q_LENGTH,
	Q_AREA,
	Q_VOLUME,
	Q_COUNT,
	Q_WEIGHT,
	Q_TIME
};
export enum IfcSlabTypeEnum {
	FLOOR,
	ROOF,
	LANDING,
	BASESLAB,
	APPROACH_SLAB,
	PAVING,
	WEARING,
	SIDEWALK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSolarDeviceTypeEnum {
	SOLARCOLLECTOR,
	SOLARPANEL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSpaceHeaterTypeEnum {
	CONVECTOR,
	RADIATOR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSpaceTypeEnum {
	SPACE,
	PARKING,
	GFA,
	INTERNAL,
	EXTERNAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSpatialZoneTypeEnum {
	CONSTRUCTION,
	FIRESAFETY,
	LIGHTING,
	OCCUPANCY,
	SECURITY,
	THERMAL,
	TRANSPORT,
	VENTILATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStackTerminalTypeEnum {
	BIRDCAGE,
	COWL,
	RAINWATERHOPPER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStairFlightTypeEnum {
	STRAIGHT,
	WINDER,
	SPIRAL,
	CURVED,
	FREEFORM,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStairTypeEnum {
	STRAIGHT_RUN_STAIR,
	TWO_STRAIGHT_RUN_STAIR,
	QUARTER_WINDING_STAIR,
	QUARTER_TURN_STAIR,
	HALF_WINDING_STAIR,
	HALF_TURN_STAIR,
	TWO_QUARTER_WINDING_STAIR,
	TWO_QUARTER_TURN_STAIR,
	THREE_QUARTER_WINDING_STAIR,
	THREE_QUARTER_TURN_STAIR,
	SPIRAL_STAIR,
	DOUBLE_RETURN_STAIR,
	CURVED_RUN_STAIR,
	TWO_CURVED_RUN_STAIR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStateEnum {
	READWRITE,
	READONLY,
	LOCKED,
	READWRITELOCKED,
	READONLYLOCKED
};
export enum IfcStructuralCurveActivityTypeEnum {
	CONST,
	LINEAR,
	POLYGONAL,
	EQUIDISTANT,
	SINUS,
	PARABOLA,
	DISCRETE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStructuralCurveMemberTypeEnum {
	RIGID_JOINED_MEMBER,
	PIN_JOINED_MEMBER,
	CABLE,
	TENSION_MEMBER,
	COMPRESSION_MEMBER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStructuralSurfaceActivityTypeEnum {
	CONST,
	BILINEAR,
	DISCRETE,
	ISOCONTOUR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcStructuralSurfaceMemberTypeEnum {
	BENDING_ELEMENT,
	MEMBRANE_ELEMENT,
	SHELL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSubContractResourceTypeEnum {
	PURCHASE,
	WORK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSurfaceFeatureTypeEnum {
	MARK,
	TAG,
	TREATMENT,
	DEFECT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSurfaceSide {
	POSITIVE,
	NEGATIVE,
	BOTH
};
export enum IfcSwitchingDeviceTypeEnum {
	CONTACTOR,
	DIMMERSWITCH,
	EMERGENCYSTOP,
	KEYPAD,
	MOMENTARYSWITCH,
	SELECTORSWITCH,
	STARTER,
	SWITCHDISCONNECTOR,
	TOGGLESWITCH,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcSystemFurnitureElementTypeEnum {
	PANEL,
	WORKSURFACE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTankTypeEnum {
	BASIN,
	BREAKPRESSURE,
	EXPANSION,
	FEEDANDEXPANSION,
	PRESSUREVESSEL,
	STORAGE,
	VESSEL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTaskDurationEnum {
	ELAPSEDTIME,
	WORKTIME,
	NOTDEFINED
};
export enum IfcTaskTypeEnum {
	ATTENDANCE,
	CONSTRUCTION,
	DEMOLITION,
	DISMANTLE,
	DISPOSAL,
	INSTALLATION,
	LOGISTIC,
	MAINTENANCE,
	MOVE,
	OPERATION,
	REMOVAL,
	RENOVATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTendonAnchorTypeEnum {
	COUPLER,
	FIXED_END,
	TENSIONING_END,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTendonConduitTypeEnum {
	DUCT,
	COUPLER,
	GROUTING_DUCT,
	TRUMPET,
	DIABOLO,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTendonTypeEnum {
	BAR,
	COATED,
	STRAND,
	WIRE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTextPath {
	LEFT,
	RIGHT,
	UP,
	DOWN
};
export enum IfcTimeSeriesDataTypeEnum {
	CONTINUOUS,
	DISCRETE,
	DISCRETEBINARY,
	PIECEWISEBINARY,
	PIECEWISECONSTANT,
	PIECEWISECONTINUOUS,
	NOTDEFINED
};
export enum IfcTransformerTypeEnum {
	CURRENT,
	FREQUENCY,
	INVERTER,
	RECTIFIER,
	VOLTAGE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTransitionCode {
	DISCONTINUOUS,
	CONTINUOUS,
	CONTSAMEGRADIENT,
	CONTSAMEGRADIENTSAMECURVATURE
};
export enum IfcTransitionCurveType {
	BIQUADRATICPARABOLA,
	BLOSSCURVE,
	CLOTHOIDCURVE,
	COSINECURVE,
	CUBICPARABOLA,
	SINECURVE
};
export enum IfcTransportElementTypeEnum {
	ELEVATOR,
	ESCALATOR,
	MOVINGWALKWAY,
	CRANEWAY,
	LIFTINGGEAR,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcTrimmingPreference {
	CARTESIAN,
	PARAMETER,
	UNSPECIFIED
};
export enum IfcTubeBundleTypeEnum {
	FINNED,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcUnitEnum {
	ABSORBEDDOSEUNIT,
	AMOUNTOFSUBSTANCEUNIT,
	AREAUNIT,
	DOSEEQUIVALENTUNIT,
	ELECTRICCAPACITANCEUNIT,
	ELECTRICCHARGEUNIT,
	ELECTRICCONDUCTANCEUNIT,
	ELECTRICCURRENTUNIT,
	ELECTRICRESISTANCEUNIT,
	ELECTRICVOLTAGEUNIT,
	ENERGYUNIT,
	FORCEUNIT,
	FREQUENCYUNIT,
	ILLUMINANCEUNIT,
	INDUCTANCEUNIT,
	LENGTHUNIT,
	LUMINOUSFLUXUNIT,
	LUMINOUSINTENSITYUNIT,
	MAGNETICFLUXDENSITYUNIT,
	MAGNETICFLUXUNIT,
	MASSUNIT,
	PLANEANGLEUNIT,
	POWERUNIT,
	PRESSUREUNIT,
	RADIOACTIVITYUNIT,
	SOLIDANGLEUNIT,
	THERMODYNAMICTEMPERATUREUNIT,
	TIMEUNIT,
	VOLUMEUNIT,
	USERDEFINED
};
export enum IfcUnitaryControlElementTypeEnum {
	ALARMPANEL,
	CONTROLPANEL,
	GASDETECTIONPANEL,
	INDICATORPANEL,
	MIMICPANEL,
	HUMIDISTAT,
	THERMOSTAT,
	WEATHERSTATION,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcUnitaryEquipmentTypeEnum {
	AIRHANDLER,
	AIRCONDITIONINGUNIT,
	DEHUMIDIFIER,
	SPLITSYSTEM,
	ROOFTOPUNIT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcValveTypeEnum {
	AIRRELEASE,
	ANTIVACUUM,
	CHANGEOVER,
	CHECK,
	COMMISSIONING,
	DIVERTING,
	DRAWOFFCOCK,
	DOUBLECHECK,
	DOUBLEREGULATING,
	FAUCET,
	FLUSHING,
	GASCOCK,
	GASTAP,
	ISOLATING,
	MIXING,
	PRESSUREREDUCING,
	PRESSURERELIEF,
	REGULATING,
	SAFETYCUTOFF,
	STEAMTRAP,
	STOPCOCK,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcVibrationDamperTypeEnum {
	BENDING_YIELD,
	SHEAR_YIELD,
	AXIAL_YIELD,
	FRICTION,
	VISCOUS,
	RUBBER,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcVibrationIsolatorTypeEnum {
	COMPRESSION,
	SPRING,
	BASE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcVoidingFeatureTypeEnum {
	CUTOUT,
	NOTCH,
	HOLE,
	MITER,
	CHAMFER,
	EDGE,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWallTypeEnum {
	MOVABLE,
	PARAPET,
	PARTITIONING,
	PLUMBINGWALL,
	SHEAR,
	SOLIDWALL,
	STANDARD,
	POLYGONAL,
	ELEMENTEDWALL,
	RETAININGWALL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWasteTerminalTypeEnum {
	FLOORTRAP,
	FLOORWASTE,
	GULLYSUMP,
	GULLYTRAP,
	ROOFDRAIN,
	WASTEDISPOSALUNIT,
	WASTETRAP,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWindowPanelOperationEnum {
	SIDEHUNGRIGHTHAND,
	SIDEHUNGLEFTHAND,
	TILTANDTURNRIGHTHAND,
	TILTANDTURNLEFTHAND,
	TOPHUNG,
	BOTTOMHUNG,
	PIVOTHORIZONTAL,
	PIVOTVERTICAL,
	SLIDINGHORIZONTAL,
	SLIDINGVERTICAL,
	REMOVABLECASEMENT,
	FIXEDCASEMENT,
	OTHEROPERATION,
	NOTDEFINED
};
export enum IfcWindowPanelPositionEnum {
	LEFT,
	MIDDLE,
	RIGHT,
	BOTTOM,
	TOP,
	NOTDEFINED
};
export enum IfcWindowStyleConstructionEnum {
	ALUMINIUM,
	HIGH_GRADE_STEEL,
	STEEL,
	WOOD,
	ALUMINIUM_WOOD,
	PLASTIC,
	OTHER_CONSTRUCTION,
	NOTDEFINED
};
export enum IfcWindowStyleOperationEnum {
	SINGLE_PANEL,
	DOUBLE_PANEL_VERTICAL,
	DOUBLE_PANEL_HORIZONTAL,
	TRIPLE_PANEL_VERTICAL,
	TRIPLE_PANEL_BOTTOM,
	TRIPLE_PANEL_TOP,
	TRIPLE_PANEL_LEFT,
	TRIPLE_PANEL_RIGHT,
	TRIPLE_PANEL_HORIZONTAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWindowTypeEnum {
	WINDOW,
	SKYLIGHT,
	LIGHTDOME,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWindowTypePartitioningEnum {
	SINGLE_PANEL,
	DOUBLE_PANEL_VERTICAL,
	DOUBLE_PANEL_HORIZONTAL,
	TRIPLE_PANEL_VERTICAL,
	TRIPLE_PANEL_BOTTOM,
	TRIPLE_PANEL_TOP,
	TRIPLE_PANEL_LEFT,
	TRIPLE_PANEL_RIGHT,
	TRIPLE_PANEL_HORIZONTAL,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWorkCalendarTypeEnum {
	FIRSTSHIFT,
	SECONDSHIFT,
	THIRDSHIFT,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWorkPlanTypeEnum {
	ACTUAL,
	BASELINE,
	PLANNED,
	USERDEFINED,
	NOTDEFINED
};
export enum IfcWorkScheduleTypeEnum {
	ACTUAL,
	BASELINE,
	PLANNED,
	USERDEFINED,
	NOTDEFINED
};
export type IfcActorSelect = 
|IfcOrganization
|IfcPerson
|IfcPersonAndOrganization
;
export type IfcAppliedValueSelect = 
|IfcMeasureWithUnit
|IfcReference
|IfcValue
;
export type IfcAxis2Placement = 
|IfcAxis2Placement2D
|IfcAxis2Placement3D
;
export type IfcBendingParameterSelect = 
|IfcLengthMeasure
|IfcPlaneAngleMeasure
;
export type IfcBooleanOperand = 
|IfcBooleanResult
|IfcCsgPrimitive3D
|IfcHalfSpaceSolid
|IfcSolidModel
|IfcTessellatedFaceSet
;
export type IfcClassificationReferenceSelect = 
|IfcClassification
|IfcClassificationReference
;
export type IfcClassificationSelect = 
|IfcClassification
|IfcClassificationReference
;
export type IfcColour = 
|IfcColourSpecification
|IfcPreDefinedColour
;
export type IfcColourOrFactor = 
|IfcColourRgb
|IfcNormalisedRatioMeasure
;
export type IfcCoordinateReferenceSystemSelect = 
|IfcCoordinateReferenceSystem
|IfcGeometricRepresentationContext
;
export type IfcCsgSelect = 
|IfcBooleanResult
|IfcCsgPrimitive3D
;
export type IfcCurveFontOrScaledCurveFontSelect = 
|IfcCurveStyleFontAndScaling
|IfcCurveStyleFontSelect
;
export type IfcCurveOnSurface = 
|IfcCompositeCurveOnSurface
|IfcPcurve
|IfcSurfaceCurve
;
export type IfcCurveOrEdgeCurve = 
|IfcBoundedCurve
|IfcEdgeCurve
;
export type IfcCurveStyleFontSelect = 
|IfcCurveStyleFont
|IfcPreDefinedCurveFont
;
export type IfcDefinitionSelect = 
|IfcObjectDefinition
|IfcPropertyDefinition
;
export type IfcDerivedMeasureValue = 
|IfcAbsorbedDoseMeasure
|IfcAccelerationMeasure
|IfcAngularVelocityMeasure
|IfcAreaDensityMeasure
|IfcCompoundPlaneAngleMeasure
|IfcCurvatureMeasure
|IfcDoseEquivalentMeasure
|IfcDynamicViscosityMeasure
|IfcElectricCapacitanceMeasure
|IfcElectricChargeMeasure
|IfcElectricConductanceMeasure
|IfcElectricResistanceMeasure
|IfcElectricVoltageMeasure
|IfcEnergyMeasure
|IfcForceMeasure
|IfcFrequencyMeasure
|IfcHeatFluxDensityMeasure
|IfcHeatingValueMeasure
|IfcIlluminanceMeasure
|IfcInductanceMeasure
|IfcIntegerCountRateMeasure
|IfcIonConcentrationMeasure
|IfcIsothermalMoistureCapacityMeasure
|IfcKinematicViscosityMeasure
|IfcLinearForceMeasure
|IfcLinearMomentMeasure
|IfcLinearStiffnessMeasure
|IfcLinearVelocityMeasure
|IfcLuminousFluxMeasure
|IfcLuminousIntensityDistributionMeasure
|IfcMagneticFluxDensityMeasure
|IfcMagneticFluxMeasure
|IfcMassDensityMeasure
|IfcMassFlowRateMeasure
|IfcMassPerLengthMeasure
|IfcModulusOfElasticityMeasure
|IfcModulusOfLinearSubgradeReactionMeasure
|IfcModulusOfRotationalSubgradeReactionMeasure
|IfcModulusOfSubgradeReactionMeasure
|IfcMoistureDiffusivityMeasure
|IfcMolecularWeightMeasure
|IfcMomentOfInertiaMeasure
|IfcMonetaryMeasure
|IfcPHMeasure
|IfcPlanarForceMeasure
|IfcPowerMeasure
|IfcPressureMeasure
|IfcRadioActivityMeasure
|IfcRotationalFrequencyMeasure
|IfcRotationalMassMeasure
|IfcRotationalStiffnessMeasure
|IfcSectionModulusMeasure
|IfcSectionalAreaIntegralMeasure
|IfcShearModulusMeasure
|IfcSoundPowerLevelMeasure
|IfcSoundPowerMeasure
|IfcSoundPressureLevelMeasure
|IfcSoundPressureMeasure
|IfcSpecificHeatCapacityMeasure
|IfcTemperatureGradientMeasure
|IfcTemperatureRateOfChangeMeasure
|IfcThermalAdmittanceMeasure
|IfcThermalConductivityMeasure
|IfcThermalExpansionCoefficientMeasure
|IfcThermalResistanceMeasure
|IfcThermalTransmittanceMeasure
|IfcTorqueMeasure
|IfcVaporPermeabilityMeasure
|IfcVolumetricFlowRateMeasure
|IfcWarpingConstantMeasure
|IfcWarpingMomentMeasure
;
export type IfcDocumentSelect = 
|IfcDocumentInformation
|IfcDocumentReference
;
export type IfcFillStyleSelect = 
|IfcColour
|IfcExternallyDefinedHatchStyle
|IfcFillAreaStyleHatching
|IfcFillAreaStyleTiles
;
export type IfcGeometricSetSelect = 
|IfcCurve
|IfcPoint
|IfcSurface
;
export type IfcGridPlacementDirectionSelect = 
|IfcDirection
|IfcVirtualGridIntersection
;
export type IfcHatchLineDistanceSelect = 
|IfcPositiveLengthMeasure
|IfcVector
;
export type IfcLayeredItem = 
|IfcRepresentation
|IfcRepresentationItem
;
export type IfcLibrarySelect = 
|IfcLibraryInformation
|IfcLibraryReference
;
export type IfcLightDistributionDataSourceSelect = 
|IfcExternalReference
|IfcLightIntensityDistribution
;
export type IfcMaterialSelect = 
|IfcMaterialDefinition
|IfcMaterialList
|IfcMaterialUsageDefinition
;
export type IfcMeasureValue = 
|IfcAmountOfSubstanceMeasure
|IfcAreaMeasure
|IfcComplexNumber
|IfcContextDependentMeasure
|IfcCountMeasure
|IfcDescriptiveMeasure
|IfcElectricCurrentMeasure
|IfcLengthMeasure
|IfcLuminousIntensityMeasure
|IfcMassMeasure
|IfcNonNegativeLengthMeasure
|IfcNormalisedRatioMeasure
|IfcNumericMeasure
|IfcParameterValue
|IfcPlaneAngleMeasure
|IfcPositiveLengthMeasure
|IfcPositivePlaneAngleMeasure
|IfcPositiveRatioMeasure
|IfcRatioMeasure
|IfcSolidAngleMeasure
|IfcThermodynamicTemperatureMeasure
|IfcTimeMeasure
|IfcVolumeMeasure
;
export type IfcMetricValueSelect = 
|IfcAppliedValue
|IfcMeasureWithUnit
|IfcReference
|IfcTable
|IfcTimeSeries
|IfcValue
;
export type IfcModulusOfRotationalSubgradeReactionSelect = 
|IfcBoolean
|IfcModulusOfRotationalSubgradeReactionMeasure
;
export type IfcModulusOfSubgradeReactionSelect = 
|IfcBoolean
|IfcModulusOfSubgradeReactionMeasure
;
export type IfcModulusOfTranslationalSubgradeReactionSelect = 
|IfcBoolean
|IfcModulusOfLinearSubgradeReactionMeasure
;
export type IfcObjectReferenceSelect = 
|IfcAddress
|IfcAppliedValue
|IfcExternalReference
|IfcMaterialDefinition
|IfcOrganization
|IfcPerson
|IfcPersonAndOrganization
|IfcTable
|IfcTimeSeries
;
export type IfcPointOrVertexPoint = 
|IfcPoint
|IfcVertexPoint
;
export type IfcPresentationStyleSelect = 
|IfcCurveStyle
|IfcFillAreaStyle
|IfcNullStyle
|IfcSurfaceStyle
|IfcTextStyle
;
export type IfcProcessSelect = 
|IfcProcess
|IfcTypeProcess
;
export type IfcProductRepresentationSelect = 
|IfcProductDefinitionShape
|IfcRepresentationMap
;
export type IfcProductSelect = 
|IfcProduct
|IfcTypeProduct
;
export type IfcPropertySetDefinitionSelect = 
|IfcPropertySetDefinition
|IfcPropertySetDefinitionSet
;
export type IfcResourceObjectSelect = 
|IfcActorRole
|IfcAppliedValue
|IfcApproval
|IfcConstraint
|IfcContextDependentUnit
|IfcConversionBasedUnit
|IfcExternalInformation
|IfcExternalReference
|IfcMaterialDefinition
|IfcOrganization
|IfcPerson
|IfcPersonAndOrganization
|IfcPhysicalQuantity
|IfcProfileDef
|IfcPropertyAbstraction
|IfcShapeAspect
|IfcTimeSeries
;
export type IfcResourceSelect = 
|IfcResource
|IfcTypeResource
;
export type IfcRotationalStiffnessSelect = 
|IfcBoolean
|IfcRotationalStiffnessMeasure
;
export type IfcSegmentIndexSelect = 
|IfcArcIndex
|IfcLineIndex
;
export type IfcShell = 
|IfcClosedShell
|IfcOpenShell
;
export type IfcSimpleValue = 
|IfcBinary
|IfcBoolean
|IfcDate
|IfcDateTime
|IfcDuration
|IfcIdentifier
|IfcInteger
|IfcLabel
|IfcLogical
|IfcPositiveInteger
|IfcReal
|IfcText
|IfcTime
|IfcTimeStamp
;
export type IfcSizeSelect = 
|IfcDescriptiveMeasure
|IfcLengthMeasure
|IfcNormalisedRatioMeasure
|IfcPositiveLengthMeasure
|IfcPositiveRatioMeasure
|IfcRatioMeasure
;
export type IfcSolidOrShell = 
|IfcClosedShell
|IfcSolidModel
;
export type IfcSpaceBoundarySelect = 
|IfcExternalSpatialElement
|IfcSpace
;
export type IfcSpecularHighlightSelect = 
|IfcSpecularExponent
|IfcSpecularRoughness
;
export type IfcStructuralActivityAssignmentSelect = 
|IfcElement
|IfcStructuralItem
;
export type IfcStyleAssignmentSelect = 
|IfcPresentationStyle
|IfcPresentationStyleAssignment
;
export type IfcSurfaceOrFaceSurface = 
|IfcFaceBasedSurfaceModel
|IfcFaceSurface
|IfcSurface
;
export type IfcSurfaceStyleElementSelect = 
|IfcExternallyDefinedSurfaceStyle
|IfcSurfaceStyleLighting
|IfcSurfaceStyleRefraction
|IfcSurfaceStyleShading
|IfcSurfaceStyleWithTextures
;
export type IfcTextFontSelect = 
|IfcExternallyDefinedTextFont
|IfcPreDefinedTextFont
;
export type IfcTimeOrRatioSelect = 
|IfcDuration
|IfcRatioMeasure
;
export type IfcTranslationalStiffnessSelect = 
|IfcBoolean
|IfcLinearStiffnessMeasure
;
export type IfcTrimmingSelect = 
|IfcCartesianPoint
|IfcParameterValue
;
export type IfcUnit = 
|IfcDerivedUnit
|IfcMonetaryUnit
|IfcNamedUnit
;
export type IfcValue = 
|IfcDerivedMeasureValue
|IfcMeasureValue
|IfcSimpleValue
;
export type IfcVectorOrDirection = 
|IfcDirection
|IfcVector
;
export type IfcWarpingStiffnessSelect = 
|IfcBoolean
|IfcWarpingMomentMeasure
;
export class IfcActionRequest {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, PredefinedType: IfcActionRequestTypeEnum | null, Status: IfcLabel | null, LongDescription: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.PredefinedType = PredefinedType;
		this.Status = Status;
		this.LongDescription = LongDescription;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	PredefinedType: IfcActionRequestTypeEnum | null;
	Status: IfcLabel | null;
	LongDescription: IfcText | null;
	static FromTape(tape: any[]): IfcActionRequest
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let PredefinedType = tape[6];
		let Status = tape[7];
		let LongDescription = tape[8];
		return new IfcActionRequest(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		args.push(STRING)
		args.push(this.Status)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcActor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, TheActor: IfcActorSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.TheActor = TheActor;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	TheActor: IfcActorSelect ;
	static FromTape(tape: any[]): IfcActor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let TheActor = tape[5];
		return new IfcActor(GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcActorRole {
	constructor(Role: IfcRoleEnum , UserDefinedRole: IfcLabel | null, Description: IfcText | null)
	{
		this.Role = Role;
		this.UserDefinedRole = UserDefinedRole;
		this.Description = Description;
	}
	Role: IfcRoleEnum ;
	UserDefinedRole: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcActorRole
	{
		let Role = tape[0];
		let UserDefinedRole = tape[1];
		let Description = tape[2];
		return new IfcActorRole(Role, UserDefinedRole, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.UserDefinedRole){
		args.push(STRING)
		args.push(this.UserDefinedRole)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcActuator {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcActuatorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcActuatorTypeEnum | null;
	static FromTape(tape: any[]): IfcActuator
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcActuator(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcActuatorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcActuatorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcActuatorTypeEnum ;
	static FromTape(tape: any[]): IfcActuatorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcActuatorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAddress {
	constructor(Purpose: IfcAddressTypeEnum | null, Description: IfcText | null, UserDefinedPurpose: IfcLabel | null)
	{
		this.Purpose = Purpose;
		this.Description = Description;
		this.UserDefinedPurpose = UserDefinedPurpose;
	}
	Purpose: IfcAddressTypeEnum | null;
	Description: IfcText | null;
	UserDefinedPurpose: IfcLabel | null;
	static FromTape(tape: any[]): IfcAddress
	{
		let Purpose = tape[0];
		let Description = tape[1];
		let UserDefinedPurpose = tape[2];
		return new IfcAddress(Purpose, Description, UserDefinedPurpose);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Purpose){
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedPurpose){
		args.push(STRING)
		args.push(this.UserDefinedPurpose)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAdvancedBrep {
	constructor(Outer: Handle<IfcClosedShell> )
	{
		this.Outer = Outer;
	}
	Outer: Handle<IfcClosedShell> ;
	static FromTape(tape: any[]): IfcAdvancedBrep
	{
		let Outer = tape[0];
		return new IfcAdvancedBrep(Outer);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Outer.expressID)
		return args;
	}
};
export class IfcAdvancedBrepWithVoids {
	constructor(Outer: Handle<IfcClosedShell> , Voids: Handle<IfcClosedShell>[] )
	{
		this.Outer = Outer;
		this.Voids = Voids;
	}
	Outer: Handle<IfcClosedShell> ;
	Voids: Handle<IfcClosedShell>[] ;
	static FromTape(tape: any[]): IfcAdvancedBrepWithVoids
	{
		let Outer = tape[0];
		let Voids = tape[1];
		return new IfcAdvancedBrepWithVoids(Outer, Voids);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Outer.expressID)
		args.push(SET_BEGIN)
		this.Voids.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcAdvancedFace {
	constructor(Bounds: Handle<IfcFaceBound>[] , FaceSurface: Handle<IfcSurface> , SameSense: IfcBoolean )
	{
		this.Bounds = Bounds;
		this.FaceSurface = FaceSurface;
		this.SameSense = SameSense;
	}
	Bounds: Handle<IfcFaceBound>[] ;
	FaceSurface: Handle<IfcSurface> ;
	SameSense: IfcBoolean ;
	static FromTape(tape: any[]): IfcAdvancedFace
	{
		let Bounds = tape[0];
		let FaceSurface = tape[1];
		let SameSense = tape[2];
		return new IfcAdvancedFace(Bounds, FaceSurface, SameSense);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Bounds.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.FaceSurface.expressID)
		return args;
	}
};
export class IfcAirTerminal {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcAirTerminalTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcAirTerminalTypeEnum | null;
	static FromTape(tape: any[]): IfcAirTerminal
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcAirTerminal(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAirTerminalBox {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcAirTerminalBoxTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcAirTerminalBoxTypeEnum | null;
	static FromTape(tape: any[]): IfcAirTerminalBox
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcAirTerminalBox(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAirTerminalBoxType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcAirTerminalBoxTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcAirTerminalBoxTypeEnum ;
	static FromTape(tape: any[]): IfcAirTerminalBoxType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcAirTerminalBoxType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAirTerminalType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcAirTerminalTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcAirTerminalTypeEnum ;
	static FromTape(tape: any[]): IfcAirTerminalType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcAirTerminalType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAirToAirHeatRecovery {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcAirToAirHeatRecoveryTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcAirToAirHeatRecoveryTypeEnum | null;
	static FromTape(tape: any[]): IfcAirToAirHeatRecovery
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcAirToAirHeatRecovery(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAirToAirHeatRecoveryType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcAirToAirHeatRecoveryTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcAirToAirHeatRecoveryTypeEnum ;
	static FromTape(tape: any[]): IfcAirToAirHeatRecoveryType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcAirToAirHeatRecoveryType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAlarm {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcAlarmTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcAlarmTypeEnum | null;
	static FromTape(tape: any[]): IfcAlarm
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcAlarm(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAlarmType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcAlarmTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcAlarmTypeEnum ;
	static FromTape(tape: any[]): IfcAlarmType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcAlarmType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAlignment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Axis: Handle<IfcCurve> , PredefinedType: IfcAlignmentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Axis = Axis;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Axis: Handle<IfcCurve> ;
	PredefinedType: IfcAlignmentTypeEnum | null;
	static FromTape(tape: any[]): IfcAlignment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Axis = tape[7];
		let PredefinedType = tape[8];
		return new IfcAlignment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAlignment2DHorizontal {
	constructor(StartDistAlong: IfcLengthMeasure | null, Segments: Handle<IfcAlignment2DHorizontalSegment>[] )
	{
		this.StartDistAlong = StartDistAlong;
		this.Segments = Segments;
	}
	StartDistAlong: IfcLengthMeasure | null;
	Segments: Handle<IfcAlignment2DHorizontalSegment>[] ;
	static FromTape(tape: any[]): IfcAlignment2DHorizontal
	{
		let StartDistAlong = tape[0];
		let Segments = tape[1];
		return new IfcAlignment2DHorizontal(StartDistAlong, Segments);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.StartDistAlong){
		args.push(REAL)
		args.push(this.StartDistAlong)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Segments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcAlignment2DHorizontalSegment {
	constructor(TangentialContinuity: IfcBoolean | null, StartTag: IfcLabel | null, EndTag: IfcLabel | null, CurveGeometry: Handle<IfcCurveSegment2D> )
	{
		this.TangentialContinuity = TangentialContinuity;
		this.StartTag = StartTag;
		this.EndTag = EndTag;
		this.CurveGeometry = CurveGeometry;
	}
	TangentialContinuity: IfcBoolean | null;
	StartTag: IfcLabel | null;
	EndTag: IfcLabel | null;
	CurveGeometry: Handle<IfcCurveSegment2D> ;
	static FromTape(tape: any[]): IfcAlignment2DHorizontalSegment
	{
		let TangentialContinuity = tape[0];
		let StartTag = tape[1];
		let EndTag = tape[2];
		let CurveGeometry = tape[3];
		return new IfcAlignment2DHorizontalSegment(TangentialContinuity, StartTag, EndTag, CurveGeometry);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TangentialContinuity){
		}
		else{ args.push(EMPTY); }
		if(this.StartTag){
		args.push(STRING)
		args.push(this.StartTag)
		}
		else{ args.push(EMPTY); }
		if(this.EndTag){
		args.push(STRING)
		args.push(this.EndTag)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.CurveGeometry.expressID)
		return args;
	}
};
export class IfcAlignment2DSegment {
	constructor(TangentialContinuity: IfcBoolean | null, StartTag: IfcLabel | null, EndTag: IfcLabel | null)
	{
		this.TangentialContinuity = TangentialContinuity;
		this.StartTag = StartTag;
		this.EndTag = EndTag;
	}
	TangentialContinuity: IfcBoolean | null;
	StartTag: IfcLabel | null;
	EndTag: IfcLabel | null;
	static FromTape(tape: any[]): IfcAlignment2DSegment
	{
		let TangentialContinuity = tape[0];
		let StartTag = tape[1];
		let EndTag = tape[2];
		return new IfcAlignment2DSegment(TangentialContinuity, StartTag, EndTag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TangentialContinuity){
		}
		else{ args.push(EMPTY); }
		if(this.StartTag){
		args.push(STRING)
		args.push(this.StartTag)
		}
		else{ args.push(EMPTY); }
		if(this.EndTag){
		args.push(STRING)
		args.push(this.EndTag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAlignment2DVerSegCircularArc {
	constructor(TangentialContinuity: IfcBoolean | null, StartTag: IfcLabel | null, EndTag: IfcLabel | null, StartDistAlong: IfcLengthMeasure , HorizontalLength: IfcPositiveLengthMeasure , StartHeight: IfcLengthMeasure , StartGradient: IfcRatioMeasure , Radius: IfcPositiveLengthMeasure , IsConvex: IfcBoolean )
	{
		this.TangentialContinuity = TangentialContinuity;
		this.StartTag = StartTag;
		this.EndTag = EndTag;
		this.StartDistAlong = StartDistAlong;
		this.HorizontalLength = HorizontalLength;
		this.StartHeight = StartHeight;
		this.StartGradient = StartGradient;
		this.Radius = Radius;
		this.IsConvex = IsConvex;
	}
	TangentialContinuity: IfcBoolean | null;
	StartTag: IfcLabel | null;
	EndTag: IfcLabel | null;
	StartDistAlong: IfcLengthMeasure ;
	HorizontalLength: IfcPositiveLengthMeasure ;
	StartHeight: IfcLengthMeasure ;
	StartGradient: IfcRatioMeasure ;
	Radius: IfcPositiveLengthMeasure ;
	IsConvex: IfcBoolean ;
	static FromTape(tape: any[]): IfcAlignment2DVerSegCircularArc
	{
		let TangentialContinuity = tape[0];
		let StartTag = tape[1];
		let EndTag = tape[2];
		let StartDistAlong = tape[3];
		let HorizontalLength = tape[4];
		let StartHeight = tape[5];
		let StartGradient = tape[6];
		let Radius = tape[7];
		let IsConvex = tape[8];
		return new IfcAlignment2DVerSegCircularArc(TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TangentialContinuity){
		}
		else{ args.push(EMPTY); }
		if(this.StartTag){
		args.push(STRING)
		args.push(this.StartTag)
		}
		else{ args.push(EMPTY); }
		if(this.EndTag){
		args.push(STRING)
		args.push(this.EndTag)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.StartDistAlong)
		args.push(REAL)
		args.push(this.StartHeight)
		args.push(REAL)
		args.push(this.StartGradient)
		return args;
	}
};
export class IfcAlignment2DVerSegLine {
	constructor(TangentialContinuity: IfcBoolean | null, StartTag: IfcLabel | null, EndTag: IfcLabel | null, StartDistAlong: IfcLengthMeasure , HorizontalLength: IfcPositiveLengthMeasure , StartHeight: IfcLengthMeasure , StartGradient: IfcRatioMeasure )
	{
		this.TangentialContinuity = TangentialContinuity;
		this.StartTag = StartTag;
		this.EndTag = EndTag;
		this.StartDistAlong = StartDistAlong;
		this.HorizontalLength = HorizontalLength;
		this.StartHeight = StartHeight;
		this.StartGradient = StartGradient;
	}
	TangentialContinuity: IfcBoolean | null;
	StartTag: IfcLabel | null;
	EndTag: IfcLabel | null;
	StartDistAlong: IfcLengthMeasure ;
	HorizontalLength: IfcPositiveLengthMeasure ;
	StartHeight: IfcLengthMeasure ;
	StartGradient: IfcRatioMeasure ;
	static FromTape(tape: any[]): IfcAlignment2DVerSegLine
	{
		let TangentialContinuity = tape[0];
		let StartTag = tape[1];
		let EndTag = tape[2];
		let StartDistAlong = tape[3];
		let HorizontalLength = tape[4];
		let StartHeight = tape[5];
		let StartGradient = tape[6];
		return new IfcAlignment2DVerSegLine(TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TangentialContinuity){
		}
		else{ args.push(EMPTY); }
		if(this.StartTag){
		args.push(STRING)
		args.push(this.StartTag)
		}
		else{ args.push(EMPTY); }
		if(this.EndTag){
		args.push(STRING)
		args.push(this.EndTag)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.StartDistAlong)
		args.push(REAL)
		args.push(this.StartHeight)
		args.push(REAL)
		args.push(this.StartGradient)
		return args;
	}
};
export class IfcAlignment2DVerSegParabolicArc {
	constructor(TangentialContinuity: IfcBoolean | null, StartTag: IfcLabel | null, EndTag: IfcLabel | null, StartDistAlong: IfcLengthMeasure , HorizontalLength: IfcPositiveLengthMeasure , StartHeight: IfcLengthMeasure , StartGradient: IfcRatioMeasure , ParabolaConstant: IfcPositiveLengthMeasure , IsConvex: IfcBoolean )
	{
		this.TangentialContinuity = TangentialContinuity;
		this.StartTag = StartTag;
		this.EndTag = EndTag;
		this.StartDistAlong = StartDistAlong;
		this.HorizontalLength = HorizontalLength;
		this.StartHeight = StartHeight;
		this.StartGradient = StartGradient;
		this.ParabolaConstant = ParabolaConstant;
		this.IsConvex = IsConvex;
	}
	TangentialContinuity: IfcBoolean | null;
	StartTag: IfcLabel | null;
	EndTag: IfcLabel | null;
	StartDistAlong: IfcLengthMeasure ;
	HorizontalLength: IfcPositiveLengthMeasure ;
	StartHeight: IfcLengthMeasure ;
	StartGradient: IfcRatioMeasure ;
	ParabolaConstant: IfcPositiveLengthMeasure ;
	IsConvex: IfcBoolean ;
	static FromTape(tape: any[]): IfcAlignment2DVerSegParabolicArc
	{
		let TangentialContinuity = tape[0];
		let StartTag = tape[1];
		let EndTag = tape[2];
		let StartDistAlong = tape[3];
		let HorizontalLength = tape[4];
		let StartHeight = tape[5];
		let StartGradient = tape[6];
		let ParabolaConstant = tape[7];
		let IsConvex = tape[8];
		return new IfcAlignment2DVerSegParabolicArc(TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TangentialContinuity){
		}
		else{ args.push(EMPTY); }
		if(this.StartTag){
		args.push(STRING)
		args.push(this.StartTag)
		}
		else{ args.push(EMPTY); }
		if(this.EndTag){
		args.push(STRING)
		args.push(this.EndTag)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.StartDistAlong)
		args.push(REAL)
		args.push(this.StartHeight)
		args.push(REAL)
		args.push(this.StartGradient)
		return args;
	}
};
export class IfcAlignment2DVertical {
	constructor(Segments: Handle<IfcAlignment2DVerticalSegment>[] )
	{
		this.Segments = Segments;
	}
	Segments: Handle<IfcAlignment2DVerticalSegment>[] ;
	static FromTape(tape: any[]): IfcAlignment2DVertical
	{
		let Segments = tape[0];
		return new IfcAlignment2DVertical(Segments);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Segments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcAlignment2DVerticalSegment {
	constructor(TangentialContinuity: IfcBoolean | null, StartTag: IfcLabel | null, EndTag: IfcLabel | null, StartDistAlong: IfcLengthMeasure , HorizontalLength: IfcPositiveLengthMeasure , StartHeight: IfcLengthMeasure , StartGradient: IfcRatioMeasure )
	{
		this.TangentialContinuity = TangentialContinuity;
		this.StartTag = StartTag;
		this.EndTag = EndTag;
		this.StartDistAlong = StartDistAlong;
		this.HorizontalLength = HorizontalLength;
		this.StartHeight = StartHeight;
		this.StartGradient = StartGradient;
	}
	TangentialContinuity: IfcBoolean | null;
	StartTag: IfcLabel | null;
	EndTag: IfcLabel | null;
	StartDistAlong: IfcLengthMeasure ;
	HorizontalLength: IfcPositiveLengthMeasure ;
	StartHeight: IfcLengthMeasure ;
	StartGradient: IfcRatioMeasure ;
	static FromTape(tape: any[]): IfcAlignment2DVerticalSegment
	{
		let TangentialContinuity = tape[0];
		let StartTag = tape[1];
		let EndTag = tape[2];
		let StartDistAlong = tape[3];
		let HorizontalLength = tape[4];
		let StartHeight = tape[5];
		let StartGradient = tape[6];
		return new IfcAlignment2DVerticalSegment(TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TangentialContinuity){
		}
		else{ args.push(EMPTY); }
		if(this.StartTag){
		args.push(STRING)
		args.push(this.StartTag)
		}
		else{ args.push(EMPTY); }
		if(this.EndTag){
		args.push(STRING)
		args.push(this.EndTag)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.StartDistAlong)
		args.push(REAL)
		args.push(this.StartHeight)
		args.push(REAL)
		args.push(this.StartGradient)
		return args;
	}
};
export class IfcAlignmentCurve {
	constructor(Horizontal: Handle<IfcAlignment2DHorizontal> , Vertical: Handle<IfcAlignment2DVertical> | null, Tag: IfcLabel | null)
	{
		this.Horizontal = Horizontal;
		this.Vertical = Vertical;
		this.Tag = Tag;
	}
	Horizontal: Handle<IfcAlignment2DHorizontal> ;
	Vertical: Handle<IfcAlignment2DVertical> | null;
	Tag: IfcLabel | null;
	static FromTape(tape: any[]): IfcAlignmentCurve
	{
		let Horizontal = tape[0];
		let Vertical = tape[1];
		let Tag = tape[2];
		return new IfcAlignmentCurve(Horizontal, Vertical, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Horizontal.expressID)
		if(this.Vertical){
		args.push(REF)
		args.push(this.Vertical.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAnnotation {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	static FromTape(tape: any[]): IfcAnnotation
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		return new IfcAnnotation(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAnnotationFillArea {
	constructor(OuterBoundary: Handle<IfcCurve> , InnerBoundaries: Handle<IfcCurve>[] | null)
	{
		this.OuterBoundary = OuterBoundary;
		this.InnerBoundaries = InnerBoundaries;
	}
	OuterBoundary: Handle<IfcCurve> ;
	InnerBoundaries: Handle<IfcCurve>[] | null;
	static FromTape(tape: any[]): IfcAnnotationFillArea
	{
		let OuterBoundary = tape[0];
		let InnerBoundaries = tape[1];
		return new IfcAnnotationFillArea(OuterBoundary, InnerBoundaries);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.OuterBoundary.expressID)
		if(this.InnerBoundaries){
		args.push(SET_BEGIN)
		this.InnerBoundaries.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcApplication {
	constructor(ApplicationDeveloper: Handle<IfcOrganization> , Version: IfcLabel , ApplicationFullName: IfcLabel , ApplicationIdentifier: IfcIdentifier )
	{
		this.ApplicationDeveloper = ApplicationDeveloper;
		this.Version = Version;
		this.ApplicationFullName = ApplicationFullName;
		this.ApplicationIdentifier = ApplicationIdentifier;
	}
	ApplicationDeveloper: Handle<IfcOrganization> ;
	Version: IfcLabel ;
	ApplicationFullName: IfcLabel ;
	ApplicationIdentifier: IfcIdentifier ;
	static FromTape(tape: any[]): IfcApplication
	{
		let ApplicationDeveloper = tape[0];
		let Version = tape[1];
		let ApplicationFullName = tape[2];
		let ApplicationIdentifier = tape[3];
		return new IfcApplication(ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ApplicationDeveloper.expressID)
		args.push(STRING)
		args.push(this.Version)
		args.push(STRING)
		args.push(this.ApplicationFullName)
		args.push(STRING)
		args.push(this.ApplicationIdentifier)
		return args;
	}
};
export class IfcAppliedValue {
	constructor(Name: IfcLabel | null, Description: IfcText | null, AppliedValue: IfcAppliedValueSelect | null, UnitBasis: Handle<IfcMeasureWithUnit> | null, ApplicableDate: IfcDate | null, FixedUntilDate: IfcDate | null, Category: IfcLabel | null, Condition: IfcLabel | null, ArithmeticOperator: IfcArithmeticOperatorEnum | null, Components: Handle<IfcAppliedValue>[] | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.AppliedValue = AppliedValue;
		this.UnitBasis = UnitBasis;
		this.ApplicableDate = ApplicableDate;
		this.FixedUntilDate = FixedUntilDate;
		this.Category = Category;
		this.Condition = Condition;
		this.ArithmeticOperator = ArithmeticOperator;
		this.Components = Components;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	AppliedValue: IfcAppliedValueSelect | null;
	UnitBasis: Handle<IfcMeasureWithUnit> | null;
	ApplicableDate: IfcDate | null;
	FixedUntilDate: IfcDate | null;
	Category: IfcLabel | null;
	Condition: IfcLabel | null;
	ArithmeticOperator: IfcArithmeticOperatorEnum | null;
	Components: Handle<IfcAppliedValue>[] | null;
	static FromTape(tape: any[]): IfcAppliedValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let AppliedValue = tape[2];
		let UnitBasis = tape[3];
		let ApplicableDate = tape[4];
		let FixedUntilDate = tape[5];
		let Category = tape[6];
		let Condition = tape[7];
		let ArithmeticOperator = tape[8];
		let Components = tape[9];
		return new IfcAppliedValue(Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.AppliedValue){
		}
		else{ args.push(EMPTY); }
		if(this.UnitBasis){
		args.push(REF)
		args.push(this.UnitBasis.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableDate){
		args.push(STRING)
		args.push(this.ApplicableDate)
		}
		else{ args.push(EMPTY); }
		if(this.FixedUntilDate){
		args.push(STRING)
		args.push(this.FixedUntilDate)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		if(this.Condition){
		args.push(STRING)
		args.push(this.Condition)
		}
		else{ args.push(EMPTY); }
		if(this.ArithmeticOperator){
		}
		else{ args.push(EMPTY); }
		if(this.Components){
		args.push(SET_BEGIN)
		this.Components.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcApproval {
	constructor(Identifier: IfcIdentifier | null, Name: IfcLabel | null, Description: IfcText | null, TimeOfApproval: IfcDateTime | null, Status: IfcLabel | null, Level: IfcLabel | null, Qualifier: IfcText | null, RequestingApproval: IfcActorSelect | null, GivingApproval: IfcActorSelect | null)
	{
		this.Identifier = Identifier;
		this.Name = Name;
		this.Description = Description;
		this.TimeOfApproval = TimeOfApproval;
		this.Status = Status;
		this.Level = Level;
		this.Qualifier = Qualifier;
		this.RequestingApproval = RequestingApproval;
		this.GivingApproval = GivingApproval;
	}
	Identifier: IfcIdentifier | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	TimeOfApproval: IfcDateTime | null;
	Status: IfcLabel | null;
	Level: IfcLabel | null;
	Qualifier: IfcText | null;
	RequestingApproval: IfcActorSelect | null;
	GivingApproval: IfcActorSelect | null;
	static FromTape(tape: any[]): IfcApproval
	{
		let Identifier = tape[0];
		let Name = tape[1];
		let Description = tape[2];
		let TimeOfApproval = tape[3];
		let Status = tape[4];
		let Level = tape[5];
		let Qualifier = tape[6];
		let RequestingApproval = tape[7];
		let GivingApproval = tape[8];
		return new IfcApproval(Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Identifier){
		args.push(STRING)
		args.push(this.Identifier)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.TimeOfApproval){
		args.push(STRING)
		args.push(this.TimeOfApproval)
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		args.push(STRING)
		args.push(this.Status)
		}
		else{ args.push(EMPTY); }
		if(this.Level){
		args.push(STRING)
		args.push(this.Level)
		}
		else{ args.push(EMPTY); }
		if(this.Qualifier){
		args.push(STRING)
		args.push(this.Qualifier)
		}
		else{ args.push(EMPTY); }
		if(this.RequestingApproval){
		}
		else{ args.push(EMPTY); }
		if(this.GivingApproval){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcApprovalRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingApproval: Handle<IfcApproval> , RelatedApprovals: Handle<IfcApproval>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingApproval = RelatingApproval;
		this.RelatedApprovals = RelatedApprovals;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingApproval: Handle<IfcApproval> ;
	RelatedApprovals: Handle<IfcApproval>[] ;
	static FromTape(tape: any[]): IfcApprovalRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingApproval = tape[2];
		let RelatedApprovals = tape[3];
		return new IfcApprovalRelationship(Name, Description, RelatingApproval, RelatedApprovals);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingApproval.expressID)
		args.push(SET_BEGIN)
		this.RelatedApprovals.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcArbitraryClosedProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, OuterCurve: Handle<IfcCurve> )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.OuterCurve = OuterCurve;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	OuterCurve: Handle<IfcCurve> ;
	static FromTape(tape: any[]): IfcArbitraryClosedProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let OuterCurve = tape[2];
		return new IfcArbitraryClosedProfileDef(ProfileType, ProfileName, OuterCurve);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.OuterCurve.expressID)
		return args;
	}
};
export class IfcArbitraryOpenProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Curve: Handle<IfcBoundedCurve> )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Curve = Curve;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Curve: Handle<IfcBoundedCurve> ;
	static FromTape(tape: any[]): IfcArbitraryOpenProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Curve = tape[2];
		return new IfcArbitraryOpenProfileDef(ProfileType, ProfileName, Curve);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Curve.expressID)
		return args;
	}
};
export class IfcArbitraryProfileDefWithVoids {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, OuterCurve: Handle<IfcCurve> , InnerCurves: Handle<IfcCurve>[] )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.OuterCurve = OuterCurve;
		this.InnerCurves = InnerCurves;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	OuterCurve: Handle<IfcCurve> ;
	InnerCurves: Handle<IfcCurve>[] ;
	static FromTape(tape: any[]): IfcArbitraryProfileDefWithVoids
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let OuterCurve = tape[2];
		let InnerCurves = tape[3];
		return new IfcArbitraryProfileDefWithVoids(ProfileType, ProfileName, OuterCurve, InnerCurves);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.OuterCurve.expressID)
		args.push(SET_BEGIN)
		this.InnerCurves.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcAsset {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, OriginalValue: Handle<IfcCostValue> | null, CurrentValue: Handle<IfcCostValue> | null, TotalReplacementCost: Handle<IfcCostValue> | null, Owner: IfcActorSelect | null, User: IfcActorSelect | null, ResponsiblePerson: Handle<IfcPerson> | null, IncorporationDate: IfcDate | null, DepreciatedValue: Handle<IfcCostValue> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.OriginalValue = OriginalValue;
		this.CurrentValue = CurrentValue;
		this.TotalReplacementCost = TotalReplacementCost;
		this.Owner = Owner;
		this.User = User;
		this.ResponsiblePerson = ResponsiblePerson;
		this.IncorporationDate = IncorporationDate;
		this.DepreciatedValue = DepreciatedValue;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	OriginalValue: Handle<IfcCostValue> | null;
	CurrentValue: Handle<IfcCostValue> | null;
	TotalReplacementCost: Handle<IfcCostValue> | null;
	Owner: IfcActorSelect | null;
	User: IfcActorSelect | null;
	ResponsiblePerson: Handle<IfcPerson> | null;
	IncorporationDate: IfcDate | null;
	DepreciatedValue: Handle<IfcCostValue> | null;
	static FromTape(tape: any[]): IfcAsset
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let OriginalValue = tape[6];
		let CurrentValue = tape[7];
		let TotalReplacementCost = tape[8];
		let Owner = tape[9];
		let User = tape[10];
		let ResponsiblePerson = tape[11];
		let IncorporationDate = tape[12];
		let DepreciatedValue = tape[13];
		return new IfcAsset(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.OriginalValue){
		args.push(REF)
		args.push(this.OriginalValue.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.CurrentValue){
		args.push(REF)
		args.push(this.CurrentValue.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.TotalReplacementCost){
		args.push(REF)
		args.push(this.TotalReplacementCost.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Owner){
		}
		else{ args.push(EMPTY); }
		if(this.User){
		}
		else{ args.push(EMPTY); }
		if(this.ResponsiblePerson){
		args.push(REF)
		args.push(this.ResponsiblePerson.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.IncorporationDate){
		args.push(STRING)
		args.push(this.IncorporationDate)
		}
		else{ args.push(EMPTY); }
		if(this.DepreciatedValue){
		args.push(REF)
		args.push(this.DepreciatedValue.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAsymmetricIShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, BottomFlangeWidth: IfcPositiveLengthMeasure , OverallDepth: IfcPositiveLengthMeasure , WebThickness: IfcPositiveLengthMeasure , BottomFlangeThickness: IfcPositiveLengthMeasure , BottomFlangeFilletRadius: IfcNonNegativeLengthMeasure | null, TopFlangeWidth: IfcPositiveLengthMeasure , TopFlangeThickness: IfcPositiveLengthMeasure | null, TopFlangeFilletRadius: IfcNonNegativeLengthMeasure | null, BottomFlangeEdgeRadius: IfcNonNegativeLengthMeasure | null, BottomFlangeSlope: IfcPlaneAngleMeasure | null, TopFlangeEdgeRadius: IfcNonNegativeLengthMeasure | null, TopFlangeSlope: IfcPlaneAngleMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.BottomFlangeWidth = BottomFlangeWidth;
		this.OverallDepth = OverallDepth;
		this.WebThickness = WebThickness;
		this.BottomFlangeThickness = BottomFlangeThickness;
		this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
		this.TopFlangeWidth = TopFlangeWidth;
		this.TopFlangeThickness = TopFlangeThickness;
		this.TopFlangeFilletRadius = TopFlangeFilletRadius;
		this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
		this.BottomFlangeSlope = BottomFlangeSlope;
		this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
		this.TopFlangeSlope = TopFlangeSlope;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	BottomFlangeWidth: IfcPositiveLengthMeasure ;
	OverallDepth: IfcPositiveLengthMeasure ;
	WebThickness: IfcPositiveLengthMeasure ;
	BottomFlangeThickness: IfcPositiveLengthMeasure ;
	BottomFlangeFilletRadius: IfcNonNegativeLengthMeasure | null;
	TopFlangeWidth: IfcPositiveLengthMeasure ;
	TopFlangeThickness: IfcPositiveLengthMeasure | null;
	TopFlangeFilletRadius: IfcNonNegativeLengthMeasure | null;
	BottomFlangeEdgeRadius: IfcNonNegativeLengthMeasure | null;
	BottomFlangeSlope: IfcPlaneAngleMeasure | null;
	TopFlangeEdgeRadius: IfcNonNegativeLengthMeasure | null;
	TopFlangeSlope: IfcPlaneAngleMeasure | null;
	static FromTape(tape: any[]): IfcAsymmetricIShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let BottomFlangeWidth = tape[3];
		let OverallDepth = tape[4];
		let WebThickness = tape[5];
		let BottomFlangeThickness = tape[6];
		let BottomFlangeFilletRadius = tape[7];
		let TopFlangeWidth = tape[8];
		let TopFlangeThickness = tape[9];
		let TopFlangeFilletRadius = tape[10];
		let BottomFlangeEdgeRadius = tape[11];
		let BottomFlangeSlope = tape[12];
		let TopFlangeEdgeRadius = tape[13];
		let TopFlangeSlope = tape[14];
		return new IfcAsymmetricIShapeProfileDef(ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BottomFlangeFilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.TopFlangeThickness){
		}
		else{ args.push(EMPTY); }
		if(this.TopFlangeFilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.BottomFlangeEdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.BottomFlangeSlope){
		args.push(REAL)
		args.push(this.BottomFlangeSlope)
		}
		else{ args.push(EMPTY); }
		if(this.TopFlangeEdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.TopFlangeSlope){
		args.push(REAL)
		args.push(this.TopFlangeSlope)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAudioVisualAppliance {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcAudioVisualApplianceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcAudioVisualApplianceTypeEnum | null;
	static FromTape(tape: any[]): IfcAudioVisualAppliance
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcAudioVisualAppliance(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAudioVisualApplianceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcAudioVisualApplianceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcAudioVisualApplianceTypeEnum ;
	static FromTape(tape: any[]): IfcAudioVisualApplianceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcAudioVisualApplianceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAxis1Placement {
	constructor(Location: Handle<IfcCartesianPoint> , Axis: Handle<IfcDirection> | null)
	{
		this.Location = Location;
		this.Axis = Axis;
	}
	Location: Handle<IfcCartesianPoint> ;
	Axis: Handle<IfcDirection> | null;
	static FromTape(tape: any[]): IfcAxis1Placement
	{
		let Location = tape[0];
		let Axis = tape[1];
		return new IfcAxis1Placement(Location, Axis);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Location.expressID)
		if(this.Axis){
		args.push(REF)
		args.push(this.Axis.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAxis2Placement2D {
	constructor(Location: Handle<IfcCartesianPoint> , RefDirection: Handle<IfcDirection> | null)
	{
		this.Location = Location;
		this.RefDirection = RefDirection;
	}
	Location: Handle<IfcCartesianPoint> ;
	RefDirection: Handle<IfcDirection> | null;
	static FromTape(tape: any[]): IfcAxis2Placement2D
	{
		let Location = tape[0];
		let RefDirection = tape[1];
		return new IfcAxis2Placement2D(Location, RefDirection);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Location.expressID)
		if(this.RefDirection){
		args.push(REF)
		args.push(this.RefDirection.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcAxis2Placement3D {
	constructor(Location: Handle<IfcCartesianPoint> , Axis: Handle<IfcDirection> | null, RefDirection: Handle<IfcDirection> | null)
	{
		this.Location = Location;
		this.Axis = Axis;
		this.RefDirection = RefDirection;
	}
	Location: Handle<IfcCartesianPoint> ;
	Axis: Handle<IfcDirection> | null;
	RefDirection: Handle<IfcDirection> | null;
	static FromTape(tape: any[]): IfcAxis2Placement3D
	{
		let Location = tape[0];
		let Axis = tape[1];
		let RefDirection = tape[2];
		return new IfcAxis2Placement3D(Location, Axis, RefDirection);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Location.expressID)
		if(this.Axis){
		args.push(REF)
		args.push(this.Axis.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.RefDirection){
		args.push(REF)
		args.push(this.RefDirection.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBSplineCurve {
	constructor(Degree: IfcInteger , ControlPointsList: Handle<IfcCartesianPoint>[] , CurveForm: IfcBSplineCurveForm , ClosedCurve: IfcLogical , SelfIntersect: IfcLogical )
	{
		this.Degree = Degree;
		this.ControlPointsList = ControlPointsList;
		this.CurveForm = CurveForm;
		this.ClosedCurve = ClosedCurve;
		this.SelfIntersect = SelfIntersect;
	}
	Degree: IfcInteger ;
	ControlPointsList: Handle<IfcCartesianPoint>[] ;
	CurveForm: IfcBSplineCurveForm ;
	ClosedCurve: IfcLogical ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcBSplineCurve
	{
		let Degree = tape[0];
		let ControlPointsList = tape[1];
		let CurveForm = tape[2];
		let ClosedCurve = tape[3];
		let SelfIntersect = tape[4];
		return new IfcBSplineCurve(Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.Degree)
		args.push(SET_BEGIN)
		this.ControlPointsList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcBSplineCurveWithKnots {
	constructor(Degree: IfcInteger , ControlPointsList: Handle<IfcCartesianPoint>[] , CurveForm: IfcBSplineCurveForm , ClosedCurve: IfcLogical , SelfIntersect: IfcLogical , KnotMultiplicities: IfcInteger[] , Knots: IfcParameterValue[] , KnotSpec: IfcKnotType )
	{
		this.Degree = Degree;
		this.ControlPointsList = ControlPointsList;
		this.CurveForm = CurveForm;
		this.ClosedCurve = ClosedCurve;
		this.SelfIntersect = SelfIntersect;
		this.KnotMultiplicities = KnotMultiplicities;
		this.Knots = Knots;
		this.KnotSpec = KnotSpec;
	}
	Degree: IfcInteger ;
	ControlPointsList: Handle<IfcCartesianPoint>[] ;
	CurveForm: IfcBSplineCurveForm ;
	ClosedCurve: IfcLogical ;
	SelfIntersect: IfcLogical ;
	KnotMultiplicities: IfcInteger[] ;
	Knots: IfcParameterValue[] ;
	KnotSpec: IfcKnotType ;
	static FromTape(tape: any[]): IfcBSplineCurveWithKnots
	{
		let Degree = tape[0];
		let ControlPointsList = tape[1];
		let CurveForm = tape[2];
		let ClosedCurve = tape[3];
		let SelfIntersect = tape[4];
		let KnotMultiplicities = tape[5];
		let Knots = tape[6];
		let KnotSpec = tape[7];
		return new IfcBSplineCurveWithKnots(Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.Degree)
		args.push(SET_BEGIN)
		this.ControlPointsList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REAL)
		args.push(...this.KnotMultiplicities)
		args.push(REAL)
		args.push(...this.Knots)
		return args;
	}
};
export class IfcBSplineSurface {
	constructor(UDegree: IfcInteger , VDegree: IfcInteger , ControlPointsList: Handle<IfcCartesianPoint>[] , SurfaceForm: IfcBSplineSurfaceForm , UClosed: IfcLogical , VClosed: IfcLogical , SelfIntersect: IfcLogical )
	{
		this.UDegree = UDegree;
		this.VDegree = VDegree;
		this.ControlPointsList = ControlPointsList;
		this.SurfaceForm = SurfaceForm;
		this.UClosed = UClosed;
		this.VClosed = VClosed;
		this.SelfIntersect = SelfIntersect;
	}
	UDegree: IfcInteger ;
	VDegree: IfcInteger ;
	ControlPointsList: Handle<IfcCartesianPoint>[] ;
	SurfaceForm: IfcBSplineSurfaceForm ;
	UClosed: IfcLogical ;
	VClosed: IfcLogical ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcBSplineSurface
	{
		let UDegree = tape[0];
		let VDegree = tape[1];
		let ControlPointsList = tape[2];
		let SurfaceForm = tape[3];
		let UClosed = tape[4];
		let VClosed = tape[5];
		let SelfIntersect = tape[6];
		return new IfcBSplineSurface(UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.UDegree)
		args.push(REAL)
		args.push(this.VDegree)
		args.push(SET_BEGIN)
		this.ControlPointsList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcBSplineSurfaceWithKnots {
	constructor(UDegree: IfcInteger , VDegree: IfcInteger , ControlPointsList: Handle<IfcCartesianPoint>[] , SurfaceForm: IfcBSplineSurfaceForm , UClosed: IfcLogical , VClosed: IfcLogical , SelfIntersect: IfcLogical , UMultiplicities: IfcInteger[] , VMultiplicities: IfcInteger[] , UKnots: IfcParameterValue[] , VKnots: IfcParameterValue[] , KnotSpec: IfcKnotType )
	{
		this.UDegree = UDegree;
		this.VDegree = VDegree;
		this.ControlPointsList = ControlPointsList;
		this.SurfaceForm = SurfaceForm;
		this.UClosed = UClosed;
		this.VClosed = VClosed;
		this.SelfIntersect = SelfIntersect;
		this.UMultiplicities = UMultiplicities;
		this.VMultiplicities = VMultiplicities;
		this.UKnots = UKnots;
		this.VKnots = VKnots;
		this.KnotSpec = KnotSpec;
	}
	UDegree: IfcInteger ;
	VDegree: IfcInteger ;
	ControlPointsList: Handle<IfcCartesianPoint>[] ;
	SurfaceForm: IfcBSplineSurfaceForm ;
	UClosed: IfcLogical ;
	VClosed: IfcLogical ;
	SelfIntersect: IfcLogical ;
	UMultiplicities: IfcInteger[] ;
	VMultiplicities: IfcInteger[] ;
	UKnots: IfcParameterValue[] ;
	VKnots: IfcParameterValue[] ;
	KnotSpec: IfcKnotType ;
	static FromTape(tape: any[]): IfcBSplineSurfaceWithKnots
	{
		let UDegree = tape[0];
		let VDegree = tape[1];
		let ControlPointsList = tape[2];
		let SurfaceForm = tape[3];
		let UClosed = tape[4];
		let VClosed = tape[5];
		let SelfIntersect = tape[6];
		let UMultiplicities = tape[7];
		let VMultiplicities = tape[8];
		let UKnots = tape[9];
		let VKnots = tape[10];
		let KnotSpec = tape[11];
		return new IfcBSplineSurfaceWithKnots(UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.UDegree)
		args.push(REAL)
		args.push(this.VDegree)
		args.push(SET_BEGIN)
		this.ControlPointsList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REAL)
		args.push(...this.UMultiplicities)
		args.push(REAL)
		args.push(...this.VMultiplicities)
		args.push(REAL)
		args.push(...this.UKnots)
		args.push(REAL)
		args.push(...this.VKnots)
		return args;
	}
};
export class IfcBeam {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBeamTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBeamTypeEnum | null;
	static FromTape(tape: any[]): IfcBeam
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBeam(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBeamStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBeamTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBeamTypeEnum | null;
	static FromTape(tape: any[]): IfcBeamStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBeamStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBeamType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcBeamTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcBeamTypeEnum ;
	static FromTape(tape: any[]): IfcBeamType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBeamType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBearing {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBearingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBearingTypeEnum | null;
	static FromTape(tape: any[]): IfcBearing
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBearing(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBearingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcBearingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcBearingTypeEnum ;
	static FromTape(tape: any[]): IfcBearingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBearingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBlobTexture {
	constructor(RepeatS: IfcBoolean , RepeatT: IfcBoolean , Mode: IfcIdentifier | null, TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null, Parameter: IfcIdentifier[] | null, RasterFormat: IfcIdentifier , RasterCode: IfcBinary )
	{
		this.RepeatS = RepeatS;
		this.RepeatT = RepeatT;
		this.Mode = Mode;
		this.TextureTransform = TextureTransform;
		this.Parameter = Parameter;
		this.RasterFormat = RasterFormat;
		this.RasterCode = RasterCode;
	}
	RepeatS: IfcBoolean ;
	RepeatT: IfcBoolean ;
	Mode: IfcIdentifier | null;
	TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null;
	Parameter: IfcIdentifier[] | null;
	RasterFormat: IfcIdentifier ;
	RasterCode: IfcBinary ;
	static FromTape(tape: any[]): IfcBlobTexture
	{
		let RepeatS = tape[0];
		let RepeatT = tape[1];
		let Mode = tape[2];
		let TextureTransform = tape[3];
		let Parameter = tape[4];
		let RasterFormat = tape[5];
		let RasterCode = tape[6];
		return new IfcBlobTexture(RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Mode){
		args.push(STRING)
		args.push(this.Mode)
		}
		else{ args.push(EMPTY); }
		if(this.TextureTransform){
		args.push(REF)
		args.push(this.TextureTransform.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Parameter){
		args.push(STRING)
		args.push(...this.Parameter)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.RasterFormat)
		args.push(REAL)
		args.push(this.RasterCode)
		return args;
	}
};
export class IfcBlock {
	constructor(Position: Handle<IfcAxis2Placement3D> , XLength: IfcPositiveLengthMeasure , YLength: IfcPositiveLengthMeasure , ZLength: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.XLength = XLength;
		this.YLength = YLength;
		this.ZLength = ZLength;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	XLength: IfcPositiveLengthMeasure ;
	YLength: IfcPositiveLengthMeasure ;
	ZLength: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcBlock
	{
		let Position = tape[0];
		let XLength = tape[1];
		let YLength = tape[2];
		let ZLength = tape[3];
		return new IfcBlock(Position, XLength, YLength, ZLength);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcBoiler {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBoilerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBoilerTypeEnum | null;
	static FromTape(tape: any[]): IfcBoiler
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBoiler(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBoilerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcBoilerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcBoilerTypeEnum ;
	static FromTape(tape: any[]): IfcBoilerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBoilerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBooleanClippingResult {
	constructor(Operator: IfcBooleanOperator , FirstOperand: IfcBooleanOperand , SecondOperand: IfcBooleanOperand )
	{
		this.Operator = Operator;
		this.FirstOperand = FirstOperand;
		this.SecondOperand = SecondOperand;
	}
	Operator: IfcBooleanOperator ;
	FirstOperand: IfcBooleanOperand ;
	SecondOperand: IfcBooleanOperand ;
	static FromTape(tape: any[]): IfcBooleanClippingResult
	{
		let Operator = tape[0];
		let FirstOperand = tape[1];
		let SecondOperand = tape[2];
		return new IfcBooleanClippingResult(Operator, FirstOperand, SecondOperand);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcBooleanResult {
	constructor(Operator: IfcBooleanOperator , FirstOperand: IfcBooleanOperand , SecondOperand: IfcBooleanOperand )
	{
		this.Operator = Operator;
		this.FirstOperand = FirstOperand;
		this.SecondOperand = SecondOperand;
	}
	Operator: IfcBooleanOperator ;
	FirstOperand: IfcBooleanOperand ;
	SecondOperand: IfcBooleanOperand ;
	static FromTape(tape: any[]): IfcBooleanResult
	{
		let Operator = tape[0];
		let FirstOperand = tape[1];
		let SecondOperand = tape[2];
		return new IfcBooleanResult(Operator, FirstOperand, SecondOperand);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcBoundaryCondition {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcBoundaryCondition
	{
		let Name = tape[0];
		return new IfcBoundaryCondition(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBoundaryCurve {
	constructor(Segments: Handle<IfcCompositeCurveSegment>[] , SelfIntersect: IfcLogical )
	{
		this.Segments = Segments;
		this.SelfIntersect = SelfIntersect;
	}
	Segments: Handle<IfcCompositeCurveSegment>[] ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcBoundaryCurve
	{
		let Segments = tape[0];
		let SelfIntersect = tape[1];
		return new IfcBoundaryCurve(Segments, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Segments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcBoundaryEdgeCondition {
	constructor(Name: IfcLabel | null, TranslationalStiffnessByLengthX: IfcModulusOfTranslationalSubgradeReactionSelect | null, TranslationalStiffnessByLengthY: IfcModulusOfTranslationalSubgradeReactionSelect | null, TranslationalStiffnessByLengthZ: IfcModulusOfTranslationalSubgradeReactionSelect | null, RotationalStiffnessByLengthX: IfcModulusOfRotationalSubgradeReactionSelect | null, RotationalStiffnessByLengthY: IfcModulusOfRotationalSubgradeReactionSelect | null, RotationalStiffnessByLengthZ: IfcModulusOfRotationalSubgradeReactionSelect | null)
	{
		this.Name = Name;
		this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
		this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
		this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
		this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
		this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
		this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
	}
	Name: IfcLabel | null;
	TranslationalStiffnessByLengthX: IfcModulusOfTranslationalSubgradeReactionSelect | null;
	TranslationalStiffnessByLengthY: IfcModulusOfTranslationalSubgradeReactionSelect | null;
	TranslationalStiffnessByLengthZ: IfcModulusOfTranslationalSubgradeReactionSelect | null;
	RotationalStiffnessByLengthX: IfcModulusOfRotationalSubgradeReactionSelect | null;
	RotationalStiffnessByLengthY: IfcModulusOfRotationalSubgradeReactionSelect | null;
	RotationalStiffnessByLengthZ: IfcModulusOfRotationalSubgradeReactionSelect | null;
	static FromTape(tape: any[]): IfcBoundaryEdgeCondition
	{
		let Name = tape[0];
		let TranslationalStiffnessByLengthX = tape[1];
		let TranslationalStiffnessByLengthY = tape[2];
		let TranslationalStiffnessByLengthZ = tape[3];
		let RotationalStiffnessByLengthX = tape[4];
		let RotationalStiffnessByLengthY = tape[5];
		let RotationalStiffnessByLengthZ = tape[6];
		return new IfcBoundaryEdgeCondition(Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessByLengthX){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessByLengthY){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessByLengthZ){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessByLengthX){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessByLengthY){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessByLengthZ){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBoundaryFaceCondition {
	constructor(Name: IfcLabel | null, TranslationalStiffnessByAreaX: IfcModulusOfSubgradeReactionSelect | null, TranslationalStiffnessByAreaY: IfcModulusOfSubgradeReactionSelect | null, TranslationalStiffnessByAreaZ: IfcModulusOfSubgradeReactionSelect | null)
	{
		this.Name = Name;
		this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
		this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
		this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
	}
	Name: IfcLabel | null;
	TranslationalStiffnessByAreaX: IfcModulusOfSubgradeReactionSelect | null;
	TranslationalStiffnessByAreaY: IfcModulusOfSubgradeReactionSelect | null;
	TranslationalStiffnessByAreaZ: IfcModulusOfSubgradeReactionSelect | null;
	static FromTape(tape: any[]): IfcBoundaryFaceCondition
	{
		let Name = tape[0];
		let TranslationalStiffnessByAreaX = tape[1];
		let TranslationalStiffnessByAreaY = tape[2];
		let TranslationalStiffnessByAreaZ = tape[3];
		return new IfcBoundaryFaceCondition(Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessByAreaX){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessByAreaY){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessByAreaZ){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBoundaryNodeCondition {
	constructor(Name: IfcLabel | null, TranslationalStiffnessX: IfcTranslationalStiffnessSelect | null, TranslationalStiffnessY: IfcTranslationalStiffnessSelect | null, TranslationalStiffnessZ: IfcTranslationalStiffnessSelect | null, RotationalStiffnessX: IfcRotationalStiffnessSelect | null, RotationalStiffnessY: IfcRotationalStiffnessSelect | null, RotationalStiffnessZ: IfcRotationalStiffnessSelect | null)
	{
		this.Name = Name;
		this.TranslationalStiffnessX = TranslationalStiffnessX;
		this.TranslationalStiffnessY = TranslationalStiffnessY;
		this.TranslationalStiffnessZ = TranslationalStiffnessZ;
		this.RotationalStiffnessX = RotationalStiffnessX;
		this.RotationalStiffnessY = RotationalStiffnessY;
		this.RotationalStiffnessZ = RotationalStiffnessZ;
	}
	Name: IfcLabel | null;
	TranslationalStiffnessX: IfcTranslationalStiffnessSelect | null;
	TranslationalStiffnessY: IfcTranslationalStiffnessSelect | null;
	TranslationalStiffnessZ: IfcTranslationalStiffnessSelect | null;
	RotationalStiffnessX: IfcRotationalStiffnessSelect | null;
	RotationalStiffnessY: IfcRotationalStiffnessSelect | null;
	RotationalStiffnessZ: IfcRotationalStiffnessSelect | null;
	static FromTape(tape: any[]): IfcBoundaryNodeCondition
	{
		let Name = tape[0];
		let TranslationalStiffnessX = tape[1];
		let TranslationalStiffnessY = tape[2];
		let TranslationalStiffnessZ = tape[3];
		let RotationalStiffnessX = tape[4];
		let RotationalStiffnessY = tape[5];
		let RotationalStiffnessZ = tape[6];
		return new IfcBoundaryNodeCondition(Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessX){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessY){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessZ){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessX){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessY){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessZ){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBoundaryNodeConditionWarping {
	constructor(Name: IfcLabel | null, TranslationalStiffnessX: IfcTranslationalStiffnessSelect | null, TranslationalStiffnessY: IfcTranslationalStiffnessSelect | null, TranslationalStiffnessZ: IfcTranslationalStiffnessSelect | null, RotationalStiffnessX: IfcRotationalStiffnessSelect | null, RotationalStiffnessY: IfcRotationalStiffnessSelect | null, RotationalStiffnessZ: IfcRotationalStiffnessSelect | null, WarpingStiffness: IfcWarpingStiffnessSelect | null)
	{
		this.Name = Name;
		this.TranslationalStiffnessX = TranslationalStiffnessX;
		this.TranslationalStiffnessY = TranslationalStiffnessY;
		this.TranslationalStiffnessZ = TranslationalStiffnessZ;
		this.RotationalStiffnessX = RotationalStiffnessX;
		this.RotationalStiffnessY = RotationalStiffnessY;
		this.RotationalStiffnessZ = RotationalStiffnessZ;
		this.WarpingStiffness = WarpingStiffness;
	}
	Name: IfcLabel | null;
	TranslationalStiffnessX: IfcTranslationalStiffnessSelect | null;
	TranslationalStiffnessY: IfcTranslationalStiffnessSelect | null;
	TranslationalStiffnessZ: IfcTranslationalStiffnessSelect | null;
	RotationalStiffnessX: IfcRotationalStiffnessSelect | null;
	RotationalStiffnessY: IfcRotationalStiffnessSelect | null;
	RotationalStiffnessZ: IfcRotationalStiffnessSelect | null;
	WarpingStiffness: IfcWarpingStiffnessSelect | null;
	static FromTape(tape: any[]): IfcBoundaryNodeConditionWarping
	{
		let Name = tape[0];
		let TranslationalStiffnessX = tape[1];
		let TranslationalStiffnessY = tape[2];
		let TranslationalStiffnessZ = tape[3];
		let RotationalStiffnessX = tape[4];
		let RotationalStiffnessY = tape[5];
		let RotationalStiffnessZ = tape[6];
		let WarpingStiffness = tape[7];
		return new IfcBoundaryNodeConditionWarping(Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessX){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessY){
		}
		else{ args.push(EMPTY); }
		if(this.TranslationalStiffnessZ){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessX){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessY){
		}
		else{ args.push(EMPTY); }
		if(this.RotationalStiffnessZ){
		}
		else{ args.push(EMPTY); }
		if(this.WarpingStiffness){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBoundedCurve {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcBoundedCurve
	{
		return new IfcBoundedCurve();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcBoundedSurface {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcBoundedSurface
	{
		return new IfcBoundedSurface();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcBoundingBox {
	constructor(Corner: Handle<IfcCartesianPoint> , XDim: IfcPositiveLengthMeasure , YDim: IfcPositiveLengthMeasure , ZDim: IfcPositiveLengthMeasure )
	{
		this.Corner = Corner;
		this.XDim = XDim;
		this.YDim = YDim;
		this.ZDim = ZDim;
	}
	Corner: Handle<IfcCartesianPoint> ;
	XDim: IfcPositiveLengthMeasure ;
	YDim: IfcPositiveLengthMeasure ;
	ZDim: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcBoundingBox
	{
		let Corner = tape[0];
		let XDim = tape[1];
		let YDim = tape[2];
		let ZDim = tape[3];
		return new IfcBoundingBox(Corner, XDim, YDim, ZDim);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Corner.expressID)
		return args;
	}
};
export class IfcBoxedHalfSpace {
	constructor(BaseSurface: Handle<IfcSurface> , AgreementFlag: IfcBoolean , Enclosure: Handle<IfcBoundingBox> )
	{
		this.BaseSurface = BaseSurface;
		this.AgreementFlag = AgreementFlag;
		this.Enclosure = Enclosure;
	}
	BaseSurface: Handle<IfcSurface> ;
	AgreementFlag: IfcBoolean ;
	Enclosure: Handle<IfcBoundingBox> ;
	static FromTape(tape: any[]): IfcBoxedHalfSpace
	{
		let BaseSurface = tape[0];
		let AgreementFlag = tape[1];
		let Enclosure = tape[2];
		return new IfcBoxedHalfSpace(BaseSurface, AgreementFlag, Enclosure);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BaseSurface.expressID)
		args.push(REF)
		args.push(this.Enclosure.expressID)
		return args;
	}
};
export class IfcBridge {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null, PredefinedType: IfcBridgeTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	PredefinedType: IfcBridgeTypeEnum | null;
	static FromTape(tape: any[]): IfcBridge
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBridge(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBridgePart {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null, PredefinedType: IfcBridgePartTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	PredefinedType: IfcBridgePartTypeEnum | null;
	static FromTape(tape: any[]): IfcBridgePart
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBridgePart(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuilding {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null, ElevationOfRefHeight: IfcLengthMeasure | null, ElevationOfTerrain: IfcLengthMeasure | null, BuildingAddress: Handle<IfcPostalAddress> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
		this.ElevationOfRefHeight = ElevationOfRefHeight;
		this.ElevationOfTerrain = ElevationOfTerrain;
		this.BuildingAddress = BuildingAddress;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	ElevationOfRefHeight: IfcLengthMeasure | null;
	ElevationOfTerrain: IfcLengthMeasure | null;
	BuildingAddress: Handle<IfcPostalAddress> | null;
	static FromTape(tape: any[]): IfcBuilding
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		let ElevationOfRefHeight = tape[9];
		let ElevationOfTerrain = tape[10];
		let BuildingAddress = tape[11];
		return new IfcBuilding(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		if(this.ElevationOfRefHeight){
		args.push(REAL)
		args.push(this.ElevationOfRefHeight)
		}
		else{ args.push(EMPTY); }
		if(this.ElevationOfTerrain){
		args.push(REAL)
		args.push(this.ElevationOfTerrain)
		}
		else{ args.push(EMPTY); }
		if(this.BuildingAddress){
		args.push(REF)
		args.push(this.BuildingAddress.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcBuildingElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcBuildingElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingElementPart {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBuildingElementPartTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBuildingElementPartTypeEnum | null;
	static FromTape(tape: any[]): IfcBuildingElementPart
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBuildingElementPart(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingElementPartType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcBuildingElementPartTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcBuildingElementPartTypeEnum ;
	static FromTape(tape: any[]): IfcBuildingElementPartType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBuildingElementPartType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingElementProxy {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBuildingElementProxyTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBuildingElementProxyTypeEnum | null;
	static FromTape(tape: any[]): IfcBuildingElementProxy
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBuildingElementProxy(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingElementProxyType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcBuildingElementProxyTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcBuildingElementProxyTypeEnum ;
	static FromTape(tape: any[]): IfcBuildingElementProxyType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBuildingElementProxyType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcBuildingElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcBuildingElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingStorey {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null, Elevation: IfcLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
		this.Elevation = Elevation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	Elevation: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcBuildingStorey
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		let Elevation = tape[9];
		return new IfcBuildingStorey(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		if(this.Elevation){
		args.push(REAL)
		args.push(this.Elevation)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBuildingSystem {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, PredefinedType: IfcBuildingSystemTypeEnum | null, LongName: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.PredefinedType = PredefinedType;
		this.LongName = LongName;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	PredefinedType: IfcBuildingSystemTypeEnum | null;
	LongName: IfcLabel | null;
	static FromTape(tape: any[]): IfcBuildingSystem
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let PredefinedType = tape[5];
		let LongName = tape[6];
		return new IfcBuildingSystem(GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBurner {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcBurnerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcBurnerTypeEnum | null;
	static FromTape(tape: any[]): IfcBurner
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcBurner(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcBurnerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcBurnerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcBurnerTypeEnum ;
	static FromTape(tape: any[]): IfcBurnerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcBurnerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Depth: IfcPositiveLengthMeasure , Width: IfcPositiveLengthMeasure , WallThickness: IfcPositiveLengthMeasure , Girth: IfcPositiveLengthMeasure , InternalFilletRadius: IfcNonNegativeLengthMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Depth = Depth;
		this.Width = Width;
		this.WallThickness = WallThickness;
		this.Girth = Girth;
		this.InternalFilletRadius = InternalFilletRadius;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Depth: IfcPositiveLengthMeasure ;
	Width: IfcPositiveLengthMeasure ;
	WallThickness: IfcPositiveLengthMeasure ;
	Girth: IfcPositiveLengthMeasure ;
	InternalFilletRadius: IfcNonNegativeLengthMeasure | null;
	static FromTape(tape: any[]): IfcCShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Depth = tape[3];
		let Width = tape[4];
		let WallThickness = tape[5];
		let Girth = tape[6];
		let InternalFilletRadius = tape[7];
		return new IfcCShapeProfileDef(ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.InternalFilletRadius){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableCarrierFitting {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCableCarrierFittingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCableCarrierFittingTypeEnum | null;
	static FromTape(tape: any[]): IfcCableCarrierFitting
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCableCarrierFitting(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableCarrierFittingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCableCarrierFittingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCableCarrierFittingTypeEnum ;
	static FromTape(tape: any[]): IfcCableCarrierFittingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCableCarrierFittingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableCarrierSegment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCableCarrierSegmentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCableCarrierSegmentTypeEnum | null;
	static FromTape(tape: any[]): IfcCableCarrierSegment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCableCarrierSegment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableCarrierSegmentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCableCarrierSegmentTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCableCarrierSegmentTypeEnum ;
	static FromTape(tape: any[]): IfcCableCarrierSegmentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCableCarrierSegmentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableFitting {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCableFittingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCableFittingTypeEnum | null;
	static FromTape(tape: any[]): IfcCableFitting
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCableFitting(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableFittingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCableFittingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCableFittingTypeEnum ;
	static FromTape(tape: any[]): IfcCableFittingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCableFittingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableSegment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCableSegmentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCableSegmentTypeEnum | null;
	static FromTape(tape: any[]): IfcCableSegment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCableSegment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCableSegmentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCableSegmentTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCableSegmentTypeEnum ;
	static FromTape(tape: any[]): IfcCableSegmentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCableSegmentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCaissonFoundation {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCaissonFoundationTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCaissonFoundationTypeEnum | null;
	static FromTape(tape: any[]): IfcCaissonFoundation
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCaissonFoundation(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCaissonFoundationType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCaissonFoundationTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCaissonFoundationTypeEnum ;
	static FromTape(tape: any[]): IfcCaissonFoundationType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCaissonFoundationType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianPoint {
	constructor(Coordinates: IfcLengthMeasure[] )
	{
		this.Coordinates = Coordinates;
	}
	Coordinates: IfcLengthMeasure[] ;
	static FromTape(tape: any[]): IfcCartesianPoint
	{
		let Coordinates = tape[0];
		return new IfcCartesianPoint(Coordinates);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(...this.Coordinates)
		return args;
	}
};
export class IfcCartesianPointList {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcCartesianPointList
	{
		return new IfcCartesianPointList();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcCartesianPointList2D {
	constructor(CoordList: IfcLengthMeasure[] , TagList: IfcLabel[] | null)
	{
		this.CoordList = CoordList;
		this.TagList = TagList;
	}
	CoordList: IfcLengthMeasure[] ;
	TagList: IfcLabel[] | null;
	static FromTape(tape: any[]): IfcCartesianPointList2D
	{
		let CoordList = tape[0];
		let TagList = tape[1];
		return new IfcCartesianPointList2D(CoordList, TagList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(...this.CoordList)
		if(this.TagList){
		args.push(STRING)
		args.push(...this.TagList)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianPointList3D {
	constructor(CoordList: IfcLengthMeasure[] , TagList: IfcLabel[] | null)
	{
		this.CoordList = CoordList;
		this.TagList = TagList;
	}
	CoordList: IfcLengthMeasure[] ;
	TagList: IfcLabel[] | null;
	static FromTape(tape: any[]): IfcCartesianPointList3D
	{
		let CoordList = tape[0];
		let TagList = tape[1];
		return new IfcCartesianPointList3D(CoordList, TagList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(...this.CoordList)
		if(this.TagList){
		args.push(STRING)
		args.push(...this.TagList)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianTransformationOperator {
	constructor(Axis1: Handle<IfcDirection> | null, Axis2: Handle<IfcDirection> | null, LocalOrigin: Handle<IfcCartesianPoint> , Scale: IfcReal | null)
	{
		this.Axis1 = Axis1;
		this.Axis2 = Axis2;
		this.LocalOrigin = LocalOrigin;
		this.Scale = Scale;
	}
	Axis1: Handle<IfcDirection> | null;
	Axis2: Handle<IfcDirection> | null;
	LocalOrigin: Handle<IfcCartesianPoint> ;
	Scale: IfcReal | null;
	static FromTape(tape: any[]): IfcCartesianTransformationOperator
	{
		let Axis1 = tape[0];
		let Axis2 = tape[1];
		let LocalOrigin = tape[2];
		let Scale = tape[3];
		return new IfcCartesianTransformationOperator(Axis1, Axis2, LocalOrigin, Scale);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Axis1){
		args.push(REF)
		args.push(this.Axis1.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Axis2){
		args.push(REF)
		args.push(this.Axis2.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LocalOrigin.expressID)
		if(this.Scale){
		args.push(REAL)
		args.push(this.Scale)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianTransformationOperator2D {
	constructor(Axis1: Handle<IfcDirection> | null, Axis2: Handle<IfcDirection> | null, LocalOrigin: Handle<IfcCartesianPoint> , Scale: IfcReal | null)
	{
		this.Axis1 = Axis1;
		this.Axis2 = Axis2;
		this.LocalOrigin = LocalOrigin;
		this.Scale = Scale;
	}
	Axis1: Handle<IfcDirection> | null;
	Axis2: Handle<IfcDirection> | null;
	LocalOrigin: Handle<IfcCartesianPoint> ;
	Scale: IfcReal | null;
	static FromTape(tape: any[]): IfcCartesianTransformationOperator2D
	{
		let Axis1 = tape[0];
		let Axis2 = tape[1];
		let LocalOrigin = tape[2];
		let Scale = tape[3];
		return new IfcCartesianTransformationOperator2D(Axis1, Axis2, LocalOrigin, Scale);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Axis1){
		args.push(REF)
		args.push(this.Axis1.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Axis2){
		args.push(REF)
		args.push(this.Axis2.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LocalOrigin.expressID)
		if(this.Scale){
		args.push(REAL)
		args.push(this.Scale)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianTransformationOperator2DnonUniform {
	constructor(Axis1: Handle<IfcDirection> | null, Axis2: Handle<IfcDirection> | null, LocalOrigin: Handle<IfcCartesianPoint> , Scale: IfcReal | null, Scale2: IfcReal | null)
	{
		this.Axis1 = Axis1;
		this.Axis2 = Axis2;
		this.LocalOrigin = LocalOrigin;
		this.Scale = Scale;
		this.Scale2 = Scale2;
	}
	Axis1: Handle<IfcDirection> | null;
	Axis2: Handle<IfcDirection> | null;
	LocalOrigin: Handle<IfcCartesianPoint> ;
	Scale: IfcReal | null;
	Scale2: IfcReal | null;
	static FromTape(tape: any[]): IfcCartesianTransformationOperator2DnonUniform
	{
		let Axis1 = tape[0];
		let Axis2 = tape[1];
		let LocalOrigin = tape[2];
		let Scale = tape[3];
		let Scale2 = tape[4];
		return new IfcCartesianTransformationOperator2DnonUniform(Axis1, Axis2, LocalOrigin, Scale, Scale2);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Axis1){
		args.push(REF)
		args.push(this.Axis1.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Axis2){
		args.push(REF)
		args.push(this.Axis2.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LocalOrigin.expressID)
		if(this.Scale){
		args.push(REAL)
		args.push(this.Scale)
		}
		else{ args.push(EMPTY); }
		if(this.Scale2){
		args.push(REAL)
		args.push(this.Scale2)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianTransformationOperator3D {
	constructor(Axis1: Handle<IfcDirection> | null, Axis2: Handle<IfcDirection> | null, LocalOrigin: Handle<IfcCartesianPoint> , Scale: IfcReal | null, Axis3: Handle<IfcDirection> | null)
	{
		this.Axis1 = Axis1;
		this.Axis2 = Axis2;
		this.LocalOrigin = LocalOrigin;
		this.Scale = Scale;
		this.Axis3 = Axis3;
	}
	Axis1: Handle<IfcDirection> | null;
	Axis2: Handle<IfcDirection> | null;
	LocalOrigin: Handle<IfcCartesianPoint> ;
	Scale: IfcReal | null;
	Axis3: Handle<IfcDirection> | null;
	static FromTape(tape: any[]): IfcCartesianTransformationOperator3D
	{
		let Axis1 = tape[0];
		let Axis2 = tape[1];
		let LocalOrigin = tape[2];
		let Scale = tape[3];
		let Axis3 = tape[4];
		return new IfcCartesianTransformationOperator3D(Axis1, Axis2, LocalOrigin, Scale, Axis3);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Axis1){
		args.push(REF)
		args.push(this.Axis1.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Axis2){
		args.push(REF)
		args.push(this.Axis2.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LocalOrigin.expressID)
		if(this.Scale){
		args.push(REAL)
		args.push(this.Scale)
		}
		else{ args.push(EMPTY); }
		if(this.Axis3){
		args.push(REF)
		args.push(this.Axis3.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCartesianTransformationOperator3DnonUniform {
	constructor(Axis1: Handle<IfcDirection> | null, Axis2: Handle<IfcDirection> | null, LocalOrigin: Handle<IfcCartesianPoint> , Scale: IfcReal | null, Axis3: Handle<IfcDirection> | null, Scale2: IfcReal | null, Scale3: IfcReal | null)
	{
		this.Axis1 = Axis1;
		this.Axis2 = Axis2;
		this.LocalOrigin = LocalOrigin;
		this.Scale = Scale;
		this.Axis3 = Axis3;
		this.Scale2 = Scale2;
		this.Scale3 = Scale3;
	}
	Axis1: Handle<IfcDirection> | null;
	Axis2: Handle<IfcDirection> | null;
	LocalOrigin: Handle<IfcCartesianPoint> ;
	Scale: IfcReal | null;
	Axis3: Handle<IfcDirection> | null;
	Scale2: IfcReal | null;
	Scale3: IfcReal | null;
	static FromTape(tape: any[]): IfcCartesianTransformationOperator3DnonUniform
	{
		let Axis1 = tape[0];
		let Axis2 = tape[1];
		let LocalOrigin = tape[2];
		let Scale = tape[3];
		let Axis3 = tape[4];
		let Scale2 = tape[5];
		let Scale3 = tape[6];
		return new IfcCartesianTransformationOperator3DnonUniform(Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Axis1){
		args.push(REF)
		args.push(this.Axis1.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Axis2){
		args.push(REF)
		args.push(this.Axis2.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LocalOrigin.expressID)
		if(this.Scale){
		args.push(REAL)
		args.push(this.Scale)
		}
		else{ args.push(EMPTY); }
		if(this.Axis3){
		args.push(REF)
		args.push(this.Axis3.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Scale2){
		args.push(REAL)
		args.push(this.Scale2)
		}
		else{ args.push(EMPTY); }
		if(this.Scale3){
		args.push(REAL)
		args.push(this.Scale3)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCenterLineProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Curve: Handle<IfcBoundedCurve> , Thickness: IfcPositiveLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Curve = Curve;
		this.Thickness = Thickness;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Curve: Handle<IfcBoundedCurve> ;
	Thickness: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCenterLineProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Curve = tape[2];
		let Thickness = tape[3];
		return new IfcCenterLineProfileDef(ProfileType, ProfileName, Curve, Thickness);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Curve.expressID)
		return args;
	}
};
export class IfcChiller {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcChillerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcChillerTypeEnum | null;
	static FromTape(tape: any[]): IfcChiller
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcChiller(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcChillerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcChillerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcChillerTypeEnum ;
	static FromTape(tape: any[]): IfcChillerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcChillerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcChimney {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcChimneyTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcChimneyTypeEnum | null;
	static FromTape(tape: any[]): IfcChimney
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcChimney(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcChimneyType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcChimneyTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcChimneyTypeEnum ;
	static FromTape(tape: any[]): IfcChimneyType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcChimneyType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCircle {
	constructor(Position: IfcAxis2Placement , Radius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.Radius = Radius;
	}
	Position: IfcAxis2Placement ;
	Radius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCircle
	{
		let Position = tape[0];
		let Radius = tape[1];
		return new IfcCircle(Position, Radius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcCircleHollowProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Radius: IfcPositiveLengthMeasure , WallThickness: IfcPositiveLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Radius = Radius;
		this.WallThickness = WallThickness;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Radius: IfcPositiveLengthMeasure ;
	WallThickness: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCircleHollowProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Radius = tape[3];
		let WallThickness = tape[4];
		return new IfcCircleHollowProfileDef(ProfileType, ProfileName, Position, Radius, WallThickness);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCircleProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Radius: IfcPositiveLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Radius = Radius;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Radius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCircleProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Radius = tape[3];
		return new IfcCircleProfileDef(ProfileType, ProfileName, Position, Radius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCircularArcSegment2D {
	constructor(StartPoint: Handle<IfcCartesianPoint> , StartDirection: IfcPlaneAngleMeasure , SegmentLength: IfcPositiveLengthMeasure , Radius: IfcPositiveLengthMeasure , IsCCW: IfcBoolean )
	{
		this.StartPoint = StartPoint;
		this.StartDirection = StartDirection;
		this.SegmentLength = SegmentLength;
		this.Radius = Radius;
		this.IsCCW = IsCCW;
	}
	StartPoint: Handle<IfcCartesianPoint> ;
	StartDirection: IfcPlaneAngleMeasure ;
	SegmentLength: IfcPositiveLengthMeasure ;
	Radius: IfcPositiveLengthMeasure ;
	IsCCW: IfcBoolean ;
	static FromTape(tape: any[]): IfcCircularArcSegment2D
	{
		let StartPoint = tape[0];
		let StartDirection = tape[1];
		let SegmentLength = tape[2];
		let Radius = tape[3];
		let IsCCW = tape[4];
		return new IfcCircularArcSegment2D(StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.StartPoint.expressID)
		args.push(REAL)
		args.push(this.StartDirection)
		return args;
	}
};
export class IfcCivilElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcCivilElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcCivilElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCivilElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcCivilElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcCivilElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcClassification {
	constructor(Source: IfcLabel | null, Edition: IfcLabel | null, EditionDate: IfcDate | null, Name: IfcLabel , Description: IfcText | null, Location: IfcURIReference | null, ReferenceTokens: IfcIdentifier[] | null)
	{
		this.Source = Source;
		this.Edition = Edition;
		this.EditionDate = EditionDate;
		this.Name = Name;
		this.Description = Description;
		this.Location = Location;
		this.ReferenceTokens = ReferenceTokens;
	}
	Source: IfcLabel | null;
	Edition: IfcLabel | null;
	EditionDate: IfcDate | null;
	Name: IfcLabel ;
	Description: IfcText | null;
	Location: IfcURIReference | null;
	ReferenceTokens: IfcIdentifier[] | null;
	static FromTape(tape: any[]): IfcClassification
	{
		let Source = tape[0];
		let Edition = tape[1];
		let EditionDate = tape[2];
		let Name = tape[3];
		let Description = tape[4];
		let Location = tape[5];
		let ReferenceTokens = tape[6];
		return new IfcClassification(Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Source){
		args.push(STRING)
		args.push(this.Source)
		}
		else{ args.push(EMPTY); }
		if(this.Edition){
		args.push(STRING)
		args.push(this.Edition)
		}
		else{ args.push(EMPTY); }
		if(this.EditionDate){
		args.push(STRING)
		args.push(this.EditionDate)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.ReferenceTokens){
		args.push(STRING)
		args.push(...this.ReferenceTokens)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcClassificationReference {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null, ReferencedSource: IfcClassificationReferenceSelect | null, Description: IfcText | null, Sort: IfcIdentifier | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
		this.ReferencedSource = ReferencedSource;
		this.Description = Description;
		this.Sort = Sort;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	ReferencedSource: IfcClassificationReferenceSelect | null;
	Description: IfcText | null;
	Sort: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcClassificationReference
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		let ReferencedSource = tape[3];
		let Description = tape[4];
		let Sort = tape[5];
		return new IfcClassificationReference(Location, Identification, Name, ReferencedSource, Description, Sort);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.ReferencedSource){
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Sort){
		args.push(STRING)
		args.push(this.Sort)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcClosedShell {
	constructor(CfsFaces: Handle<IfcFace>[] )
	{
		this.CfsFaces = CfsFaces;
	}
	CfsFaces: Handle<IfcFace>[] ;
	static FromTape(tape: any[]): IfcClosedShell
	{
		let CfsFaces = tape[0];
		return new IfcClosedShell(CfsFaces);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.CfsFaces.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcCoil {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCoilTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCoilTypeEnum | null;
	static FromTape(tape: any[]): IfcCoil
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCoil(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCoilType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCoilTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCoilTypeEnum ;
	static FromTape(tape: any[]): IfcCoilType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCoilType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcColourRgb {
	constructor(Name: IfcLabel | null, Red: IfcNormalisedRatioMeasure , Green: IfcNormalisedRatioMeasure , Blue: IfcNormalisedRatioMeasure )
	{
		this.Name = Name;
		this.Red = Red;
		this.Green = Green;
		this.Blue = Blue;
	}
	Name: IfcLabel | null;
	Red: IfcNormalisedRatioMeasure ;
	Green: IfcNormalisedRatioMeasure ;
	Blue: IfcNormalisedRatioMeasure ;
	static FromTape(tape: any[]): IfcColourRgb
	{
		let Name = tape[0];
		let Red = tape[1];
		let Green = tape[2];
		let Blue = tape[3];
		return new IfcColourRgb(Name, Red, Green, Blue);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcColourRgbList {
	constructor(ColourList: IfcNormalisedRatioMeasure[] )
	{
		this.ColourList = ColourList;
	}
	ColourList: IfcNormalisedRatioMeasure[] ;
	static FromTape(tape: any[]): IfcColourRgbList
	{
		let ColourList = tape[0];
		return new IfcColourRgbList(ColourList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcColourSpecification {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcColourSpecification
	{
		let Name = tape[0];
		return new IfcColourSpecification(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcColumn {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcColumnTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcColumnTypeEnum | null;
	static FromTape(tape: any[]): IfcColumn
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcColumn(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcColumnStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcColumnTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcColumnTypeEnum | null;
	static FromTape(tape: any[]): IfcColumnStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcColumnStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcColumnType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcColumnTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcColumnTypeEnum ;
	static FromTape(tape: any[]): IfcColumnType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcColumnType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCommunicationsAppliance {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCommunicationsApplianceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCommunicationsApplianceTypeEnum | null;
	static FromTape(tape: any[]): IfcCommunicationsAppliance
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCommunicationsAppliance(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCommunicationsApplianceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCommunicationsApplianceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCommunicationsApplianceTypeEnum ;
	static FromTape(tape: any[]): IfcCommunicationsApplianceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCommunicationsApplianceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcComplexProperty {
	constructor(Name: IfcIdentifier , Description: IfcText | null, UsageName: IfcIdentifier , HasProperties: Handle<IfcProperty>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.UsageName = UsageName;
		this.HasProperties = HasProperties;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	UsageName: IfcIdentifier ;
	HasProperties: Handle<IfcProperty>[] ;
	static FromTape(tape: any[]): IfcComplexProperty
	{
		let Name = tape[0];
		let Description = tape[1];
		let UsageName = tape[2];
		let HasProperties = tape[3];
		return new IfcComplexProperty(Name, Description, UsageName, HasProperties);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.UsageName)
		args.push(SET_BEGIN)
		this.HasProperties.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcComplexPropertyTemplate {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, UsageName: IfcLabel | null, TemplateType: IfcComplexPropertyTemplateTypeEnum | null, HasPropertyTemplates: Handle<IfcPropertyTemplate>[] | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.UsageName = UsageName;
		this.TemplateType = TemplateType;
		this.HasPropertyTemplates = HasPropertyTemplates;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	UsageName: IfcLabel | null;
	TemplateType: IfcComplexPropertyTemplateTypeEnum | null;
	HasPropertyTemplates: Handle<IfcPropertyTemplate>[] | null;
	static FromTape(tape: any[]): IfcComplexPropertyTemplate
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let UsageName = tape[4];
		let TemplateType = tape[5];
		let HasPropertyTemplates = tape[6];
		return new IfcComplexPropertyTemplate(GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.UsageName){
		args.push(STRING)
		args.push(this.UsageName)
		}
		else{ args.push(EMPTY); }
		if(this.TemplateType){
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertyTemplates){
		args.push(SET_BEGIN)
		this.HasPropertyTemplates.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCompositeCurve {
	constructor(Segments: Handle<IfcCompositeCurveSegment>[] , SelfIntersect: IfcLogical )
	{
		this.Segments = Segments;
		this.SelfIntersect = SelfIntersect;
	}
	Segments: Handle<IfcCompositeCurveSegment>[] ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcCompositeCurve
	{
		let Segments = tape[0];
		let SelfIntersect = tape[1];
		return new IfcCompositeCurve(Segments, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Segments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcCompositeCurveOnSurface {
	constructor(Segments: Handle<IfcCompositeCurveSegment>[] , SelfIntersect: IfcLogical )
	{
		this.Segments = Segments;
		this.SelfIntersect = SelfIntersect;
	}
	Segments: Handle<IfcCompositeCurveSegment>[] ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcCompositeCurveOnSurface
	{
		let Segments = tape[0];
		let SelfIntersect = tape[1];
		return new IfcCompositeCurveOnSurface(Segments, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Segments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcCompositeCurveSegment {
	constructor(Transition: IfcTransitionCode , SameSense: IfcBoolean , ParentCurve: Handle<IfcCurve> )
	{
		this.Transition = Transition;
		this.SameSense = SameSense;
		this.ParentCurve = ParentCurve;
	}
	Transition: IfcTransitionCode ;
	SameSense: IfcBoolean ;
	ParentCurve: Handle<IfcCurve> ;
	static FromTape(tape: any[]): IfcCompositeCurveSegment
	{
		let Transition = tape[0];
		let SameSense = tape[1];
		let ParentCurve = tape[2];
		return new IfcCompositeCurveSegment(Transition, SameSense, ParentCurve);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ParentCurve.expressID)
		return args;
	}
};
export class IfcCompositeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Profiles: Handle<IfcProfileDef>[] , Label: IfcLabel | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Profiles = Profiles;
		this.Label = Label;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Profiles: Handle<IfcProfileDef>[] ;
	Label: IfcLabel | null;
	static FromTape(tape: any[]): IfcCompositeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Profiles = tape[2];
		let Label = tape[3];
		return new IfcCompositeProfileDef(ProfileType, ProfileName, Profiles, Label);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Profiles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.Label){
		args.push(STRING)
		args.push(this.Label)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCompressor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCompressorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCompressorTypeEnum | null;
	static FromTape(tape: any[]): IfcCompressor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCompressor(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCompressorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCompressorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCompressorTypeEnum ;
	static FromTape(tape: any[]): IfcCompressorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCompressorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCondenser {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCondenserTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCondenserTypeEnum | null;
	static FromTape(tape: any[]): IfcCondenser
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCondenser(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCondenserType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCondenserTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCondenserTypeEnum ;
	static FromTape(tape: any[]): IfcCondenserType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCondenserType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConic {
	constructor(Position: IfcAxis2Placement )
	{
		this.Position = Position;
	}
	Position: IfcAxis2Placement ;
	static FromTape(tape: any[]): IfcConic
	{
		let Position = tape[0];
		return new IfcConic(Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcConnectedFaceSet {
	constructor(CfsFaces: Handle<IfcFace>[] )
	{
		this.CfsFaces = CfsFaces;
	}
	CfsFaces: Handle<IfcFace>[] ;
	static FromTape(tape: any[]): IfcConnectedFaceSet
	{
		let CfsFaces = tape[0];
		return new IfcConnectedFaceSet(CfsFaces);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.CfsFaces.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcConnectionCurveGeometry {
	constructor(CurveOnRelatingElement: IfcCurveOrEdgeCurve , CurveOnRelatedElement: IfcCurveOrEdgeCurve | null)
	{
		this.CurveOnRelatingElement = CurveOnRelatingElement;
		this.CurveOnRelatedElement = CurveOnRelatedElement;
	}
	CurveOnRelatingElement: IfcCurveOrEdgeCurve ;
	CurveOnRelatedElement: IfcCurveOrEdgeCurve | null;
	static FromTape(tape: any[]): IfcConnectionCurveGeometry
	{
		let CurveOnRelatingElement = tape[0];
		let CurveOnRelatedElement = tape[1];
		return new IfcConnectionCurveGeometry(CurveOnRelatingElement, CurveOnRelatedElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.CurveOnRelatedElement){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConnectionGeometry {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcConnectionGeometry
	{
		return new IfcConnectionGeometry();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcConnectionPointEccentricity {
	constructor(PointOnRelatingElement: IfcPointOrVertexPoint , PointOnRelatedElement: IfcPointOrVertexPoint | null, EccentricityInX: IfcLengthMeasure | null, EccentricityInY: IfcLengthMeasure | null, EccentricityInZ: IfcLengthMeasure | null)
	{
		this.PointOnRelatingElement = PointOnRelatingElement;
		this.PointOnRelatedElement = PointOnRelatedElement;
		this.EccentricityInX = EccentricityInX;
		this.EccentricityInY = EccentricityInY;
		this.EccentricityInZ = EccentricityInZ;
	}
	PointOnRelatingElement: IfcPointOrVertexPoint ;
	PointOnRelatedElement: IfcPointOrVertexPoint | null;
	EccentricityInX: IfcLengthMeasure | null;
	EccentricityInY: IfcLengthMeasure | null;
	EccentricityInZ: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcConnectionPointEccentricity
	{
		let PointOnRelatingElement = tape[0];
		let PointOnRelatedElement = tape[1];
		let EccentricityInX = tape[2];
		let EccentricityInY = tape[3];
		let EccentricityInZ = tape[4];
		return new IfcConnectionPointEccentricity(PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.PointOnRelatedElement){
		}
		else{ args.push(EMPTY); }
		if(this.EccentricityInX){
		args.push(REAL)
		args.push(this.EccentricityInX)
		}
		else{ args.push(EMPTY); }
		if(this.EccentricityInY){
		args.push(REAL)
		args.push(this.EccentricityInY)
		}
		else{ args.push(EMPTY); }
		if(this.EccentricityInZ){
		args.push(REAL)
		args.push(this.EccentricityInZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConnectionPointGeometry {
	constructor(PointOnRelatingElement: IfcPointOrVertexPoint , PointOnRelatedElement: IfcPointOrVertexPoint | null)
	{
		this.PointOnRelatingElement = PointOnRelatingElement;
		this.PointOnRelatedElement = PointOnRelatedElement;
	}
	PointOnRelatingElement: IfcPointOrVertexPoint ;
	PointOnRelatedElement: IfcPointOrVertexPoint | null;
	static FromTape(tape: any[]): IfcConnectionPointGeometry
	{
		let PointOnRelatingElement = tape[0];
		let PointOnRelatedElement = tape[1];
		return new IfcConnectionPointGeometry(PointOnRelatingElement, PointOnRelatedElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.PointOnRelatedElement){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConnectionSurfaceGeometry {
	constructor(SurfaceOnRelatingElement: IfcSurfaceOrFaceSurface , SurfaceOnRelatedElement: IfcSurfaceOrFaceSurface | null)
	{
		this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
		this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
	}
	SurfaceOnRelatingElement: IfcSurfaceOrFaceSurface ;
	SurfaceOnRelatedElement: IfcSurfaceOrFaceSurface | null;
	static FromTape(tape: any[]): IfcConnectionSurfaceGeometry
	{
		let SurfaceOnRelatingElement = tape[0];
		let SurfaceOnRelatedElement = tape[1];
		return new IfcConnectionSurfaceGeometry(SurfaceOnRelatingElement, SurfaceOnRelatedElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.SurfaceOnRelatedElement){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConnectionVolumeGeometry {
	constructor(VolumeOnRelatingElement: IfcSolidOrShell , VolumeOnRelatedElement: IfcSolidOrShell | null)
	{
		this.VolumeOnRelatingElement = VolumeOnRelatingElement;
		this.VolumeOnRelatedElement = VolumeOnRelatedElement;
	}
	VolumeOnRelatingElement: IfcSolidOrShell ;
	VolumeOnRelatedElement: IfcSolidOrShell | null;
	static FromTape(tape: any[]): IfcConnectionVolumeGeometry
	{
		let VolumeOnRelatingElement = tape[0];
		let VolumeOnRelatedElement = tape[1];
		return new IfcConnectionVolumeGeometry(VolumeOnRelatingElement, VolumeOnRelatedElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.VolumeOnRelatedElement){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstraint {
	constructor(Name: IfcLabel , Description: IfcText | null, ConstraintGrade: IfcConstraintEnum , ConstraintSource: IfcLabel | null, CreatingActor: IfcActorSelect | null, CreationTime: IfcDateTime | null, UserDefinedGrade: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.ConstraintGrade = ConstraintGrade;
		this.ConstraintSource = ConstraintSource;
		this.CreatingActor = CreatingActor;
		this.CreationTime = CreationTime;
		this.UserDefinedGrade = UserDefinedGrade;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	ConstraintGrade: IfcConstraintEnum ;
	ConstraintSource: IfcLabel | null;
	CreatingActor: IfcActorSelect | null;
	CreationTime: IfcDateTime | null;
	UserDefinedGrade: IfcLabel | null;
	static FromTape(tape: any[]): IfcConstraint
	{
		let Name = tape[0];
		let Description = tape[1];
		let ConstraintGrade = tape[2];
		let ConstraintSource = tape[3];
		let CreatingActor = tape[4];
		let CreationTime = tape[5];
		let UserDefinedGrade = tape[6];
		return new IfcConstraint(Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ConstraintSource){
		args.push(STRING)
		args.push(this.ConstraintSource)
		}
		else{ args.push(EMPTY); }
		if(this.CreatingActor){
		}
		else{ args.push(EMPTY); }
		if(this.CreationTime){
		args.push(STRING)
		args.push(this.CreationTime)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedGrade){
		args.push(STRING)
		args.push(this.UserDefinedGrade)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionEquipmentResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcConstructionEquipmentResourceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcConstructionEquipmentResourceTypeEnum | null;
	static FromTape(tape: any[]): IfcConstructionEquipmentResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		let PredefinedType = tape[10];
		return new IfcConstructionEquipmentResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionEquipmentResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcConstructionEquipmentResourceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcConstructionEquipmentResourceTypeEnum ;
	static FromTape(tape: any[]): IfcConstructionEquipmentResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		let PredefinedType = tape[11];
		return new IfcConstructionEquipmentResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionMaterialResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcConstructionMaterialResourceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcConstructionMaterialResourceTypeEnum | null;
	static FromTape(tape: any[]): IfcConstructionMaterialResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		let PredefinedType = tape[10];
		return new IfcConstructionMaterialResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionMaterialResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcConstructionMaterialResourceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcConstructionMaterialResourceTypeEnum ;
	static FromTape(tape: any[]): IfcConstructionMaterialResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		let PredefinedType = tape[11];
		return new IfcConstructionMaterialResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionProductResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcConstructionProductResourceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcConstructionProductResourceTypeEnum | null;
	static FromTape(tape: any[]): IfcConstructionProductResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		let PredefinedType = tape[10];
		return new IfcConstructionProductResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionProductResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcConstructionProductResourceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcConstructionProductResourceTypeEnum ;
	static FromTape(tape: any[]): IfcConstructionProductResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		let PredefinedType = tape[11];
		return new IfcConstructionProductResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	static FromTape(tape: any[]): IfcConstructionResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		return new IfcConstructionResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConstructionResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	static FromTape(tape: any[]): IfcConstructionResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		return new IfcConstructionResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcContext {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, LongName: IfcLabel | null, Phase: IfcLabel | null, RepresentationContexts: Handle<IfcRepresentationContext>[] | null, UnitsInContext: Handle<IfcUnitAssignment> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.LongName = LongName;
		this.Phase = Phase;
		this.RepresentationContexts = RepresentationContexts;
		this.UnitsInContext = UnitsInContext;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	LongName: IfcLabel | null;
	Phase: IfcLabel | null;
	RepresentationContexts: Handle<IfcRepresentationContext>[] | null;
	UnitsInContext: Handle<IfcUnitAssignment> | null;
	static FromTape(tape: any[]): IfcContext
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let LongName = tape[5];
		let Phase = tape[6];
		let RepresentationContexts = tape[7];
		let UnitsInContext = tape[8];
		return new IfcContext(GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.Phase){
		args.push(STRING)
		args.push(this.Phase)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationContexts){
		args.push(SET_BEGIN)
		this.RepresentationContexts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.UnitsInContext){
		args.push(REF)
		args.push(this.UnitsInContext.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcContextDependentUnit {
	constructor(Dimensions: Handle<IfcDimensionalExponents> , UnitType: IfcUnitEnum , Name: IfcLabel )
	{
		this.Dimensions = Dimensions;
		this.UnitType = UnitType;
		this.Name = Name;
	}
	Dimensions: Handle<IfcDimensionalExponents> ;
	UnitType: IfcUnitEnum ;
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcContextDependentUnit
	{
		let Dimensions = tape[0];
		let UnitType = tape[1];
		let Name = tape[2];
		return new IfcContextDependentUnit(Dimensions, UnitType, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Dimensions.expressID)
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcControl {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcControl
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		return new IfcControl(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcController {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcControllerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcControllerTypeEnum | null;
	static FromTape(tape: any[]): IfcController
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcController(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcControllerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcControllerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcControllerTypeEnum ;
	static FromTape(tape: any[]): IfcControllerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcControllerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcConversionBasedUnit {
	constructor(Dimensions: Handle<IfcDimensionalExponents> , UnitType: IfcUnitEnum , Name: IfcLabel , ConversionFactor: Handle<IfcMeasureWithUnit> )
	{
		this.Dimensions = Dimensions;
		this.UnitType = UnitType;
		this.Name = Name;
		this.ConversionFactor = ConversionFactor;
	}
	Dimensions: Handle<IfcDimensionalExponents> ;
	UnitType: IfcUnitEnum ;
	Name: IfcLabel ;
	ConversionFactor: Handle<IfcMeasureWithUnit> ;
	static FromTape(tape: any[]): IfcConversionBasedUnit
	{
		let Dimensions = tape[0];
		let UnitType = tape[1];
		let Name = tape[2];
		let ConversionFactor = tape[3];
		return new IfcConversionBasedUnit(Dimensions, UnitType, Name, ConversionFactor);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Dimensions.expressID)
		args.push(STRING)
		args.push(this.Name)
		args.push(REF)
		args.push(this.ConversionFactor.expressID)
		return args;
	}
};
export class IfcConversionBasedUnitWithOffset {
	constructor(Dimensions: Handle<IfcDimensionalExponents> , UnitType: IfcUnitEnum , Name: IfcLabel , ConversionFactor: Handle<IfcMeasureWithUnit> , ConversionOffset: IfcReal )
	{
		this.Dimensions = Dimensions;
		this.UnitType = UnitType;
		this.Name = Name;
		this.ConversionFactor = ConversionFactor;
		this.ConversionOffset = ConversionOffset;
	}
	Dimensions: Handle<IfcDimensionalExponents> ;
	UnitType: IfcUnitEnum ;
	Name: IfcLabel ;
	ConversionFactor: Handle<IfcMeasureWithUnit> ;
	ConversionOffset: IfcReal ;
	static FromTape(tape: any[]): IfcConversionBasedUnitWithOffset
	{
		let Dimensions = tape[0];
		let UnitType = tape[1];
		let Name = tape[2];
		let ConversionFactor = tape[3];
		let ConversionOffset = tape[4];
		return new IfcConversionBasedUnitWithOffset(Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Dimensions.expressID)
		args.push(STRING)
		args.push(this.Name)
		args.push(REF)
		args.push(this.ConversionFactor.expressID)
		args.push(REAL)
		args.push(this.ConversionOffset)
		return args;
	}
};
export class IfcCooledBeam {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCooledBeamTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCooledBeamTypeEnum | null;
	static FromTape(tape: any[]): IfcCooledBeam
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCooledBeam(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCooledBeamType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCooledBeamTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCooledBeamTypeEnum ;
	static FromTape(tape: any[]): IfcCooledBeamType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCooledBeamType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCoolingTower {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCoolingTowerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCoolingTowerTypeEnum | null;
	static FromTape(tape: any[]): IfcCoolingTower
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCoolingTower(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCoolingTowerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCoolingTowerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCoolingTowerTypeEnum ;
	static FromTape(tape: any[]): IfcCoolingTowerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCoolingTowerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCoordinateOperation {
	constructor(SourceCRS: IfcCoordinateReferenceSystemSelect , TargetCRS: Handle<IfcCoordinateReferenceSystem> )
	{
		this.SourceCRS = SourceCRS;
		this.TargetCRS = TargetCRS;
	}
	SourceCRS: IfcCoordinateReferenceSystemSelect ;
	TargetCRS: Handle<IfcCoordinateReferenceSystem> ;
	static FromTape(tape: any[]): IfcCoordinateOperation
	{
		let SourceCRS = tape[0];
		let TargetCRS = tape[1];
		return new IfcCoordinateOperation(SourceCRS, TargetCRS);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.TargetCRS.expressID)
		return args;
	}
};
export class IfcCoordinateReferenceSystem {
	constructor(Name: IfcLabel , Description: IfcText | null, GeodeticDatum: IfcIdentifier | null, VerticalDatum: IfcIdentifier | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.GeodeticDatum = GeodeticDatum;
		this.VerticalDatum = VerticalDatum;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	GeodeticDatum: IfcIdentifier | null;
	VerticalDatum: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcCoordinateReferenceSystem
	{
		let Name = tape[0];
		let Description = tape[1];
		let GeodeticDatum = tape[2];
		let VerticalDatum = tape[3];
		return new IfcCoordinateReferenceSystem(Name, Description, GeodeticDatum, VerticalDatum);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.GeodeticDatum){
		args.push(STRING)
		args.push(this.GeodeticDatum)
		}
		else{ args.push(EMPTY); }
		if(this.VerticalDatum){
		args.push(STRING)
		args.push(this.VerticalDatum)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCostItem {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, PredefinedType: IfcCostItemTypeEnum | null, CostValues: Handle<IfcCostValue>[] | null, CostQuantities: Handle<IfcPhysicalQuantity>[] | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.PredefinedType = PredefinedType;
		this.CostValues = CostValues;
		this.CostQuantities = CostQuantities;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	PredefinedType: IfcCostItemTypeEnum | null;
	CostValues: Handle<IfcCostValue>[] | null;
	CostQuantities: Handle<IfcPhysicalQuantity>[] | null;
	static FromTape(tape: any[]): IfcCostItem
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let PredefinedType = tape[6];
		let CostValues = tape[7];
		let CostQuantities = tape[8];
		return new IfcCostItem(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.CostValues){
		args.push(SET_BEGIN)
		this.CostValues.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.CostQuantities){
		args.push(SET_BEGIN)
		this.CostQuantities.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCostSchedule {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, PredefinedType: IfcCostScheduleTypeEnum | null, Status: IfcLabel | null, SubmittedOn: IfcDateTime | null, UpdateDate: IfcDateTime | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.PredefinedType = PredefinedType;
		this.Status = Status;
		this.SubmittedOn = SubmittedOn;
		this.UpdateDate = UpdateDate;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	PredefinedType: IfcCostScheduleTypeEnum | null;
	Status: IfcLabel | null;
	SubmittedOn: IfcDateTime | null;
	UpdateDate: IfcDateTime | null;
	static FromTape(tape: any[]): IfcCostSchedule
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let PredefinedType = tape[6];
		let Status = tape[7];
		let SubmittedOn = tape[8];
		let UpdateDate = tape[9];
		return new IfcCostSchedule(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		args.push(STRING)
		args.push(this.Status)
		}
		else{ args.push(EMPTY); }
		if(this.SubmittedOn){
		args.push(STRING)
		args.push(this.SubmittedOn)
		}
		else{ args.push(EMPTY); }
		if(this.UpdateDate){
		args.push(STRING)
		args.push(this.UpdateDate)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCostValue {
	constructor(Name: IfcLabel | null, Description: IfcText | null, AppliedValue: IfcAppliedValueSelect | null, UnitBasis: Handle<IfcMeasureWithUnit> | null, ApplicableDate: IfcDate | null, FixedUntilDate: IfcDate | null, Category: IfcLabel | null, Condition: IfcLabel | null, ArithmeticOperator: IfcArithmeticOperatorEnum | null, Components: Handle<IfcAppliedValue>[] | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.AppliedValue = AppliedValue;
		this.UnitBasis = UnitBasis;
		this.ApplicableDate = ApplicableDate;
		this.FixedUntilDate = FixedUntilDate;
		this.Category = Category;
		this.Condition = Condition;
		this.ArithmeticOperator = ArithmeticOperator;
		this.Components = Components;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	AppliedValue: IfcAppliedValueSelect | null;
	UnitBasis: Handle<IfcMeasureWithUnit> | null;
	ApplicableDate: IfcDate | null;
	FixedUntilDate: IfcDate | null;
	Category: IfcLabel | null;
	Condition: IfcLabel | null;
	ArithmeticOperator: IfcArithmeticOperatorEnum | null;
	Components: Handle<IfcAppliedValue>[] | null;
	static FromTape(tape: any[]): IfcCostValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let AppliedValue = tape[2];
		let UnitBasis = tape[3];
		let ApplicableDate = tape[4];
		let FixedUntilDate = tape[5];
		let Category = tape[6];
		let Condition = tape[7];
		let ArithmeticOperator = tape[8];
		let Components = tape[9];
		return new IfcCostValue(Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.AppliedValue){
		}
		else{ args.push(EMPTY); }
		if(this.UnitBasis){
		args.push(REF)
		args.push(this.UnitBasis.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableDate){
		args.push(STRING)
		args.push(this.ApplicableDate)
		}
		else{ args.push(EMPTY); }
		if(this.FixedUntilDate){
		args.push(STRING)
		args.push(this.FixedUntilDate)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		if(this.Condition){
		args.push(STRING)
		args.push(this.Condition)
		}
		else{ args.push(EMPTY); }
		if(this.ArithmeticOperator){
		}
		else{ args.push(EMPTY); }
		if(this.Components){
		args.push(SET_BEGIN)
		this.Components.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCovering {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCoveringTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCoveringTypeEnum | null;
	static FromTape(tape: any[]): IfcCovering
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCovering(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCoveringType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCoveringTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCoveringTypeEnum ;
	static FromTape(tape: any[]): IfcCoveringType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCoveringType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCrewResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcCrewResourceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcCrewResourceTypeEnum | null;
	static FromTape(tape: any[]): IfcCrewResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		let PredefinedType = tape[10];
		return new IfcCrewResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCrewResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcCrewResourceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcCrewResourceTypeEnum ;
	static FromTape(tape: any[]): IfcCrewResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		let PredefinedType = tape[11];
		return new IfcCrewResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCsgPrimitive3D {
	constructor(Position: Handle<IfcAxis2Placement3D> )
	{
		this.Position = Position;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	static FromTape(tape: any[]): IfcCsgPrimitive3D
	{
		let Position = tape[0];
		return new IfcCsgPrimitive3D(Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcCsgSolid {
	constructor(TreeRootExpression: IfcCsgSelect )
	{
		this.TreeRootExpression = TreeRootExpression;
	}
	TreeRootExpression: IfcCsgSelect ;
	static FromTape(tape: any[]): IfcCsgSolid
	{
		let TreeRootExpression = tape[0];
		return new IfcCsgSolid(TreeRootExpression);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcCurrencyRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingMonetaryUnit: Handle<IfcMonetaryUnit> , RelatedMonetaryUnit: Handle<IfcMonetaryUnit> , ExchangeRate: IfcPositiveRatioMeasure , RateDateTime: IfcDateTime | null, RateSource: Handle<IfcLibraryInformation> | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingMonetaryUnit = RelatingMonetaryUnit;
		this.RelatedMonetaryUnit = RelatedMonetaryUnit;
		this.ExchangeRate = ExchangeRate;
		this.RateDateTime = RateDateTime;
		this.RateSource = RateSource;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingMonetaryUnit: Handle<IfcMonetaryUnit> ;
	RelatedMonetaryUnit: Handle<IfcMonetaryUnit> ;
	ExchangeRate: IfcPositiveRatioMeasure ;
	RateDateTime: IfcDateTime | null;
	RateSource: Handle<IfcLibraryInformation> | null;
	static FromTape(tape: any[]): IfcCurrencyRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingMonetaryUnit = tape[2];
		let RelatedMonetaryUnit = tape[3];
		let ExchangeRate = tape[4];
		let RateDateTime = tape[5];
		let RateSource = tape[6];
		return new IfcCurrencyRelationship(Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingMonetaryUnit.expressID)
		args.push(REF)
		args.push(this.RelatedMonetaryUnit.expressID)
		if(this.RateDateTime){
		args.push(STRING)
		args.push(this.RateDateTime)
		}
		else{ args.push(EMPTY); }
		if(this.RateSource){
		args.push(REF)
		args.push(this.RateSource.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCurtainWall {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcCurtainWallTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcCurtainWallTypeEnum | null;
	static FromTape(tape: any[]): IfcCurtainWall
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcCurtainWall(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCurtainWallType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcCurtainWallTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcCurtainWallTypeEnum ;
	static FromTape(tape: any[]): IfcCurtainWallType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcCurtainWallType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCurve {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcCurve
	{
		return new IfcCurve();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcCurveBoundedPlane {
	constructor(BasisSurface: Handle<IfcPlane> , OuterBoundary: Handle<IfcCurve> , InnerBoundaries: Handle<IfcCurve>[] )
	{
		this.BasisSurface = BasisSurface;
		this.OuterBoundary = OuterBoundary;
		this.InnerBoundaries = InnerBoundaries;
	}
	BasisSurface: Handle<IfcPlane> ;
	OuterBoundary: Handle<IfcCurve> ;
	InnerBoundaries: Handle<IfcCurve>[] ;
	static FromTape(tape: any[]): IfcCurveBoundedPlane
	{
		let BasisSurface = tape[0];
		let OuterBoundary = tape[1];
		let InnerBoundaries = tape[2];
		return new IfcCurveBoundedPlane(BasisSurface, OuterBoundary, InnerBoundaries);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisSurface.expressID)
		args.push(REF)
		args.push(this.OuterBoundary.expressID)
		args.push(SET_BEGIN)
		this.InnerBoundaries.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcCurveBoundedSurface {
	constructor(BasisSurface: Handle<IfcSurface> , Boundaries: Handle<IfcBoundaryCurve>[] , ImplicitOuter: IfcBoolean )
	{
		this.BasisSurface = BasisSurface;
		this.Boundaries = Boundaries;
		this.ImplicitOuter = ImplicitOuter;
	}
	BasisSurface: Handle<IfcSurface> ;
	Boundaries: Handle<IfcBoundaryCurve>[] ;
	ImplicitOuter: IfcBoolean ;
	static FromTape(tape: any[]): IfcCurveBoundedSurface
	{
		let BasisSurface = tape[0];
		let Boundaries = tape[1];
		let ImplicitOuter = tape[2];
		return new IfcCurveBoundedSurface(BasisSurface, Boundaries, ImplicitOuter);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisSurface.expressID)
		args.push(SET_BEGIN)
		this.Boundaries.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcCurveSegment2D {
	constructor(StartPoint: Handle<IfcCartesianPoint> , StartDirection: IfcPlaneAngleMeasure , SegmentLength: IfcPositiveLengthMeasure )
	{
		this.StartPoint = StartPoint;
		this.StartDirection = StartDirection;
		this.SegmentLength = SegmentLength;
	}
	StartPoint: Handle<IfcCartesianPoint> ;
	StartDirection: IfcPlaneAngleMeasure ;
	SegmentLength: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCurveSegment2D
	{
		let StartPoint = tape[0];
		let StartDirection = tape[1];
		let SegmentLength = tape[2];
		return new IfcCurveSegment2D(StartPoint, StartDirection, SegmentLength);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.StartPoint.expressID)
		args.push(REAL)
		args.push(this.StartDirection)
		return args;
	}
};
export class IfcCurveStyle {
	constructor(Name: IfcLabel | null, CurveFont: IfcCurveFontOrScaledCurveFontSelect | null, CurveWidth: IfcSizeSelect | null, CurveColour: IfcColour | null, ModelOrDraughting: IfcBoolean | null)
	{
		this.Name = Name;
		this.CurveFont = CurveFont;
		this.CurveWidth = CurveWidth;
		this.CurveColour = CurveColour;
		this.ModelOrDraughting = ModelOrDraughting;
	}
	Name: IfcLabel | null;
	CurveFont: IfcCurveFontOrScaledCurveFontSelect | null;
	CurveWidth: IfcSizeSelect | null;
	CurveColour: IfcColour | null;
	ModelOrDraughting: IfcBoolean | null;
	static FromTape(tape: any[]): IfcCurveStyle
	{
		let Name = tape[0];
		let CurveFont = tape[1];
		let CurveWidth = tape[2];
		let CurveColour = tape[3];
		let ModelOrDraughting = tape[4];
		return new IfcCurveStyle(Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.CurveFont){
		}
		else{ args.push(EMPTY); }
		if(this.CurveWidth){
		}
		else{ args.push(EMPTY); }
		if(this.CurveColour){
		}
		else{ args.push(EMPTY); }
		if(this.ModelOrDraughting){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCurveStyleFont {
	constructor(Name: IfcLabel | null, PatternList: Handle<IfcCurveStyleFontPattern>[] )
	{
		this.Name = Name;
		this.PatternList = PatternList;
	}
	Name: IfcLabel | null;
	PatternList: Handle<IfcCurveStyleFontPattern>[] ;
	static FromTape(tape: any[]): IfcCurveStyleFont
	{
		let Name = tape[0];
		let PatternList = tape[1];
		return new IfcCurveStyleFont(Name, PatternList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.PatternList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcCurveStyleFontAndScaling {
	constructor(Name: IfcLabel | null, CurveFont: IfcCurveStyleFontSelect , CurveFontScaling: IfcPositiveRatioMeasure )
	{
		this.Name = Name;
		this.CurveFont = CurveFont;
		this.CurveFontScaling = CurveFontScaling;
	}
	Name: IfcLabel | null;
	CurveFont: IfcCurveStyleFontSelect ;
	CurveFontScaling: IfcPositiveRatioMeasure ;
	static FromTape(tape: any[]): IfcCurveStyleFontAndScaling
	{
		let Name = tape[0];
		let CurveFont = tape[1];
		let CurveFontScaling = tape[2];
		return new IfcCurveStyleFontAndScaling(Name, CurveFont, CurveFontScaling);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcCurveStyleFontPattern {
	constructor(VisibleSegmentLength: IfcLengthMeasure , InvisibleSegmentLength: IfcPositiveLengthMeasure )
	{
		this.VisibleSegmentLength = VisibleSegmentLength;
		this.InvisibleSegmentLength = InvisibleSegmentLength;
	}
	VisibleSegmentLength: IfcLengthMeasure ;
	InvisibleSegmentLength: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCurveStyleFontPattern
	{
		let VisibleSegmentLength = tape[0];
		let InvisibleSegmentLength = tape[1];
		return new IfcCurveStyleFontPattern(VisibleSegmentLength, InvisibleSegmentLength);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.VisibleSegmentLength)
		return args;
	}
};
export class IfcCylindricalSurface {
	constructor(Position: Handle<IfcAxis2Placement3D> , Radius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.Radius = Radius;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	Radius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcCylindricalSurface
	{
		let Position = tape[0];
		let Radius = tape[1];
		return new IfcCylindricalSurface(Position, Radius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcDamper {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcDamperTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcDamperTypeEnum | null;
	static FromTape(tape: any[]): IfcDamper
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcDamper(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDamperType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDamperTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDamperTypeEnum ;
	static FromTape(tape: any[]): IfcDamperType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcDamperType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDeepFoundation {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcDeepFoundation
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcDeepFoundation(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDeepFoundationType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDeepFoundationType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcDeepFoundationType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDerivedProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, ParentProfile: Handle<IfcProfileDef> , Operator: Handle<IfcCartesianTransformationOperator2D> , Label: IfcLabel | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.ParentProfile = ParentProfile;
		this.Operator = Operator;
		this.Label = Label;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	ParentProfile: Handle<IfcProfileDef> ;
	Operator: Handle<IfcCartesianTransformationOperator2D> ;
	Label: IfcLabel | null;
	static FromTape(tape: any[]): IfcDerivedProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let ParentProfile = tape[2];
		let Operator = tape[3];
		let Label = tape[4];
		return new IfcDerivedProfileDef(ProfileType, ProfileName, ParentProfile, Operator, Label);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ParentProfile.expressID)
		args.push(REF)
		args.push(this.Operator.expressID)
		if(this.Label){
		args.push(STRING)
		args.push(this.Label)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDerivedUnit {
	constructor(Elements: Handle<IfcDerivedUnitElement>[] , UnitType: IfcDerivedUnitEnum , UserDefinedType: IfcLabel | null)
	{
		this.Elements = Elements;
		this.UnitType = UnitType;
		this.UserDefinedType = UserDefinedType;
	}
	Elements: Handle<IfcDerivedUnitElement>[] ;
	UnitType: IfcDerivedUnitEnum ;
	UserDefinedType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDerivedUnit
	{
		let Elements = tape[0];
		let UnitType = tape[1];
		let UserDefinedType = tape[2];
		return new IfcDerivedUnit(Elements, UnitType, UserDefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Elements.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.UserDefinedType){
		args.push(STRING)
		args.push(this.UserDefinedType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDerivedUnitElement {
	constructor(Unit: Handle<IfcNamedUnit> , Exponent: Handle<number> )
	{
		this.Unit = Unit;
		this.Exponent = Exponent;
	}
	Unit: Handle<IfcNamedUnit> ;
	Exponent: Handle<number> ;
	static FromTape(tape: any[]): IfcDerivedUnitElement
	{
		let Unit = tape[0];
		let Exponent = tape[1];
		return new IfcDerivedUnitElement(Unit, Exponent);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Unit.expressID)
		args.push(REF)
		args.push(this.Exponent.expressID)
		return args;
	}
};
export class IfcDimensionalExponents {
	constructor(LengthExponent: Handle<number> , MassExponent: Handle<number> , TimeExponent: Handle<number> , ElectricCurrentExponent: Handle<number> , ThermodynamicTemperatureExponent: Handle<number> , AmountOfSubstanceExponent: Handle<number> , LuminousIntensityExponent: Handle<number> )
	{
		this.LengthExponent = LengthExponent;
		this.MassExponent = MassExponent;
		this.TimeExponent = TimeExponent;
		this.ElectricCurrentExponent = ElectricCurrentExponent;
		this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
		this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
		this.LuminousIntensityExponent = LuminousIntensityExponent;
	}
	LengthExponent: Handle<number> ;
	MassExponent: Handle<number> ;
	TimeExponent: Handle<number> ;
	ElectricCurrentExponent: Handle<number> ;
	ThermodynamicTemperatureExponent: Handle<number> ;
	AmountOfSubstanceExponent: Handle<number> ;
	LuminousIntensityExponent: Handle<number> ;
	static FromTape(tape: any[]): IfcDimensionalExponents
	{
		let LengthExponent = tape[0];
		let MassExponent = tape[1];
		let TimeExponent = tape[2];
		let ElectricCurrentExponent = tape[3];
		let ThermodynamicTemperatureExponent = tape[4];
		let AmountOfSubstanceExponent = tape[5];
		let LuminousIntensityExponent = tape[6];
		return new IfcDimensionalExponents(LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.LengthExponent.expressID)
		args.push(REF)
		args.push(this.MassExponent.expressID)
		args.push(REF)
		args.push(this.TimeExponent.expressID)
		args.push(REF)
		args.push(this.ElectricCurrentExponent.expressID)
		args.push(REF)
		args.push(this.ThermodynamicTemperatureExponent.expressID)
		args.push(REF)
		args.push(this.AmountOfSubstanceExponent.expressID)
		args.push(REF)
		args.push(this.LuminousIntensityExponent.expressID)
		return args;
	}
};
export class IfcDirection {
	constructor(DirectionRatios: IfcReal[] )
	{
		this.DirectionRatios = DirectionRatios;
	}
	DirectionRatios: IfcReal[] ;
	static FromTape(tape: any[]): IfcDirection
	{
		let DirectionRatios = tape[0];
		return new IfcDirection(DirectionRatios);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(...this.DirectionRatios)
		return args;
	}
};
export class IfcDiscreteAccessory {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcDiscreteAccessoryTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcDiscreteAccessoryTypeEnum | null;
	static FromTape(tape: any[]): IfcDiscreteAccessory
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcDiscreteAccessory(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDiscreteAccessoryType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDiscreteAccessoryTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDiscreteAccessoryTypeEnum ;
	static FromTape(tape: any[]): IfcDiscreteAccessoryType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcDiscreteAccessoryType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistanceExpression {
	constructor(DistanceAlong: IfcLengthMeasure , OffsetLateral: IfcLengthMeasure | null, OffsetVertical: IfcLengthMeasure | null, OffsetLongitudinal: IfcLengthMeasure | null, AlongHorizontal: IfcBoolean | null)
	{
		this.DistanceAlong = DistanceAlong;
		this.OffsetLateral = OffsetLateral;
		this.OffsetVertical = OffsetVertical;
		this.OffsetLongitudinal = OffsetLongitudinal;
		this.AlongHorizontal = AlongHorizontal;
	}
	DistanceAlong: IfcLengthMeasure ;
	OffsetLateral: IfcLengthMeasure | null;
	OffsetVertical: IfcLengthMeasure | null;
	OffsetLongitudinal: IfcLengthMeasure | null;
	AlongHorizontal: IfcBoolean | null;
	static FromTape(tape: any[]): IfcDistanceExpression
	{
		let DistanceAlong = tape[0];
		let OffsetLateral = tape[1];
		let OffsetVertical = tape[2];
		let OffsetLongitudinal = tape[3];
		let AlongHorizontal = tape[4];
		return new IfcDistanceExpression(DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.DistanceAlong)
		if(this.OffsetLateral){
		args.push(REAL)
		args.push(this.OffsetLateral)
		}
		else{ args.push(EMPTY); }
		if(this.OffsetVertical){
		args.push(REAL)
		args.push(this.OffsetVertical)
		}
		else{ args.push(EMPTY); }
		if(this.OffsetLongitudinal){
		args.push(REAL)
		args.push(this.OffsetLongitudinal)
		}
		else{ args.push(EMPTY); }
		if(this.AlongHorizontal){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionChamberElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcDistributionChamberElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcDistributionChamberElementTypeEnum | null;
	static FromTape(tape: any[]): IfcDistributionChamberElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcDistributionChamberElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionChamberElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDistributionChamberElementTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDistributionChamberElementTypeEnum ;
	static FromTape(tape: any[]): IfcDistributionChamberElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcDistributionChamberElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionCircuit {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, LongName: IfcLabel | null, PredefinedType: IfcDistributionSystemEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.LongName = LongName;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	LongName: IfcLabel | null;
	PredefinedType: IfcDistributionSystemEnum | null;
	static FromTape(tape: any[]): IfcDistributionCircuit
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let LongName = tape[5];
		let PredefinedType = tape[6];
		return new IfcDistributionCircuit(GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionControlElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcDistributionControlElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcDistributionControlElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionControlElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDistributionControlElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcDistributionControlElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcDistributionElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcDistributionElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDistributionElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcDistributionElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionFlowElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcDistributionFlowElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcDistributionFlowElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionFlowElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDistributionFlowElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcDistributionFlowElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionPort {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, FlowDirection: IfcFlowDirectionEnum | null, PredefinedType: IfcDistributionPortTypeEnum | null, SystemType: IfcDistributionSystemEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.FlowDirection = FlowDirection;
		this.PredefinedType = PredefinedType;
		this.SystemType = SystemType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	FlowDirection: IfcFlowDirectionEnum | null;
	PredefinedType: IfcDistributionPortTypeEnum | null;
	SystemType: IfcDistributionSystemEnum | null;
	static FromTape(tape: any[]): IfcDistributionPort
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let FlowDirection = tape[7];
		let PredefinedType = tape[8];
		let SystemType = tape[9];
		return new IfcDistributionPort(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.FlowDirection){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.SystemType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDistributionSystem {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, LongName: IfcLabel | null, PredefinedType: IfcDistributionSystemEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.LongName = LongName;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	LongName: IfcLabel | null;
	PredefinedType: IfcDistributionSystemEnum | null;
	static FromTape(tape: any[]): IfcDistributionSystem
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let LongName = tape[5];
		let PredefinedType = tape[6];
		return new IfcDistributionSystem(GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDocumentInformation {
	constructor(Identification: IfcIdentifier , Name: IfcLabel , Description: IfcText | null, Location: IfcURIReference | null, Purpose: IfcText | null, IntendedUse: IfcText | null, Scope: IfcText | null, Revision: IfcLabel | null, DocumentOwner: IfcActorSelect | null, Editors: IfcActorSelect[] | null, CreationTime: IfcDateTime | null, LastRevisionTime: IfcDateTime | null, ElectronicFormat: IfcIdentifier | null, ValidFrom: IfcDate | null, ValidUntil: IfcDate | null, Confidentiality: IfcDocumentConfidentialityEnum | null, Status: IfcDocumentStatusEnum | null)
	{
		this.Identification = Identification;
		this.Name = Name;
		this.Description = Description;
		this.Location = Location;
		this.Purpose = Purpose;
		this.IntendedUse = IntendedUse;
		this.Scope = Scope;
		this.Revision = Revision;
		this.DocumentOwner = DocumentOwner;
		this.Editors = Editors;
		this.CreationTime = CreationTime;
		this.LastRevisionTime = LastRevisionTime;
		this.ElectronicFormat = ElectronicFormat;
		this.ValidFrom = ValidFrom;
		this.ValidUntil = ValidUntil;
		this.Confidentiality = Confidentiality;
		this.Status = Status;
	}
	Identification: IfcIdentifier ;
	Name: IfcLabel ;
	Description: IfcText | null;
	Location: IfcURIReference | null;
	Purpose: IfcText | null;
	IntendedUse: IfcText | null;
	Scope: IfcText | null;
	Revision: IfcLabel | null;
	DocumentOwner: IfcActorSelect | null;
	Editors: IfcActorSelect[] | null;
	CreationTime: IfcDateTime | null;
	LastRevisionTime: IfcDateTime | null;
	ElectronicFormat: IfcIdentifier | null;
	ValidFrom: IfcDate | null;
	ValidUntil: IfcDate | null;
	Confidentiality: IfcDocumentConfidentialityEnum | null;
	Status: IfcDocumentStatusEnum | null;
	static FromTape(tape: any[]): IfcDocumentInformation
	{
		let Identification = tape[0];
		let Name = tape[1];
		let Description = tape[2];
		let Location = tape[3];
		let Purpose = tape[4];
		let IntendedUse = tape[5];
		let Scope = tape[6];
		let Revision = tape[7];
		let DocumentOwner = tape[8];
		let Editors = tape[9];
		let CreationTime = tape[10];
		let LastRevisionTime = tape[11];
		let ElectronicFormat = tape[12];
		let ValidFrom = tape[13];
		let ValidUntil = tape[14];
		let Confidentiality = tape[15];
		let Status = tape[16];
		return new IfcDocumentInformation(Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Identification)
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Purpose){
		args.push(STRING)
		args.push(this.Purpose)
		}
		else{ args.push(EMPTY); }
		if(this.IntendedUse){
		args.push(STRING)
		args.push(this.IntendedUse)
		}
		else{ args.push(EMPTY); }
		if(this.Scope){
		args.push(STRING)
		args.push(this.Scope)
		}
		else{ args.push(EMPTY); }
		if(this.Revision){
		args.push(STRING)
		args.push(this.Revision)
		}
		else{ args.push(EMPTY); }
		if(this.DocumentOwner){
		}
		else{ args.push(EMPTY); }
		if(this.Editors){
		}
		else{ args.push(EMPTY); }
		if(this.CreationTime){
		args.push(STRING)
		args.push(this.CreationTime)
		}
		else{ args.push(EMPTY); }
		if(this.LastRevisionTime){
		args.push(STRING)
		args.push(this.LastRevisionTime)
		}
		else{ args.push(EMPTY); }
		if(this.ElectronicFormat){
		args.push(STRING)
		args.push(this.ElectronicFormat)
		}
		else{ args.push(EMPTY); }
		if(this.ValidFrom){
		args.push(STRING)
		args.push(this.ValidFrom)
		}
		else{ args.push(EMPTY); }
		if(this.ValidUntil){
		args.push(STRING)
		args.push(this.ValidUntil)
		}
		else{ args.push(EMPTY); }
		if(this.Confidentiality){
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDocumentInformationRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingDocument: Handle<IfcDocumentInformation> , RelatedDocuments: Handle<IfcDocumentInformation>[] , RelationshipType: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingDocument = RelatingDocument;
		this.RelatedDocuments = RelatedDocuments;
		this.RelationshipType = RelationshipType;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingDocument: Handle<IfcDocumentInformation> ;
	RelatedDocuments: Handle<IfcDocumentInformation>[] ;
	RelationshipType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDocumentInformationRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingDocument = tape[2];
		let RelatedDocuments = tape[3];
		let RelationshipType = tape[4];
		return new IfcDocumentInformationRelationship(Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingDocument.expressID)
		args.push(SET_BEGIN)
		this.RelatedDocuments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelationshipType){
		args.push(STRING)
		args.push(this.RelationshipType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDocumentReference {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null, Description: IfcText | null, ReferencedDocument: Handle<IfcDocumentInformation> | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
		this.Description = Description;
		this.ReferencedDocument = ReferencedDocument;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ReferencedDocument: Handle<IfcDocumentInformation> | null;
	static FromTape(tape: any[]): IfcDocumentReference
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ReferencedDocument = tape[4];
		return new IfcDocumentReference(Location, Identification, Name, Description, ReferencedDocument);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ReferencedDocument){
		args.push(REF)
		args.push(this.ReferencedDocument.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDoor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, OverallHeight: IfcPositiveLengthMeasure | null, OverallWidth: IfcPositiveLengthMeasure | null, PredefinedType: IfcDoorTypeEnum | null, OperationType: IfcDoorTypeOperationEnum | null, UserDefinedOperationType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.OverallHeight = OverallHeight;
		this.OverallWidth = OverallWidth;
		this.PredefinedType = PredefinedType;
		this.OperationType = OperationType;
		this.UserDefinedOperationType = UserDefinedOperationType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	OverallHeight: IfcPositiveLengthMeasure | null;
	OverallWidth: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcDoorTypeEnum | null;
	OperationType: IfcDoorTypeOperationEnum | null;
	UserDefinedOperationType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDoor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let OverallHeight = tape[8];
		let OverallWidth = tape[9];
		let PredefinedType = tape[10];
		let OperationType = tape[11];
		let UserDefinedOperationType = tape[12];
		return new IfcDoor(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.OverallHeight){
		}
		else{ args.push(EMPTY); }
		if(this.OverallWidth){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.OperationType){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedOperationType){
		args.push(STRING)
		args.push(this.UserDefinedOperationType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDoorLiningProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, LiningDepth: IfcPositiveLengthMeasure | null, LiningThickness: IfcNonNegativeLengthMeasure | null, ThresholdDepth: IfcPositiveLengthMeasure | null, ThresholdThickness: IfcNonNegativeLengthMeasure | null, TransomThickness: IfcNonNegativeLengthMeasure | null, TransomOffset: IfcLengthMeasure | null, LiningOffset: IfcLengthMeasure | null, ThresholdOffset: IfcLengthMeasure | null, CasingThickness: IfcPositiveLengthMeasure | null, CasingDepth: IfcPositiveLengthMeasure | null, ShapeAspectStyle: Handle<IfcShapeAspect> | null, LiningToPanelOffsetX: IfcLengthMeasure | null, LiningToPanelOffsetY: IfcLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.LiningDepth = LiningDepth;
		this.LiningThickness = LiningThickness;
		this.ThresholdDepth = ThresholdDepth;
		this.ThresholdThickness = ThresholdThickness;
		this.TransomThickness = TransomThickness;
		this.TransomOffset = TransomOffset;
		this.LiningOffset = LiningOffset;
		this.ThresholdOffset = ThresholdOffset;
		this.CasingThickness = CasingThickness;
		this.CasingDepth = CasingDepth;
		this.ShapeAspectStyle = ShapeAspectStyle;
		this.LiningToPanelOffsetX = LiningToPanelOffsetX;
		this.LiningToPanelOffsetY = LiningToPanelOffsetY;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	LiningDepth: IfcPositiveLengthMeasure | null;
	LiningThickness: IfcNonNegativeLengthMeasure | null;
	ThresholdDepth: IfcPositiveLengthMeasure | null;
	ThresholdThickness: IfcNonNegativeLengthMeasure | null;
	TransomThickness: IfcNonNegativeLengthMeasure | null;
	TransomOffset: IfcLengthMeasure | null;
	LiningOffset: IfcLengthMeasure | null;
	ThresholdOffset: IfcLengthMeasure | null;
	CasingThickness: IfcPositiveLengthMeasure | null;
	CasingDepth: IfcPositiveLengthMeasure | null;
	ShapeAspectStyle: Handle<IfcShapeAspect> | null;
	LiningToPanelOffsetX: IfcLengthMeasure | null;
	LiningToPanelOffsetY: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcDoorLiningProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let LiningDepth = tape[4];
		let LiningThickness = tape[5];
		let ThresholdDepth = tape[6];
		let ThresholdThickness = tape[7];
		let TransomThickness = tape[8];
		let TransomOffset = tape[9];
		let LiningOffset = tape[10];
		let ThresholdOffset = tape[11];
		let CasingThickness = tape[12];
		let CasingDepth = tape[13];
		let ShapeAspectStyle = tape[14];
		let LiningToPanelOffsetX = tape[15];
		let LiningToPanelOffsetY = tape[16];
		return new IfcDoorLiningProperties(GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.LiningDepth){
		}
		else{ args.push(EMPTY); }
		if(this.LiningThickness){
		}
		else{ args.push(EMPTY); }
		if(this.ThresholdDepth){
		}
		else{ args.push(EMPTY); }
		if(this.ThresholdThickness){
		}
		else{ args.push(EMPTY); }
		if(this.TransomThickness){
		}
		else{ args.push(EMPTY); }
		if(this.TransomOffset){
		args.push(REAL)
		args.push(this.TransomOffset)
		}
		else{ args.push(EMPTY); }
		if(this.LiningOffset){
		args.push(REAL)
		args.push(this.LiningOffset)
		}
		else{ args.push(EMPTY); }
		if(this.ThresholdOffset){
		args.push(REAL)
		args.push(this.ThresholdOffset)
		}
		else{ args.push(EMPTY); }
		if(this.CasingThickness){
		}
		else{ args.push(EMPTY); }
		if(this.CasingDepth){
		}
		else{ args.push(EMPTY); }
		if(this.ShapeAspectStyle){
		args.push(REF)
		args.push(this.ShapeAspectStyle.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LiningToPanelOffsetX){
		args.push(REAL)
		args.push(this.LiningToPanelOffsetX)
		}
		else{ args.push(EMPTY); }
		if(this.LiningToPanelOffsetY){
		args.push(REAL)
		args.push(this.LiningToPanelOffsetY)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDoorPanelProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, PanelDepth: IfcPositiveLengthMeasure | null, PanelOperation: IfcDoorPanelOperationEnum , PanelWidth: IfcNormalisedRatioMeasure | null, PanelPosition: IfcDoorPanelPositionEnum , ShapeAspectStyle: Handle<IfcShapeAspect> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.PanelDepth = PanelDepth;
		this.PanelOperation = PanelOperation;
		this.PanelWidth = PanelWidth;
		this.PanelPosition = PanelPosition;
		this.ShapeAspectStyle = ShapeAspectStyle;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	PanelDepth: IfcPositiveLengthMeasure | null;
	PanelOperation: IfcDoorPanelOperationEnum ;
	PanelWidth: IfcNormalisedRatioMeasure | null;
	PanelPosition: IfcDoorPanelPositionEnum ;
	ShapeAspectStyle: Handle<IfcShapeAspect> | null;
	static FromTape(tape: any[]): IfcDoorPanelProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let PanelDepth = tape[4];
		let PanelOperation = tape[5];
		let PanelWidth = tape[6];
		let PanelPosition = tape[7];
		let ShapeAspectStyle = tape[8];
		return new IfcDoorPanelProperties(GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.PanelDepth){
		}
		else{ args.push(EMPTY); }
		if(this.PanelWidth){
		}
		else{ args.push(EMPTY); }
		if(this.ShapeAspectStyle){
		args.push(REF)
		args.push(this.ShapeAspectStyle.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDoorStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, OverallHeight: IfcPositiveLengthMeasure | null, OverallWidth: IfcPositiveLengthMeasure | null, PredefinedType: IfcDoorTypeEnum | null, OperationType: IfcDoorTypeOperationEnum | null, UserDefinedOperationType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.OverallHeight = OverallHeight;
		this.OverallWidth = OverallWidth;
		this.PredefinedType = PredefinedType;
		this.OperationType = OperationType;
		this.UserDefinedOperationType = UserDefinedOperationType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	OverallHeight: IfcPositiveLengthMeasure | null;
	OverallWidth: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcDoorTypeEnum | null;
	OperationType: IfcDoorTypeOperationEnum | null;
	UserDefinedOperationType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDoorStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let OverallHeight = tape[8];
		let OverallWidth = tape[9];
		let PredefinedType = tape[10];
		let OperationType = tape[11];
		let UserDefinedOperationType = tape[12];
		return new IfcDoorStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.OverallHeight){
		}
		else{ args.push(EMPTY); }
		if(this.OverallWidth){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.OperationType){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedOperationType){
		args.push(STRING)
		args.push(this.UserDefinedOperationType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDoorStyle {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, OperationType: IfcDoorStyleOperationEnum , ConstructionType: IfcDoorStyleConstructionEnum , ParameterTakesPrecedence: IfcBoolean , Sizeable: IfcBoolean )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.OperationType = OperationType;
		this.ConstructionType = ConstructionType;
		this.ParameterTakesPrecedence = ParameterTakesPrecedence;
		this.Sizeable = Sizeable;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	OperationType: IfcDoorStyleOperationEnum ;
	ConstructionType: IfcDoorStyleConstructionEnum ;
	ParameterTakesPrecedence: IfcBoolean ;
	Sizeable: IfcBoolean ;
	static FromTape(tape: any[]): IfcDoorStyle
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let OperationType = tape[8];
		let ConstructionType = tape[9];
		let ParameterTakesPrecedence = tape[10];
		let Sizeable = tape[11];
		return new IfcDoorStyle(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDoorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDoorTypeEnum , OperationType: IfcDoorTypeOperationEnum , ParameterTakesPrecedence: IfcBoolean | null, UserDefinedOperationType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.OperationType = OperationType;
		this.ParameterTakesPrecedence = ParameterTakesPrecedence;
		this.UserDefinedOperationType = UserDefinedOperationType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDoorTypeEnum ;
	OperationType: IfcDoorTypeOperationEnum ;
	ParameterTakesPrecedence: IfcBoolean | null;
	UserDefinedOperationType: IfcLabel | null;
	static FromTape(tape: any[]): IfcDoorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let OperationType = tape[10];
		let ParameterTakesPrecedence = tape[11];
		let UserDefinedOperationType = tape[12];
		return new IfcDoorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.ParameterTakesPrecedence){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedOperationType){
		args.push(STRING)
		args.push(this.UserDefinedOperationType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDraughtingPreDefinedColour {
	constructor(Name: IfcLabel )
	{
		this.Name = Name;
	}
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcDraughtingPreDefinedColour
	{
		let Name = tape[0];
		return new IfcDraughtingPreDefinedColour(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcDraughtingPreDefinedCurveFont {
	constructor(Name: IfcLabel )
	{
		this.Name = Name;
	}
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcDraughtingPreDefinedCurveFont
	{
		let Name = tape[0];
		return new IfcDraughtingPreDefinedCurveFont(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcDuctFitting {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcDuctFittingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcDuctFittingTypeEnum | null;
	static FromTape(tape: any[]): IfcDuctFitting
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcDuctFitting(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDuctFittingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDuctFittingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDuctFittingTypeEnum ;
	static FromTape(tape: any[]): IfcDuctFittingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcDuctFittingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDuctSegment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcDuctSegmentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcDuctSegmentTypeEnum | null;
	static FromTape(tape: any[]): IfcDuctSegment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcDuctSegment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDuctSegmentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDuctSegmentTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDuctSegmentTypeEnum ;
	static FromTape(tape: any[]): IfcDuctSegmentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcDuctSegmentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDuctSilencer {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcDuctSilencerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcDuctSilencerTypeEnum | null;
	static FromTape(tape: any[]): IfcDuctSilencer
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcDuctSilencer(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcDuctSilencerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcDuctSilencerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcDuctSilencerTypeEnum ;
	static FromTape(tape: any[]): IfcDuctSilencerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcDuctSilencerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEdge {
	constructor(EdgeStart: Handle<IfcVertex> , EdgeEnd: Handle<IfcVertex> )
	{
		this.EdgeStart = EdgeStart;
		this.EdgeEnd = EdgeEnd;
	}
	EdgeStart: Handle<IfcVertex> ;
	EdgeEnd: Handle<IfcVertex> ;
	static FromTape(tape: any[]): IfcEdge
	{
		let EdgeStart = tape[0];
		let EdgeEnd = tape[1];
		return new IfcEdge(EdgeStart, EdgeEnd);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.EdgeStart.expressID)
		args.push(REF)
		args.push(this.EdgeEnd.expressID)
		return args;
	}
};
export class IfcEdgeCurve {
	constructor(EdgeStart: Handle<IfcVertex> , EdgeEnd: Handle<IfcVertex> , EdgeGeometry: Handle<IfcCurve> , SameSense: IfcBoolean )
	{
		this.EdgeStart = EdgeStart;
		this.EdgeEnd = EdgeEnd;
		this.EdgeGeometry = EdgeGeometry;
		this.SameSense = SameSense;
	}
	EdgeStart: Handle<IfcVertex> ;
	EdgeEnd: Handle<IfcVertex> ;
	EdgeGeometry: Handle<IfcCurve> ;
	SameSense: IfcBoolean ;
	static FromTape(tape: any[]): IfcEdgeCurve
	{
		let EdgeStart = tape[0];
		let EdgeEnd = tape[1];
		let EdgeGeometry = tape[2];
		let SameSense = tape[3];
		return new IfcEdgeCurve(EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.EdgeStart.expressID)
		args.push(REF)
		args.push(this.EdgeEnd.expressID)
		args.push(REF)
		args.push(this.EdgeGeometry.expressID)
		return args;
	}
};
export class IfcEdgeLoop {
	constructor(EdgeList: Handle<IfcOrientedEdge>[] )
	{
		this.EdgeList = EdgeList;
	}
	EdgeList: Handle<IfcOrientedEdge>[] ;
	static FromTape(tape: any[]): IfcEdgeLoop
	{
		let EdgeList = tape[0];
		return new IfcEdgeLoop(EdgeList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.EdgeList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcElectricAppliance {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcElectricApplianceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcElectricApplianceTypeEnum | null;
	static FromTape(tape: any[]): IfcElectricAppliance
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcElectricAppliance(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricApplianceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElectricApplianceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElectricApplianceTypeEnum ;
	static FromTape(tape: any[]): IfcElectricApplianceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElectricApplianceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricDistributionBoard {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcElectricDistributionBoardTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcElectricDistributionBoardTypeEnum | null;
	static FromTape(tape: any[]): IfcElectricDistributionBoard
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcElectricDistributionBoard(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricDistributionBoardType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElectricDistributionBoardTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElectricDistributionBoardTypeEnum ;
	static FromTape(tape: any[]): IfcElectricDistributionBoardType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElectricDistributionBoardType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricFlowStorageDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcElectricFlowStorageDeviceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcElectricFlowStorageDeviceTypeEnum | null;
	static FromTape(tape: any[]): IfcElectricFlowStorageDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcElectricFlowStorageDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricFlowStorageDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElectricFlowStorageDeviceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElectricFlowStorageDeviceTypeEnum ;
	static FromTape(tape: any[]): IfcElectricFlowStorageDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElectricFlowStorageDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricGenerator {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcElectricGeneratorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcElectricGeneratorTypeEnum | null;
	static FromTape(tape: any[]): IfcElectricGenerator
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcElectricGenerator(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricGeneratorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElectricGeneratorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElectricGeneratorTypeEnum ;
	static FromTape(tape: any[]): IfcElectricGeneratorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElectricGeneratorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricMotor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcElectricMotorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcElectricMotorTypeEnum | null;
	static FromTape(tape: any[]): IfcElectricMotor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcElectricMotor(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricMotorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElectricMotorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElectricMotorTypeEnum ;
	static FromTape(tape: any[]): IfcElectricMotorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElectricMotorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricTimeControl {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcElectricTimeControlTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcElectricTimeControlTypeEnum | null;
	static FromTape(tape: any[]): IfcElectricTimeControl
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcElectricTimeControl(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElectricTimeControlType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElectricTimeControlTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElectricTimeControlTypeEnum ;
	static FromTape(tape: any[]): IfcElectricTimeControlType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElectricTimeControlType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElementAssembly {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, AssemblyPlace: IfcAssemblyPlaceEnum | null, PredefinedType: IfcElementAssemblyTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.AssemblyPlace = AssemblyPlace;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	AssemblyPlace: IfcAssemblyPlaceEnum | null;
	PredefinedType: IfcElementAssemblyTypeEnum | null;
	static FromTape(tape: any[]): IfcElementAssembly
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let AssemblyPlace = tape[8];
		let PredefinedType = tape[9];
		return new IfcElementAssembly(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.AssemblyPlace){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElementAssemblyType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcElementAssemblyTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcElementAssemblyTypeEnum ;
	static FromTape(tape: any[]): IfcElementAssemblyType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcElementAssemblyType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElementComponent {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcElementComponent
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcElementComponent(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElementComponentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcElementComponentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcElementComponentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElementQuantity {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, MethodOfMeasurement: IfcLabel | null, Quantities: Handle<IfcPhysicalQuantity>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.MethodOfMeasurement = MethodOfMeasurement;
		this.Quantities = Quantities;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	MethodOfMeasurement: IfcLabel | null;
	Quantities: Handle<IfcPhysicalQuantity>[] ;
	static FromTape(tape: any[]): IfcElementQuantity
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let MethodOfMeasurement = tape[4];
		let Quantities = tape[5];
		return new IfcElementQuantity(GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.MethodOfMeasurement){
		args.push(STRING)
		args.push(this.MethodOfMeasurement)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Quantities.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcElementarySurface {
	constructor(Position: Handle<IfcAxis2Placement3D> )
	{
		this.Position = Position;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	static FromTape(tape: any[]): IfcElementarySurface
	{
		let Position = tape[0];
		return new IfcElementarySurface(Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcEllipse {
	constructor(Position: IfcAxis2Placement , SemiAxis1: IfcPositiveLengthMeasure , SemiAxis2: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.SemiAxis1 = SemiAxis1;
		this.SemiAxis2 = SemiAxis2;
	}
	Position: IfcAxis2Placement ;
	SemiAxis1: IfcPositiveLengthMeasure ;
	SemiAxis2: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcEllipse
	{
		let Position = tape[0];
		let SemiAxis1 = tape[1];
		let SemiAxis2 = tape[2];
		return new IfcEllipse(Position, SemiAxis1, SemiAxis2);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcEllipseProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, SemiAxis1: IfcPositiveLengthMeasure , SemiAxis2: IfcPositiveLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.SemiAxis1 = SemiAxis1;
		this.SemiAxis2 = SemiAxis2;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	SemiAxis1: IfcPositiveLengthMeasure ;
	SemiAxis2: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcEllipseProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let SemiAxis1 = tape[3];
		let SemiAxis2 = tape[4];
		return new IfcEllipseProfileDef(ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEnergyConversionDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcEnergyConversionDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcEnergyConversionDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEnergyConversionDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcEnergyConversionDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcEnergyConversionDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEngine {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcEngineTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcEngineTypeEnum | null;
	static FromTape(tape: any[]): IfcEngine
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcEngine(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEngineType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcEngineTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcEngineTypeEnum ;
	static FromTape(tape: any[]): IfcEngineType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcEngineType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEvaporativeCooler {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcEvaporativeCoolerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcEvaporativeCoolerTypeEnum | null;
	static FromTape(tape: any[]): IfcEvaporativeCooler
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcEvaporativeCooler(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEvaporativeCoolerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcEvaporativeCoolerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcEvaporativeCoolerTypeEnum ;
	static FromTape(tape: any[]): IfcEvaporativeCoolerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcEvaporativeCoolerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEvaporator {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcEvaporatorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcEvaporatorTypeEnum | null;
	static FromTape(tape: any[]): IfcEvaporator
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcEvaporator(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEvaporatorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcEvaporatorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcEvaporatorTypeEnum ;
	static FromTape(tape: any[]): IfcEvaporatorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcEvaporatorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEvent {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, PredefinedType: IfcEventTypeEnum | null, EventTriggerType: IfcEventTriggerTypeEnum | null, UserDefinedEventTriggerType: IfcLabel | null, EventOccurenceTime: Handle<IfcEventTime> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.PredefinedType = PredefinedType;
		this.EventTriggerType = EventTriggerType;
		this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
		this.EventOccurenceTime = EventOccurenceTime;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	PredefinedType: IfcEventTypeEnum | null;
	EventTriggerType: IfcEventTriggerTypeEnum | null;
	UserDefinedEventTriggerType: IfcLabel | null;
	EventOccurenceTime: Handle<IfcEventTime> | null;
	static FromTape(tape: any[]): IfcEvent
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let PredefinedType = tape[7];
		let EventTriggerType = tape[8];
		let UserDefinedEventTriggerType = tape[9];
		let EventOccurenceTime = tape[10];
		return new IfcEvent(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.EventTriggerType){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedEventTriggerType){
		args.push(STRING)
		args.push(this.UserDefinedEventTriggerType)
		}
		else{ args.push(EMPTY); }
		if(this.EventOccurenceTime){
		args.push(REF)
		args.push(this.EventOccurenceTime.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEventTime {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null, ActualDate: IfcDateTime | null, EarlyDate: IfcDateTime | null, LateDate: IfcDateTime | null, ScheduleDate: IfcDateTime | null)
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.ActualDate = ActualDate;
		this.EarlyDate = EarlyDate;
		this.LateDate = LateDate;
		this.ScheduleDate = ScheduleDate;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	ActualDate: IfcDateTime | null;
	EarlyDate: IfcDateTime | null;
	LateDate: IfcDateTime | null;
	ScheduleDate: IfcDateTime | null;
	static FromTape(tape: any[]): IfcEventTime
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		let ActualDate = tape[3];
		let EarlyDate = tape[4];
		let LateDate = tape[5];
		let ScheduleDate = tape[6];
		return new IfcEventTime(Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.ActualDate){
		args.push(STRING)
		args.push(this.ActualDate)
		}
		else{ args.push(EMPTY); }
		if(this.EarlyDate){
		args.push(STRING)
		args.push(this.EarlyDate)
		}
		else{ args.push(EMPTY); }
		if(this.LateDate){
		args.push(STRING)
		args.push(this.LateDate)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleDate){
		args.push(STRING)
		args.push(this.ScheduleDate)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcEventType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ProcessType: IfcLabel | null, PredefinedType: IfcEventTypeEnum , EventTriggerType: IfcEventTriggerTypeEnum , UserDefinedEventTriggerType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ProcessType = ProcessType;
		this.PredefinedType = PredefinedType;
		this.EventTriggerType = EventTriggerType;
		this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ProcessType: IfcLabel | null;
	PredefinedType: IfcEventTypeEnum ;
	EventTriggerType: IfcEventTriggerTypeEnum ;
	UserDefinedEventTriggerType: IfcLabel | null;
	static FromTape(tape: any[]): IfcEventType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ProcessType = tape[8];
		let PredefinedType = tape[9];
		let EventTriggerType = tape[10];
		let UserDefinedEventTriggerType = tape[11];
		return new IfcEventType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ProcessType){
		args.push(STRING)
		args.push(this.ProcessType)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedEventTriggerType){
		args.push(STRING)
		args.push(this.UserDefinedEventTriggerType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExtendedProperties {
	constructor(Name: IfcIdentifier | null, Description: IfcText | null, Properties: Handle<IfcProperty>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.Properties = Properties;
	}
	Name: IfcIdentifier | null;
	Description: IfcText | null;
	Properties: Handle<IfcProperty>[] ;
	static FromTape(tape: any[]): IfcExtendedProperties
	{
		let Name = tape[0];
		let Description = tape[1];
		let Properties = tape[2];
		return new IfcExtendedProperties(Name, Description, Properties);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Properties.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcExternalInformation {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcExternalInformation
	{
		return new IfcExternalInformation();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcExternalReference {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcExternalReference
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		return new IfcExternalReference(Location, Identification, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExternalReferenceRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingReference: Handle<IfcExternalReference> , RelatedResourceObjects: IfcResourceObjectSelect[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingReference = RelatingReference;
		this.RelatedResourceObjects = RelatedResourceObjects;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingReference: Handle<IfcExternalReference> ;
	RelatedResourceObjects: IfcResourceObjectSelect[] ;
	static FromTape(tape: any[]): IfcExternalReferenceRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingReference = tape[2];
		let RelatedResourceObjects = tape[3];
		return new IfcExternalReferenceRelationship(Name, Description, RelatingReference, RelatedResourceObjects);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingReference.expressID)
		return args;
	}
};
export class IfcExternalSpatialElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, PredefinedType: IfcExternalSpatialElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	PredefinedType: IfcExternalSpatialElementTypeEnum | null;
	static FromTape(tape: any[]): IfcExternalSpatialElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let PredefinedType = tape[8];
		return new IfcExternalSpatialElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExternalSpatialStructureElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	static FromTape(tape: any[]): IfcExternalSpatialStructureElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		return new IfcExternalSpatialStructureElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExternallyDefinedHatchStyle {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcExternallyDefinedHatchStyle
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		return new IfcExternallyDefinedHatchStyle(Location, Identification, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExternallyDefinedSurfaceStyle {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcExternallyDefinedSurfaceStyle
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		return new IfcExternallyDefinedSurfaceStyle(Location, Identification, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExternallyDefinedTextFont {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcExternallyDefinedTextFont
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		return new IfcExternallyDefinedTextFont(Location, Identification, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcExtrudedAreaSolid {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, ExtrudedDirection: Handle<IfcDirection> , Depth: IfcPositiveLengthMeasure )
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
		this.ExtrudedDirection = ExtrudedDirection;
		this.Depth = Depth;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	ExtrudedDirection: Handle<IfcDirection> ;
	Depth: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcExtrudedAreaSolid
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		let ExtrudedDirection = tape[2];
		let Depth = tape[3];
		return new IfcExtrudedAreaSolid(SweptArea, Position, ExtrudedDirection, Depth);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ExtrudedDirection.expressID)
		return args;
	}
};
export class IfcExtrudedAreaSolidTapered {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, ExtrudedDirection: Handle<IfcDirection> , Depth: IfcPositiveLengthMeasure , EndSweptArea: Handle<IfcProfileDef> )
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
		this.ExtrudedDirection = ExtrudedDirection;
		this.Depth = Depth;
		this.EndSweptArea = EndSweptArea;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	ExtrudedDirection: Handle<IfcDirection> ;
	Depth: IfcPositiveLengthMeasure ;
	EndSweptArea: Handle<IfcProfileDef> ;
	static FromTape(tape: any[]): IfcExtrudedAreaSolidTapered
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		let ExtrudedDirection = tape[2];
		let Depth = tape[3];
		let EndSweptArea = tape[4];
		return new IfcExtrudedAreaSolidTapered(SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ExtrudedDirection.expressID)
		args.push(REF)
		args.push(this.EndSweptArea.expressID)
		return args;
	}
};
export class IfcFace {
	constructor(Bounds: Handle<IfcFaceBound>[] )
	{
		this.Bounds = Bounds;
	}
	Bounds: Handle<IfcFaceBound>[] ;
	static FromTape(tape: any[]): IfcFace
	{
		let Bounds = tape[0];
		return new IfcFace(Bounds);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Bounds.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcFaceBasedSurfaceModel {
	constructor(FbsmFaces: Handle<IfcConnectedFaceSet>[] )
	{
		this.FbsmFaces = FbsmFaces;
	}
	FbsmFaces: Handle<IfcConnectedFaceSet>[] ;
	static FromTape(tape: any[]): IfcFaceBasedSurfaceModel
	{
		let FbsmFaces = tape[0];
		return new IfcFaceBasedSurfaceModel(FbsmFaces);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.FbsmFaces.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcFaceBound {
	constructor(Bound: Handle<IfcLoop> , Orientation: IfcBoolean )
	{
		this.Bound = Bound;
		this.Orientation = Orientation;
	}
	Bound: Handle<IfcLoop> ;
	Orientation: IfcBoolean ;
	static FromTape(tape: any[]): IfcFaceBound
	{
		let Bound = tape[0];
		let Orientation = tape[1];
		return new IfcFaceBound(Bound, Orientation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Bound.expressID)
		return args;
	}
};
export class IfcFaceOuterBound {
	constructor(Bound: Handle<IfcLoop> , Orientation: IfcBoolean )
	{
		this.Bound = Bound;
		this.Orientation = Orientation;
	}
	Bound: Handle<IfcLoop> ;
	Orientation: IfcBoolean ;
	static FromTape(tape: any[]): IfcFaceOuterBound
	{
		let Bound = tape[0];
		let Orientation = tape[1];
		return new IfcFaceOuterBound(Bound, Orientation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Bound.expressID)
		return args;
	}
};
export class IfcFaceSurface {
	constructor(Bounds: Handle<IfcFaceBound>[] , FaceSurface: Handle<IfcSurface> , SameSense: IfcBoolean )
	{
		this.Bounds = Bounds;
		this.FaceSurface = FaceSurface;
		this.SameSense = SameSense;
	}
	Bounds: Handle<IfcFaceBound>[] ;
	FaceSurface: Handle<IfcSurface> ;
	SameSense: IfcBoolean ;
	static FromTape(tape: any[]): IfcFaceSurface
	{
		let Bounds = tape[0];
		let FaceSurface = tape[1];
		let SameSense = tape[2];
		return new IfcFaceSurface(Bounds, FaceSurface, SameSense);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Bounds.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.FaceSurface.expressID)
		return args;
	}
};
export class IfcFacetedBrep {
	constructor(Outer: Handle<IfcClosedShell> )
	{
		this.Outer = Outer;
	}
	Outer: Handle<IfcClosedShell> ;
	static FromTape(tape: any[]): IfcFacetedBrep
	{
		let Outer = tape[0];
		return new IfcFacetedBrep(Outer);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Outer.expressID)
		return args;
	}
};
export class IfcFacetedBrepWithVoids {
	constructor(Outer: Handle<IfcClosedShell> , Voids: Handle<IfcClosedShell>[] )
	{
		this.Outer = Outer;
		this.Voids = Voids;
	}
	Outer: Handle<IfcClosedShell> ;
	Voids: Handle<IfcClosedShell>[] ;
	static FromTape(tape: any[]): IfcFacetedBrepWithVoids
	{
		let Outer = tape[0];
		let Voids = tape[1];
		return new IfcFacetedBrepWithVoids(Outer, Voids);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Outer.expressID)
		args.push(SET_BEGIN)
		this.Voids.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcFacility {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	static FromTape(tape: any[]): IfcFacility
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		return new IfcFacility(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFacilityPart {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	static FromTape(tape: any[]): IfcFacilityPart
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		return new IfcFacilityPart(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFailureConnectionCondition {
	constructor(Name: IfcLabel | null, TensionFailureX: IfcForceMeasure | null, TensionFailureY: IfcForceMeasure | null, TensionFailureZ: IfcForceMeasure | null, CompressionFailureX: IfcForceMeasure | null, CompressionFailureY: IfcForceMeasure | null, CompressionFailureZ: IfcForceMeasure | null)
	{
		this.Name = Name;
		this.TensionFailureX = TensionFailureX;
		this.TensionFailureY = TensionFailureY;
		this.TensionFailureZ = TensionFailureZ;
		this.CompressionFailureX = CompressionFailureX;
		this.CompressionFailureY = CompressionFailureY;
		this.CompressionFailureZ = CompressionFailureZ;
	}
	Name: IfcLabel | null;
	TensionFailureX: IfcForceMeasure | null;
	TensionFailureY: IfcForceMeasure | null;
	TensionFailureZ: IfcForceMeasure | null;
	CompressionFailureX: IfcForceMeasure | null;
	CompressionFailureY: IfcForceMeasure | null;
	CompressionFailureZ: IfcForceMeasure | null;
	static FromTape(tape: any[]): IfcFailureConnectionCondition
	{
		let Name = tape[0];
		let TensionFailureX = tape[1];
		let TensionFailureY = tape[2];
		let TensionFailureZ = tape[3];
		let CompressionFailureX = tape[4];
		let CompressionFailureY = tape[5];
		let CompressionFailureZ = tape[6];
		return new IfcFailureConnectionCondition(Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.TensionFailureX){
		args.push(REAL)
		args.push(this.TensionFailureX)
		}
		else{ args.push(EMPTY); }
		if(this.TensionFailureY){
		args.push(REAL)
		args.push(this.TensionFailureY)
		}
		else{ args.push(EMPTY); }
		if(this.TensionFailureZ){
		args.push(REAL)
		args.push(this.TensionFailureZ)
		}
		else{ args.push(EMPTY); }
		if(this.CompressionFailureX){
		args.push(REAL)
		args.push(this.CompressionFailureX)
		}
		else{ args.push(EMPTY); }
		if(this.CompressionFailureY){
		args.push(REAL)
		args.push(this.CompressionFailureY)
		}
		else{ args.push(EMPTY); }
		if(this.CompressionFailureZ){
		args.push(REAL)
		args.push(this.CompressionFailureZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFan {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFanTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFanTypeEnum | null;
	static FromTape(tape: any[]): IfcFan
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFan(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFanType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFanTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFanTypeEnum ;
	static FromTape(tape: any[]): IfcFanType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFanType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFastener {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFastenerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFastenerTypeEnum | null;
	static FromTape(tape: any[]): IfcFastener
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFastener(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFastenerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFastenerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFastenerTypeEnum ;
	static FromTape(tape: any[]): IfcFastenerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFastenerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFeatureElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFeatureElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFeatureElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFeatureElementAddition {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFeatureElementAddition
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFeatureElementAddition(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFeatureElementSubtraction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFeatureElementSubtraction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFeatureElementSubtraction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFillAreaStyle {
	constructor(Name: IfcLabel | null, FillStyles: IfcFillStyleSelect[] , ModelorDraughting: IfcBoolean | null)
	{
		this.Name = Name;
		this.FillStyles = FillStyles;
		this.ModelorDraughting = ModelorDraughting;
	}
	Name: IfcLabel | null;
	FillStyles: IfcFillStyleSelect[] ;
	ModelorDraughting: IfcBoolean | null;
	static FromTape(tape: any[]): IfcFillAreaStyle
	{
		let Name = tape[0];
		let FillStyles = tape[1];
		let ModelorDraughting = tape[2];
		return new IfcFillAreaStyle(Name, FillStyles, ModelorDraughting);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.ModelorDraughting){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFillAreaStyleHatching {
	constructor(HatchLineAppearance: Handle<IfcCurveStyle> , StartOfNextHatchLine: IfcHatchLineDistanceSelect , PointOfReferenceHatchLine: Handle<IfcCartesianPoint> | null, PatternStart: Handle<IfcCartesianPoint> | null, HatchLineAngle: IfcPlaneAngleMeasure )
	{
		this.HatchLineAppearance = HatchLineAppearance;
		this.StartOfNextHatchLine = StartOfNextHatchLine;
		this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
		this.PatternStart = PatternStart;
		this.HatchLineAngle = HatchLineAngle;
	}
	HatchLineAppearance: Handle<IfcCurveStyle> ;
	StartOfNextHatchLine: IfcHatchLineDistanceSelect ;
	PointOfReferenceHatchLine: Handle<IfcCartesianPoint> | null;
	PatternStart: Handle<IfcCartesianPoint> | null;
	HatchLineAngle: IfcPlaneAngleMeasure ;
	static FromTape(tape: any[]): IfcFillAreaStyleHatching
	{
		let HatchLineAppearance = tape[0];
		let StartOfNextHatchLine = tape[1];
		let PointOfReferenceHatchLine = tape[2];
		let PatternStart = tape[3];
		let HatchLineAngle = tape[4];
		return new IfcFillAreaStyleHatching(HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.HatchLineAppearance.expressID)
		if(this.PointOfReferenceHatchLine){
		args.push(REF)
		args.push(this.PointOfReferenceHatchLine.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PatternStart){
		args.push(REF)
		args.push(this.PatternStart.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.HatchLineAngle)
		return args;
	}
};
export class IfcFillAreaStyleTiles {
	constructor(TilingPattern: Handle<IfcVector>[] , Tiles: Handle<IfcStyledItem>[] , TilingScale: IfcPositiveRatioMeasure )
	{
		this.TilingPattern = TilingPattern;
		this.Tiles = Tiles;
		this.TilingScale = TilingScale;
	}
	TilingPattern: Handle<IfcVector>[] ;
	Tiles: Handle<IfcStyledItem>[] ;
	TilingScale: IfcPositiveRatioMeasure ;
	static FromTape(tape: any[]): IfcFillAreaStyleTiles
	{
		let TilingPattern = tape[0];
		let Tiles = tape[1];
		let TilingScale = tape[2];
		return new IfcFillAreaStyleTiles(TilingPattern, Tiles, TilingScale);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.TilingPattern.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(SET_BEGIN)
		this.Tiles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcFilter {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFilterTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFilterTypeEnum | null;
	static FromTape(tape: any[]): IfcFilter
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFilter(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFilterType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFilterTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFilterTypeEnum ;
	static FromTape(tape: any[]): IfcFilterType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFilterType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFireSuppressionTerminal {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFireSuppressionTerminalTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFireSuppressionTerminalTypeEnum | null;
	static FromTape(tape: any[]): IfcFireSuppressionTerminal
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFireSuppressionTerminal(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFireSuppressionTerminalType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFireSuppressionTerminalTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFireSuppressionTerminalTypeEnum ;
	static FromTape(tape: any[]): IfcFireSuppressionTerminalType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFireSuppressionTerminalType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFixedReferenceSweptAreaSolid {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, Directrix: Handle<IfcCurve> , StartParam: IfcParameterValue | null, EndParam: IfcParameterValue | null, FixedReference: Handle<IfcDirection> )
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
		this.Directrix = Directrix;
		this.StartParam = StartParam;
		this.EndParam = EndParam;
		this.FixedReference = FixedReference;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	Directrix: Handle<IfcCurve> ;
	StartParam: IfcParameterValue | null;
	EndParam: IfcParameterValue | null;
	FixedReference: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcFixedReferenceSweptAreaSolid
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		let Directrix = tape[2];
		let StartParam = tape[3];
		let EndParam = tape[4];
		let FixedReference = tape[5];
		return new IfcFixedReferenceSweptAreaSolid(SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Directrix.expressID)
		if(this.StartParam){
		args.push(REAL)
		args.push(this.StartParam)
		}
		else{ args.push(EMPTY); }
		if(this.EndParam){
		args.push(REAL)
		args.push(this.EndParam)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.FixedReference.expressID)
		return args;
	}
};
export class IfcFlowController {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowController
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowController(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowControllerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowControllerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowControllerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowFitting {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowFitting
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowFitting(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowFittingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowFittingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowFittingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowInstrument {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFlowInstrumentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFlowInstrumentTypeEnum | null;
	static FromTape(tape: any[]): IfcFlowInstrument
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFlowInstrument(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowInstrumentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFlowInstrumentTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFlowInstrumentTypeEnum ;
	static FromTape(tape: any[]): IfcFlowInstrumentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFlowInstrumentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowMeter {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFlowMeterTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFlowMeterTypeEnum | null;
	static FromTape(tape: any[]): IfcFlowMeter
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFlowMeter(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowMeterType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFlowMeterTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFlowMeterTypeEnum ;
	static FromTape(tape: any[]): IfcFlowMeterType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFlowMeterType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowMovingDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowMovingDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowMovingDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowMovingDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowMovingDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowMovingDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowSegment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowSegment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowSegment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowSegmentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowSegmentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowSegmentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowStorageDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowStorageDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowStorageDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowStorageDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowStorageDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowStorageDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowTerminal {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowTerminal
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowTerminal(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowTerminalType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowTerminalType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowTerminalType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowTreatmentDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFlowTreatmentDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFlowTreatmentDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFlowTreatmentDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFlowTreatmentDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFlowTreatmentDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFooting {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFootingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFootingTypeEnum | null;
	static FromTape(tape: any[]): IfcFooting
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFooting(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFootingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcFootingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcFootingTypeEnum ;
	static FromTape(tape: any[]): IfcFootingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcFootingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFurnishingElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcFurnishingElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcFurnishingElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFurnishingElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcFurnishingElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcFurnishingElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFurniture {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcFurnitureTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcFurnitureTypeEnum | null;
	static FromTape(tape: any[]): IfcFurniture
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcFurniture(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcFurnitureType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, AssemblyPlace: IfcAssemblyPlaceEnum , PredefinedType: IfcFurnitureTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.AssemblyPlace = AssemblyPlace;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	AssemblyPlace: IfcAssemblyPlaceEnum ;
	PredefinedType: IfcFurnitureTypeEnum | null;
	static FromTape(tape: any[]): IfcFurnitureType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let AssemblyPlace = tape[9];
		let PredefinedType = tape[10];
		return new IfcFurnitureType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGeographicElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcGeographicElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcGeographicElementTypeEnum | null;
	static FromTape(tape: any[]): IfcGeographicElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcGeographicElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGeographicElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcGeographicElementTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcGeographicElementTypeEnum ;
	static FromTape(tape: any[]): IfcGeographicElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcGeographicElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGeometricCurveSet {
	constructor(Elements: IfcGeometricSetSelect[] )
	{
		this.Elements = Elements;
	}
	Elements: IfcGeometricSetSelect[] ;
	static FromTape(tape: any[]): IfcGeometricCurveSet
	{
		let Elements = tape[0];
		return new IfcGeometricCurveSet(Elements);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcGeometricRepresentationContext {
	constructor(ContextIdentifier: IfcLabel | null, ContextType: IfcLabel | null, CoordinateSpaceDimension: IfcDimensionCount , Precision: IfcReal | null, WorldCoordinateSystem: IfcAxis2Placement , TrueNorth: Handle<IfcDirection> | null)
	{
		this.ContextIdentifier = ContextIdentifier;
		this.ContextType = ContextType;
		this.CoordinateSpaceDimension = CoordinateSpaceDimension;
		this.Precision = Precision;
		this.WorldCoordinateSystem = WorldCoordinateSystem;
		this.TrueNorth = TrueNorth;
	}
	ContextIdentifier: IfcLabel | null;
	ContextType: IfcLabel | null;
	CoordinateSpaceDimension: IfcDimensionCount ;
	Precision: IfcReal | null;
	WorldCoordinateSystem: IfcAxis2Placement ;
	TrueNorth: Handle<IfcDirection> | null;
	static FromTape(tape: any[]): IfcGeometricRepresentationContext
	{
		let ContextIdentifier = tape[0];
		let ContextType = tape[1];
		let CoordinateSpaceDimension = tape[2];
		let Precision = tape[3];
		let WorldCoordinateSystem = tape[4];
		let TrueNorth = tape[5];
		return new IfcGeometricRepresentationContext(ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ContextIdentifier){
		args.push(STRING)
		args.push(this.ContextIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.ContextType){
		args.push(STRING)
		args.push(this.ContextType)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.CoordinateSpaceDimension)
		if(this.Precision){
		args.push(REAL)
		args.push(this.Precision)
		}
		else{ args.push(EMPTY); }
		if(this.TrueNorth){
		args.push(REF)
		args.push(this.TrueNorth.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGeometricRepresentationItem {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcGeometricRepresentationItem
	{
		return new IfcGeometricRepresentationItem();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcGeometricRepresentationSubContext {
	constructor(ContextIdentifier: IfcLabel | null, ContextType: IfcLabel | null, CoordinateSpaceDimension: IfcDimensionCount , Precision: IfcReal | null, WorldCoordinateSystem: IfcAxis2Placement , TrueNorth: Handle<IfcDirection> | null, ParentContext: Handle<IfcGeometricRepresentationContext> , TargetScale: IfcPositiveRatioMeasure | null, TargetView: IfcGeometricProjectionEnum , UserDefinedTargetView: IfcLabel | null)
	{
		this.ContextIdentifier = ContextIdentifier;
		this.ContextType = ContextType;
		this.CoordinateSpaceDimension = CoordinateSpaceDimension;
		this.Precision = Precision;
		this.WorldCoordinateSystem = WorldCoordinateSystem;
		this.TrueNorth = TrueNorth;
		this.ParentContext = ParentContext;
		this.TargetScale = TargetScale;
		this.TargetView = TargetView;
		this.UserDefinedTargetView = UserDefinedTargetView;
	}
	ContextIdentifier: IfcLabel | null;
	ContextType: IfcLabel | null;
	CoordinateSpaceDimension: IfcDimensionCount ;
	Precision: IfcReal | null;
	WorldCoordinateSystem: IfcAxis2Placement ;
	TrueNorth: Handle<IfcDirection> | null;
	ParentContext: Handle<IfcGeometricRepresentationContext> ;
	TargetScale: IfcPositiveRatioMeasure | null;
	TargetView: IfcGeometricProjectionEnum ;
	UserDefinedTargetView: IfcLabel | null;
	static FromTape(tape: any[]): IfcGeometricRepresentationSubContext
	{
		let ContextIdentifier = tape[0];
		let ContextType = tape[1];
		let CoordinateSpaceDimension = tape[2];
		let Precision = tape[3];
		let WorldCoordinateSystem = tape[4];
		let TrueNorth = tape[5];
		let ParentContext = tape[6];
		let TargetScale = tape[7];
		let TargetView = tape[8];
		let UserDefinedTargetView = tape[9];
		return new IfcGeometricRepresentationSubContext(ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ContextIdentifier){
		args.push(STRING)
		args.push(this.ContextIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.ContextType){
		args.push(STRING)
		args.push(this.ContextType)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.CoordinateSpaceDimension)
		if(this.Precision){
		args.push(REAL)
		args.push(this.Precision)
		}
		else{ args.push(EMPTY); }
		if(this.TrueNorth){
		args.push(REF)
		args.push(this.TrueNorth.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ParentContext.expressID)
		if(this.TargetScale){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedTargetView){
		args.push(STRING)
		args.push(this.UserDefinedTargetView)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGeometricSet {
	constructor(Elements: IfcGeometricSetSelect[] )
	{
		this.Elements = Elements;
	}
	Elements: IfcGeometricSetSelect[] ;
	static FromTape(tape: any[]): IfcGeometricSet
	{
		let Elements = tape[0];
		return new IfcGeometricSet(Elements);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcGrid {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, UAxes: Handle<IfcGridAxis>[] , VAxes: Handle<IfcGridAxis>[] , WAxes: Handle<IfcGridAxis>[] | null, PredefinedType: IfcGridTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.UAxes = UAxes;
		this.VAxes = VAxes;
		this.WAxes = WAxes;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	UAxes: Handle<IfcGridAxis>[] ;
	VAxes: Handle<IfcGridAxis>[] ;
	WAxes: Handle<IfcGridAxis>[] | null;
	PredefinedType: IfcGridTypeEnum | null;
	static FromTape(tape: any[]): IfcGrid
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let UAxes = tape[7];
		let VAxes = tape[8];
		let WAxes = tape[9];
		let PredefinedType = tape[10];
		return new IfcGrid(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.UAxes.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(SET_BEGIN)
		this.VAxes.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.WAxes){
		args.push(SET_BEGIN)
		this.WAxes.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGridAxis {
	constructor(AxisTag: IfcLabel | null, AxisCurve: Handle<IfcCurve> , SameSense: IfcBoolean )
	{
		this.AxisTag = AxisTag;
		this.AxisCurve = AxisCurve;
		this.SameSense = SameSense;
	}
	AxisTag: IfcLabel | null;
	AxisCurve: Handle<IfcCurve> ;
	SameSense: IfcBoolean ;
	static FromTape(tape: any[]): IfcGridAxis
	{
		let AxisTag = tape[0];
		let AxisCurve = tape[1];
		let SameSense = tape[2];
		return new IfcGridAxis(AxisTag, AxisCurve, SameSense);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.AxisTag){
		args.push(STRING)
		args.push(this.AxisTag)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AxisCurve.expressID)
		return args;
	}
};
export class IfcGridPlacement {
	constructor(PlacementRelTo: Handle<IfcObjectPlacement> | null, PlacementLocation: Handle<IfcVirtualGridIntersection> , PlacementRefDirection: IfcGridPlacementDirectionSelect | null)
	{
		this.PlacementRelTo = PlacementRelTo;
		this.PlacementLocation = PlacementLocation;
		this.PlacementRefDirection = PlacementRefDirection;
	}
	PlacementRelTo: Handle<IfcObjectPlacement> | null;
	PlacementLocation: Handle<IfcVirtualGridIntersection> ;
	PlacementRefDirection: IfcGridPlacementDirectionSelect | null;
	static FromTape(tape: any[]): IfcGridPlacement
	{
		let PlacementRelTo = tape[0];
		let PlacementLocation = tape[1];
		let PlacementRefDirection = tape[2];
		return new IfcGridPlacement(PlacementRelTo, PlacementLocation, PlacementRefDirection);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.PlacementRelTo){
		args.push(REF)
		args.push(this.PlacementRelTo.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.PlacementLocation.expressID)
		if(this.PlacementRefDirection){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcGroup {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	static FromTape(tape: any[]): IfcGroup
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		return new IfcGroup(GlobalId, OwnerHistory, Name, Description, ObjectType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcHalfSpaceSolid {
	constructor(BaseSurface: Handle<IfcSurface> , AgreementFlag: IfcBoolean )
	{
		this.BaseSurface = BaseSurface;
		this.AgreementFlag = AgreementFlag;
	}
	BaseSurface: Handle<IfcSurface> ;
	AgreementFlag: IfcBoolean ;
	static FromTape(tape: any[]): IfcHalfSpaceSolid
	{
		let BaseSurface = tape[0];
		let AgreementFlag = tape[1];
		return new IfcHalfSpaceSolid(BaseSurface, AgreementFlag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BaseSurface.expressID)
		return args;
	}
};
export class IfcHeatExchanger {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcHeatExchangerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcHeatExchangerTypeEnum | null;
	static FromTape(tape: any[]): IfcHeatExchanger
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcHeatExchanger(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcHeatExchangerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcHeatExchangerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcHeatExchangerTypeEnum ;
	static FromTape(tape: any[]): IfcHeatExchangerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcHeatExchangerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcHumidifier {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcHumidifierTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcHumidifierTypeEnum | null;
	static FromTape(tape: any[]): IfcHumidifier
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcHumidifier(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcHumidifierType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcHumidifierTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcHumidifierTypeEnum ;
	static FromTape(tape: any[]): IfcHumidifierType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcHumidifierType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcIShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, OverallWidth: IfcPositiveLengthMeasure , OverallDepth: IfcPositiveLengthMeasure , WebThickness: IfcPositiveLengthMeasure , FlangeThickness: IfcPositiveLengthMeasure , FilletRadius: IfcNonNegativeLengthMeasure | null, FlangeEdgeRadius: IfcNonNegativeLengthMeasure | null, FlangeSlope: IfcPlaneAngleMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.OverallWidth = OverallWidth;
		this.OverallDepth = OverallDepth;
		this.WebThickness = WebThickness;
		this.FlangeThickness = FlangeThickness;
		this.FilletRadius = FilletRadius;
		this.FlangeEdgeRadius = FlangeEdgeRadius;
		this.FlangeSlope = FlangeSlope;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	OverallWidth: IfcPositiveLengthMeasure ;
	OverallDepth: IfcPositiveLengthMeasure ;
	WebThickness: IfcPositiveLengthMeasure ;
	FlangeThickness: IfcPositiveLengthMeasure ;
	FilletRadius: IfcNonNegativeLengthMeasure | null;
	FlangeEdgeRadius: IfcNonNegativeLengthMeasure | null;
	FlangeSlope: IfcPlaneAngleMeasure | null;
	static FromTape(tape: any[]): IfcIShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let OverallWidth = tape[3];
		let OverallDepth = tape[4];
		let WebThickness = tape[5];
		let FlangeThickness = tape[6];
		let FilletRadius = tape[7];
		let FlangeEdgeRadius = tape[8];
		let FlangeSlope = tape[9];
		return new IfcIShapeProfileDef(ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.FilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.FlangeEdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.FlangeSlope){
		args.push(REAL)
		args.push(this.FlangeSlope)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcImageTexture {
	constructor(RepeatS: IfcBoolean , RepeatT: IfcBoolean , Mode: IfcIdentifier | null, TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null, Parameter: IfcIdentifier[] | null, URLReference: IfcURIReference )
	{
		this.RepeatS = RepeatS;
		this.RepeatT = RepeatT;
		this.Mode = Mode;
		this.TextureTransform = TextureTransform;
		this.Parameter = Parameter;
		this.URLReference = URLReference;
	}
	RepeatS: IfcBoolean ;
	RepeatT: IfcBoolean ;
	Mode: IfcIdentifier | null;
	TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null;
	Parameter: IfcIdentifier[] | null;
	URLReference: IfcURIReference ;
	static FromTape(tape: any[]): IfcImageTexture
	{
		let RepeatS = tape[0];
		let RepeatT = tape[1];
		let Mode = tape[2];
		let TextureTransform = tape[3];
		let Parameter = tape[4];
		let URLReference = tape[5];
		return new IfcImageTexture(RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Mode){
		args.push(STRING)
		args.push(this.Mode)
		}
		else{ args.push(EMPTY); }
		if(this.TextureTransform){
		args.push(REF)
		args.push(this.TextureTransform.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Parameter){
		args.push(STRING)
		args.push(...this.Parameter)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.URLReference)
		return args;
	}
};
export class IfcIndexedColourMap {
	constructor(MappedTo: Handle<IfcTessellatedFaceSet> , Opacity: IfcNormalisedRatioMeasure | null, Colours: Handle<IfcColourRgbList> , ColourIndex: IfcPositiveInteger[] )
	{
		this.MappedTo = MappedTo;
		this.Opacity = Opacity;
		this.Colours = Colours;
		this.ColourIndex = ColourIndex;
	}
	MappedTo: Handle<IfcTessellatedFaceSet> ;
	Opacity: IfcNormalisedRatioMeasure | null;
	Colours: Handle<IfcColourRgbList> ;
	ColourIndex: IfcPositiveInteger[] ;
	static FromTape(tape: any[]): IfcIndexedColourMap
	{
		let MappedTo = tape[0];
		let Opacity = tape[1];
		let Colours = tape[2];
		let ColourIndex = tape[3];
		return new IfcIndexedColourMap(MappedTo, Opacity, Colours, ColourIndex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.MappedTo.expressID)
		if(this.Opacity){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Colours.expressID)
		return args;
	}
};
export class IfcIndexedPolyCurve {
	constructor(Points: Handle<IfcCartesianPointList> , Segments: IfcSegmentIndexSelect[] | null, SelfIntersect: IfcBoolean | null)
	{
		this.Points = Points;
		this.Segments = Segments;
		this.SelfIntersect = SelfIntersect;
	}
	Points: Handle<IfcCartesianPointList> ;
	Segments: IfcSegmentIndexSelect[] | null;
	SelfIntersect: IfcBoolean | null;
	static FromTape(tape: any[]): IfcIndexedPolyCurve
	{
		let Points = tape[0];
		let Segments = tape[1];
		let SelfIntersect = tape[2];
		return new IfcIndexedPolyCurve(Points, Segments, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Points.expressID)
		if(this.Segments){
		}
		else{ args.push(EMPTY); }
		if(this.SelfIntersect){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcIndexedPolygonalFace {
	constructor(CoordIndex: IfcPositiveInteger[] )
	{
		this.CoordIndex = CoordIndex;
	}
	CoordIndex: IfcPositiveInteger[] ;
	static FromTape(tape: any[]): IfcIndexedPolygonalFace
	{
		let CoordIndex = tape[0];
		return new IfcIndexedPolygonalFace(CoordIndex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcIndexedPolygonalFaceWithVoids {
	constructor(CoordIndex: IfcPositiveInteger[] , InnerCoordIndices: IfcPositiveInteger[] )
	{
		this.CoordIndex = CoordIndex;
		this.InnerCoordIndices = InnerCoordIndices;
	}
	CoordIndex: IfcPositiveInteger[] ;
	InnerCoordIndices: IfcPositiveInteger[] ;
	static FromTape(tape: any[]): IfcIndexedPolygonalFaceWithVoids
	{
		let CoordIndex = tape[0];
		let InnerCoordIndices = tape[1];
		return new IfcIndexedPolygonalFaceWithVoids(CoordIndex, InnerCoordIndices);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcIndexedTextureMap {
	constructor(Maps: Handle<IfcSurfaceTexture>[] , MappedTo: Handle<IfcTessellatedFaceSet> , TexCoords: Handle<IfcTextureVertexList> )
	{
		this.Maps = Maps;
		this.MappedTo = MappedTo;
		this.TexCoords = TexCoords;
	}
	Maps: Handle<IfcSurfaceTexture>[] ;
	MappedTo: Handle<IfcTessellatedFaceSet> ;
	TexCoords: Handle<IfcTextureVertexList> ;
	static FromTape(tape: any[]): IfcIndexedTextureMap
	{
		let Maps = tape[0];
		let MappedTo = tape[1];
		let TexCoords = tape[2];
		return new IfcIndexedTextureMap(Maps, MappedTo, TexCoords);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Maps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.MappedTo.expressID)
		args.push(REF)
		args.push(this.TexCoords.expressID)
		return args;
	}
};
export class IfcIndexedTriangleTextureMap {
	constructor(Maps: Handle<IfcSurfaceTexture>[] , MappedTo: Handle<IfcTessellatedFaceSet> , TexCoords: Handle<IfcTextureVertexList> , TexCoordIndex: IfcPositiveInteger[] | null)
	{
		this.Maps = Maps;
		this.MappedTo = MappedTo;
		this.TexCoords = TexCoords;
		this.TexCoordIndex = TexCoordIndex;
	}
	Maps: Handle<IfcSurfaceTexture>[] ;
	MappedTo: Handle<IfcTessellatedFaceSet> ;
	TexCoords: Handle<IfcTextureVertexList> ;
	TexCoordIndex: IfcPositiveInteger[] | null;
	static FromTape(tape: any[]): IfcIndexedTriangleTextureMap
	{
		let Maps = tape[0];
		let MappedTo = tape[1];
		let TexCoords = tape[2];
		let TexCoordIndex = tape[3];
		return new IfcIndexedTriangleTextureMap(Maps, MappedTo, TexCoords, TexCoordIndex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Maps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.MappedTo.expressID)
		args.push(REF)
		args.push(this.TexCoords.expressID)
		if(this.TexCoordIndex){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcInterceptor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcInterceptorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcInterceptorTypeEnum | null;
	static FromTape(tape: any[]): IfcInterceptor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcInterceptor(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcInterceptorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcInterceptorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcInterceptorTypeEnum ;
	static FromTape(tape: any[]): IfcInterceptorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcInterceptorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcIntersectionCurve {
	constructor(Curve3D: Handle<IfcCurve> , AssociatedGeometry: Handle<IfcPcurve>[] , MasterRepresentation: IfcPreferredSurfaceCurveRepresentation )
	{
		this.Curve3D = Curve3D;
		this.AssociatedGeometry = AssociatedGeometry;
		this.MasterRepresentation = MasterRepresentation;
	}
	Curve3D: Handle<IfcCurve> ;
	AssociatedGeometry: Handle<IfcPcurve>[] ;
	MasterRepresentation: IfcPreferredSurfaceCurveRepresentation ;
	static FromTape(tape: any[]): IfcIntersectionCurve
	{
		let Curve3D = tape[0];
		let AssociatedGeometry = tape[1];
		let MasterRepresentation = tape[2];
		return new IfcIntersectionCurve(Curve3D, AssociatedGeometry, MasterRepresentation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Curve3D.expressID)
		args.push(SET_BEGIN)
		this.AssociatedGeometry.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcInventory {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, PredefinedType: IfcInventoryTypeEnum | null, Jurisdiction: IfcActorSelect | null, ResponsiblePersons: Handle<IfcPerson>[] | null, LastUpdateDate: IfcDate | null, CurrentValue: Handle<IfcCostValue> | null, OriginalValue: Handle<IfcCostValue> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.PredefinedType = PredefinedType;
		this.Jurisdiction = Jurisdiction;
		this.ResponsiblePersons = ResponsiblePersons;
		this.LastUpdateDate = LastUpdateDate;
		this.CurrentValue = CurrentValue;
		this.OriginalValue = OriginalValue;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	PredefinedType: IfcInventoryTypeEnum | null;
	Jurisdiction: IfcActorSelect | null;
	ResponsiblePersons: Handle<IfcPerson>[] | null;
	LastUpdateDate: IfcDate | null;
	CurrentValue: Handle<IfcCostValue> | null;
	OriginalValue: Handle<IfcCostValue> | null;
	static FromTape(tape: any[]): IfcInventory
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let PredefinedType = tape[5];
		let Jurisdiction = tape[6];
		let ResponsiblePersons = tape[7];
		let LastUpdateDate = tape[8];
		let CurrentValue = tape[9];
		let OriginalValue = tape[10];
		return new IfcInventory(GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.Jurisdiction){
		}
		else{ args.push(EMPTY); }
		if(this.ResponsiblePersons){
		args.push(SET_BEGIN)
		this.ResponsiblePersons.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.LastUpdateDate){
		args.push(STRING)
		args.push(this.LastUpdateDate)
		}
		else{ args.push(EMPTY); }
		if(this.CurrentValue){
		args.push(REF)
		args.push(this.CurrentValue.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.OriginalValue){
		args.push(REF)
		args.push(this.OriginalValue.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcIrregularTimeSeries {
	constructor(Name: IfcLabel , Description: IfcText | null, StartTime: IfcDateTime , EndTime: IfcDateTime , TimeSeriesDataType: IfcTimeSeriesDataTypeEnum , DataOrigin: IfcDataOriginEnum , UserDefinedDataOrigin: IfcLabel | null, Unit: IfcUnit | null, Values: Handle<IfcIrregularTimeSeriesValue>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.StartTime = StartTime;
		this.EndTime = EndTime;
		this.TimeSeriesDataType = TimeSeriesDataType;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.Unit = Unit;
		this.Values = Values;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	StartTime: IfcDateTime ;
	EndTime: IfcDateTime ;
	TimeSeriesDataType: IfcTimeSeriesDataTypeEnum ;
	DataOrigin: IfcDataOriginEnum ;
	UserDefinedDataOrigin: IfcLabel | null;
	Unit: IfcUnit | null;
	Values: Handle<IfcIrregularTimeSeriesValue>[] ;
	static FromTape(tape: any[]): IfcIrregularTimeSeries
	{
		let Name = tape[0];
		let Description = tape[1];
		let StartTime = tape[2];
		let EndTime = tape[3];
		let TimeSeriesDataType = tape[4];
		let DataOrigin = tape[5];
		let UserDefinedDataOrigin = tape[6];
		let Unit = tape[7];
		let Values = tape[8];
		return new IfcIrregularTimeSeries(Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.StartTime)
		args.push(STRING)
		args.push(this.EndTime)
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Values.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcIrregularTimeSeriesValue {
	constructor(TimeStamp: IfcDateTime , ListValues: IfcValue[] )
	{
		this.TimeStamp = TimeStamp;
		this.ListValues = ListValues;
	}
	TimeStamp: IfcDateTime ;
	ListValues: IfcValue[] ;
	static FromTape(tape: any[]): IfcIrregularTimeSeriesValue
	{
		let TimeStamp = tape[0];
		let ListValues = { t: tape[1], v: tape[2][0]} as any;
		return new IfcIrregularTimeSeriesValue(TimeStamp, ListValues);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.TimeStamp)
		return args;
	}
};
export class IfcJunctionBox {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcJunctionBoxTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcJunctionBoxTypeEnum | null;
	static FromTape(tape: any[]): IfcJunctionBox
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcJunctionBox(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcJunctionBoxType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcJunctionBoxTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcJunctionBoxTypeEnum ;
	static FromTape(tape: any[]): IfcJunctionBoxType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcJunctionBoxType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Depth: IfcPositiveLengthMeasure , Width: IfcPositiveLengthMeasure | null, Thickness: IfcPositiveLengthMeasure , FilletRadius: IfcNonNegativeLengthMeasure | null, EdgeRadius: IfcNonNegativeLengthMeasure | null, LegSlope: IfcPlaneAngleMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Depth = Depth;
		this.Width = Width;
		this.Thickness = Thickness;
		this.FilletRadius = FilletRadius;
		this.EdgeRadius = EdgeRadius;
		this.LegSlope = LegSlope;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Depth: IfcPositiveLengthMeasure ;
	Width: IfcPositiveLengthMeasure | null;
	Thickness: IfcPositiveLengthMeasure ;
	FilletRadius: IfcNonNegativeLengthMeasure | null;
	EdgeRadius: IfcNonNegativeLengthMeasure | null;
	LegSlope: IfcPlaneAngleMeasure | null;
	static FromTape(tape: any[]): IfcLShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Depth = tape[3];
		let Width = tape[4];
		let Thickness = tape[5];
		let FilletRadius = tape[6];
		let EdgeRadius = tape[7];
		let LegSlope = tape[8];
		return new IfcLShapeProfileDef(ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Width){
		}
		else{ args.push(EMPTY); }
		if(this.FilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.EdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.LegSlope){
		args.push(REAL)
		args.push(this.LegSlope)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLaborResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcLaborResourceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcLaborResourceTypeEnum | null;
	static FromTape(tape: any[]): IfcLaborResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		let PredefinedType = tape[10];
		return new IfcLaborResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLaborResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcLaborResourceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcLaborResourceTypeEnum ;
	static FromTape(tape: any[]): IfcLaborResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		let PredefinedType = tape[11];
		return new IfcLaborResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLagTime {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null, LagValue: IfcTimeOrRatioSelect , DurationType: IfcTaskDurationEnum )
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.LagValue = LagValue;
		this.DurationType = DurationType;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	LagValue: IfcTimeOrRatioSelect ;
	DurationType: IfcTaskDurationEnum ;
	static FromTape(tape: any[]): IfcLagTime
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		let LagValue = tape[3];
		let DurationType = tape[4];
		return new IfcLagTime(Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLamp {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcLampTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcLampTypeEnum | null;
	static FromTape(tape: any[]): IfcLamp
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcLamp(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLampType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcLampTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcLampTypeEnum ;
	static FromTape(tape: any[]): IfcLampType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcLampType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLibraryInformation {
	constructor(Name: IfcLabel , Version: IfcLabel | null, Publisher: IfcActorSelect | null, VersionDate: IfcDateTime | null, Location: IfcURIReference | null, Description: IfcText | null)
	{
		this.Name = Name;
		this.Version = Version;
		this.Publisher = Publisher;
		this.VersionDate = VersionDate;
		this.Location = Location;
		this.Description = Description;
	}
	Name: IfcLabel ;
	Version: IfcLabel | null;
	Publisher: IfcActorSelect | null;
	VersionDate: IfcDateTime | null;
	Location: IfcURIReference | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcLibraryInformation
	{
		let Name = tape[0];
		let Version = tape[1];
		let Publisher = tape[2];
		let VersionDate = tape[3];
		let Location = tape[4];
		let Description = tape[5];
		return new IfcLibraryInformation(Name, Version, Publisher, VersionDate, Location, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Version){
		args.push(STRING)
		args.push(this.Version)
		}
		else{ args.push(EMPTY); }
		if(this.Publisher){
		}
		else{ args.push(EMPTY); }
		if(this.VersionDate){
		args.push(STRING)
		args.push(this.VersionDate)
		}
		else{ args.push(EMPTY); }
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLibraryReference {
	constructor(Location: IfcURIReference | null, Identification: IfcIdentifier | null, Name: IfcLabel | null, Description: IfcText | null, Language: IfcLanguageId | null, ReferencedLibrary: Handle<IfcLibraryInformation> | null)
	{
		this.Location = Location;
		this.Identification = Identification;
		this.Name = Name;
		this.Description = Description;
		this.Language = Language;
		this.ReferencedLibrary = ReferencedLibrary;
	}
	Location: IfcURIReference | null;
	Identification: IfcIdentifier | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	Language: IfcLanguageId | null;
	ReferencedLibrary: Handle<IfcLibraryInformation> | null;
	static FromTape(tape: any[]): IfcLibraryReference
	{
		let Location = tape[0];
		let Identification = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let Language = tape[4];
		let ReferencedLibrary = tape[5];
		return new IfcLibraryReference(Location, Identification, Name, Description, Language, ReferencedLibrary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Location){
		args.push(STRING)
		args.push(this.Location)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Language){
		}
		else{ args.push(EMPTY); }
		if(this.ReferencedLibrary){
		args.push(REF)
		args.push(this.ReferencedLibrary.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLightDistributionData {
	constructor(MainPlaneAngle: IfcPlaneAngleMeasure , SecondaryPlaneAngle: IfcPlaneAngleMeasure[] , LuminousIntensity: IfcLuminousIntensityDistributionMeasure[] )
	{
		this.MainPlaneAngle = MainPlaneAngle;
		this.SecondaryPlaneAngle = SecondaryPlaneAngle;
		this.LuminousIntensity = LuminousIntensity;
	}
	MainPlaneAngle: IfcPlaneAngleMeasure ;
	SecondaryPlaneAngle: IfcPlaneAngleMeasure[] ;
	LuminousIntensity: IfcLuminousIntensityDistributionMeasure[] ;
	static FromTape(tape: any[]): IfcLightDistributionData
	{
		let MainPlaneAngle = tape[0];
		let SecondaryPlaneAngle = tape[1];
		let LuminousIntensity = tape[2];
		return new IfcLightDistributionData(MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.MainPlaneAngle)
		args.push(REAL)
		args.push(...this.SecondaryPlaneAngle)
		args.push(REAL)
		args.push(...this.LuminousIntensity)
		return args;
	}
};
export class IfcLightFixture {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcLightFixtureTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcLightFixtureTypeEnum | null;
	static FromTape(tape: any[]): IfcLightFixture
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcLightFixture(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLightFixtureType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcLightFixtureTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcLightFixtureTypeEnum ;
	static FromTape(tape: any[]): IfcLightFixtureType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcLightFixtureType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLightIntensityDistribution {
	constructor(LightDistributionCurve: IfcLightDistributionCurveEnum , DistributionData: Handle<IfcLightDistributionData>[] )
	{
		this.LightDistributionCurve = LightDistributionCurve;
		this.DistributionData = DistributionData;
	}
	LightDistributionCurve: IfcLightDistributionCurveEnum ;
	DistributionData: Handle<IfcLightDistributionData>[] ;
	static FromTape(tape: any[]): IfcLightIntensityDistribution
	{
		let LightDistributionCurve = tape[0];
		let DistributionData = tape[1];
		return new IfcLightIntensityDistribution(LightDistributionCurve, DistributionData);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.DistributionData.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcLightSource {
	constructor(Name: IfcLabel | null, LightColour: Handle<IfcColourRgb> , AmbientIntensity: IfcNormalisedRatioMeasure | null, Intensity: IfcNormalisedRatioMeasure | null)
	{
		this.Name = Name;
		this.LightColour = LightColour;
		this.AmbientIntensity = AmbientIntensity;
		this.Intensity = Intensity;
	}
	Name: IfcLabel | null;
	LightColour: Handle<IfcColourRgb> ;
	AmbientIntensity: IfcNormalisedRatioMeasure | null;
	Intensity: IfcNormalisedRatioMeasure | null;
	static FromTape(tape: any[]): IfcLightSource
	{
		let Name = tape[0];
		let LightColour = tape[1];
		let AmbientIntensity = tape[2];
		let Intensity = tape[3];
		return new IfcLightSource(Name, LightColour, AmbientIntensity, Intensity);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LightColour.expressID)
		if(this.AmbientIntensity){
		}
		else{ args.push(EMPTY); }
		if(this.Intensity){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLightSourceAmbient {
	constructor(Name: IfcLabel | null, LightColour: Handle<IfcColourRgb> , AmbientIntensity: IfcNormalisedRatioMeasure | null, Intensity: IfcNormalisedRatioMeasure | null)
	{
		this.Name = Name;
		this.LightColour = LightColour;
		this.AmbientIntensity = AmbientIntensity;
		this.Intensity = Intensity;
	}
	Name: IfcLabel | null;
	LightColour: Handle<IfcColourRgb> ;
	AmbientIntensity: IfcNormalisedRatioMeasure | null;
	Intensity: IfcNormalisedRatioMeasure | null;
	static FromTape(tape: any[]): IfcLightSourceAmbient
	{
		let Name = tape[0];
		let LightColour = tape[1];
		let AmbientIntensity = tape[2];
		let Intensity = tape[3];
		return new IfcLightSourceAmbient(Name, LightColour, AmbientIntensity, Intensity);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LightColour.expressID)
		if(this.AmbientIntensity){
		}
		else{ args.push(EMPTY); }
		if(this.Intensity){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLightSourceDirectional {
	constructor(Name: IfcLabel | null, LightColour: Handle<IfcColourRgb> , AmbientIntensity: IfcNormalisedRatioMeasure | null, Intensity: IfcNormalisedRatioMeasure | null, Orientation: Handle<IfcDirection> )
	{
		this.Name = Name;
		this.LightColour = LightColour;
		this.AmbientIntensity = AmbientIntensity;
		this.Intensity = Intensity;
		this.Orientation = Orientation;
	}
	Name: IfcLabel | null;
	LightColour: Handle<IfcColourRgb> ;
	AmbientIntensity: IfcNormalisedRatioMeasure | null;
	Intensity: IfcNormalisedRatioMeasure | null;
	Orientation: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcLightSourceDirectional
	{
		let Name = tape[0];
		let LightColour = tape[1];
		let AmbientIntensity = tape[2];
		let Intensity = tape[3];
		let Orientation = tape[4];
		return new IfcLightSourceDirectional(Name, LightColour, AmbientIntensity, Intensity, Orientation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LightColour.expressID)
		if(this.AmbientIntensity){
		}
		else{ args.push(EMPTY); }
		if(this.Intensity){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Orientation.expressID)
		return args;
	}
};
export class IfcLightSourceGoniometric {
	constructor(Name: IfcLabel | null, LightColour: Handle<IfcColourRgb> , AmbientIntensity: IfcNormalisedRatioMeasure | null, Intensity: IfcNormalisedRatioMeasure | null, Position: Handle<IfcAxis2Placement3D> , ColourAppearance: Handle<IfcColourRgb> | null, ColourTemperature: IfcThermodynamicTemperatureMeasure , LuminousFlux: IfcLuminousFluxMeasure , LightEmissionSource: IfcLightEmissionSourceEnum , LightDistributionDataSource: IfcLightDistributionDataSourceSelect )
	{
		this.Name = Name;
		this.LightColour = LightColour;
		this.AmbientIntensity = AmbientIntensity;
		this.Intensity = Intensity;
		this.Position = Position;
		this.ColourAppearance = ColourAppearance;
		this.ColourTemperature = ColourTemperature;
		this.LuminousFlux = LuminousFlux;
		this.LightEmissionSource = LightEmissionSource;
		this.LightDistributionDataSource = LightDistributionDataSource;
	}
	Name: IfcLabel | null;
	LightColour: Handle<IfcColourRgb> ;
	AmbientIntensity: IfcNormalisedRatioMeasure | null;
	Intensity: IfcNormalisedRatioMeasure | null;
	Position: Handle<IfcAxis2Placement3D> ;
	ColourAppearance: Handle<IfcColourRgb> | null;
	ColourTemperature: IfcThermodynamicTemperatureMeasure ;
	LuminousFlux: IfcLuminousFluxMeasure ;
	LightEmissionSource: IfcLightEmissionSourceEnum ;
	LightDistributionDataSource: IfcLightDistributionDataSourceSelect ;
	static FromTape(tape: any[]): IfcLightSourceGoniometric
	{
		let Name = tape[0];
		let LightColour = tape[1];
		let AmbientIntensity = tape[2];
		let Intensity = tape[3];
		let Position = tape[4];
		let ColourAppearance = tape[5];
		let ColourTemperature = tape[6];
		let LuminousFlux = tape[7];
		let LightEmissionSource = tape[8];
		let LightDistributionDataSource = tape[9];
		return new IfcLightSourceGoniometric(Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LightColour.expressID)
		if(this.AmbientIntensity){
		}
		else{ args.push(EMPTY); }
		if(this.Intensity){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Position.expressID)
		if(this.ColourAppearance){
		args.push(REF)
		args.push(this.ColourAppearance.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.ColourTemperature)
		args.push(REAL)
		args.push(this.LuminousFlux)
		return args;
	}
};
export class IfcLightSourcePositional {
	constructor(Name: IfcLabel | null, LightColour: Handle<IfcColourRgb> , AmbientIntensity: IfcNormalisedRatioMeasure | null, Intensity: IfcNormalisedRatioMeasure | null, Position: Handle<IfcCartesianPoint> , Radius: IfcPositiveLengthMeasure , ConstantAttenuation: IfcReal , DistanceAttenuation: IfcReal , QuadricAttenuation: IfcReal )
	{
		this.Name = Name;
		this.LightColour = LightColour;
		this.AmbientIntensity = AmbientIntensity;
		this.Intensity = Intensity;
		this.Position = Position;
		this.Radius = Radius;
		this.ConstantAttenuation = ConstantAttenuation;
		this.DistanceAttenuation = DistanceAttenuation;
		this.QuadricAttenuation = QuadricAttenuation;
	}
	Name: IfcLabel | null;
	LightColour: Handle<IfcColourRgb> ;
	AmbientIntensity: IfcNormalisedRatioMeasure | null;
	Intensity: IfcNormalisedRatioMeasure | null;
	Position: Handle<IfcCartesianPoint> ;
	Radius: IfcPositiveLengthMeasure ;
	ConstantAttenuation: IfcReal ;
	DistanceAttenuation: IfcReal ;
	QuadricAttenuation: IfcReal ;
	static FromTape(tape: any[]): IfcLightSourcePositional
	{
		let Name = tape[0];
		let LightColour = tape[1];
		let AmbientIntensity = tape[2];
		let Intensity = tape[3];
		let Position = tape[4];
		let Radius = tape[5];
		let ConstantAttenuation = tape[6];
		let DistanceAttenuation = tape[7];
		let QuadricAttenuation = tape[8];
		return new IfcLightSourcePositional(Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LightColour.expressID)
		if(this.AmbientIntensity){
		}
		else{ args.push(EMPTY); }
		if(this.Intensity){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Position.expressID)
		args.push(REAL)
		args.push(this.ConstantAttenuation)
		args.push(REAL)
		args.push(this.DistanceAttenuation)
		args.push(REAL)
		args.push(this.QuadricAttenuation)
		return args;
	}
};
export class IfcLightSourceSpot {
	constructor(Name: IfcLabel | null, LightColour: Handle<IfcColourRgb> , AmbientIntensity: IfcNormalisedRatioMeasure | null, Intensity: IfcNormalisedRatioMeasure | null, Position: Handle<IfcCartesianPoint> , Radius: IfcPositiveLengthMeasure , ConstantAttenuation: IfcReal , DistanceAttenuation: IfcReal , QuadricAttenuation: IfcReal , Orientation: Handle<IfcDirection> , ConcentrationExponent: IfcReal | null, SpreadAngle: IfcPositivePlaneAngleMeasure , BeamWidthAngle: IfcPositivePlaneAngleMeasure )
	{
		this.Name = Name;
		this.LightColour = LightColour;
		this.AmbientIntensity = AmbientIntensity;
		this.Intensity = Intensity;
		this.Position = Position;
		this.Radius = Radius;
		this.ConstantAttenuation = ConstantAttenuation;
		this.DistanceAttenuation = DistanceAttenuation;
		this.QuadricAttenuation = QuadricAttenuation;
		this.Orientation = Orientation;
		this.ConcentrationExponent = ConcentrationExponent;
		this.SpreadAngle = SpreadAngle;
		this.BeamWidthAngle = BeamWidthAngle;
	}
	Name: IfcLabel | null;
	LightColour: Handle<IfcColourRgb> ;
	AmbientIntensity: IfcNormalisedRatioMeasure | null;
	Intensity: IfcNormalisedRatioMeasure | null;
	Position: Handle<IfcCartesianPoint> ;
	Radius: IfcPositiveLengthMeasure ;
	ConstantAttenuation: IfcReal ;
	DistanceAttenuation: IfcReal ;
	QuadricAttenuation: IfcReal ;
	Orientation: Handle<IfcDirection> ;
	ConcentrationExponent: IfcReal | null;
	SpreadAngle: IfcPositivePlaneAngleMeasure ;
	BeamWidthAngle: IfcPositivePlaneAngleMeasure ;
	static FromTape(tape: any[]): IfcLightSourceSpot
	{
		let Name = tape[0];
		let LightColour = tape[1];
		let AmbientIntensity = tape[2];
		let Intensity = tape[3];
		let Position = tape[4];
		let Radius = tape[5];
		let ConstantAttenuation = tape[6];
		let DistanceAttenuation = tape[7];
		let QuadricAttenuation = tape[8];
		let Orientation = tape[9];
		let ConcentrationExponent = tape[10];
		let SpreadAngle = tape[11];
		let BeamWidthAngle = tape[12];
		return new IfcLightSourceSpot(Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.LightColour.expressID)
		if(this.AmbientIntensity){
		}
		else{ args.push(EMPTY); }
		if(this.Intensity){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Position.expressID)
		args.push(REAL)
		args.push(this.ConstantAttenuation)
		args.push(REAL)
		args.push(this.DistanceAttenuation)
		args.push(REAL)
		args.push(this.QuadricAttenuation)
		args.push(REF)
		args.push(this.Orientation.expressID)
		if(this.ConcentrationExponent){
		args.push(REAL)
		args.push(this.ConcentrationExponent)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLine {
	constructor(Pnt: Handle<IfcCartesianPoint> , Dir: Handle<IfcVector> )
	{
		this.Pnt = Pnt;
		this.Dir = Dir;
	}
	Pnt: Handle<IfcCartesianPoint> ;
	Dir: Handle<IfcVector> ;
	static FromTape(tape: any[]): IfcLine
	{
		let Pnt = tape[0];
		let Dir = tape[1];
		return new IfcLine(Pnt, Dir);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Pnt.expressID)
		args.push(REF)
		args.push(this.Dir.expressID)
		return args;
	}
};
export class IfcLineSegment2D {
	constructor(StartPoint: Handle<IfcCartesianPoint> , StartDirection: IfcPlaneAngleMeasure , SegmentLength: IfcPositiveLengthMeasure )
	{
		this.StartPoint = StartPoint;
		this.StartDirection = StartDirection;
		this.SegmentLength = SegmentLength;
	}
	StartPoint: Handle<IfcCartesianPoint> ;
	StartDirection: IfcPlaneAngleMeasure ;
	SegmentLength: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcLineSegment2D
	{
		let StartPoint = tape[0];
		let StartDirection = tape[1];
		let SegmentLength = tape[2];
		return new IfcLineSegment2D(StartPoint, StartDirection, SegmentLength);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.StartPoint.expressID)
		args.push(REAL)
		args.push(this.StartDirection)
		return args;
	}
};
export class IfcLinearPlacement {
	constructor(PlacementRelTo: Handle<IfcObjectPlacement> | null, PlacementMeasuredAlong: Handle<IfcCurve> , Distance: Handle<IfcDistanceExpression> , Orientation: Handle<IfcOrientationExpression> | null, CartesianPosition: Handle<IfcAxis2Placement3D> | null)
	{
		this.PlacementRelTo = PlacementRelTo;
		this.PlacementMeasuredAlong = PlacementMeasuredAlong;
		this.Distance = Distance;
		this.Orientation = Orientation;
		this.CartesianPosition = CartesianPosition;
	}
	PlacementRelTo: Handle<IfcObjectPlacement> | null;
	PlacementMeasuredAlong: Handle<IfcCurve> ;
	Distance: Handle<IfcDistanceExpression> ;
	Orientation: Handle<IfcOrientationExpression> | null;
	CartesianPosition: Handle<IfcAxis2Placement3D> | null;
	static FromTape(tape: any[]): IfcLinearPlacement
	{
		let PlacementRelTo = tape[0];
		let PlacementMeasuredAlong = tape[1];
		let Distance = tape[2];
		let Orientation = tape[3];
		let CartesianPosition = tape[4];
		return new IfcLinearPlacement(PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.PlacementRelTo){
		args.push(REF)
		args.push(this.PlacementRelTo.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.PlacementMeasuredAlong.expressID)
		args.push(REF)
		args.push(this.Distance.expressID)
		if(this.Orientation){
		args.push(REF)
		args.push(this.Orientation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.CartesianPosition){
		args.push(REF)
		args.push(this.CartesianPosition.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLinearPositioningElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Axis: Handle<IfcCurve> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Axis = Axis;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Axis: Handle<IfcCurve> ;
	static FromTape(tape: any[]): IfcLinearPositioningElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Axis = tape[7];
		return new IfcLinearPositioningElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		return args;
	}
};
export class IfcLocalPlacement {
	constructor(PlacementRelTo: Handle<IfcObjectPlacement> | null, RelativePlacement: IfcAxis2Placement )
	{
		this.PlacementRelTo = PlacementRelTo;
		this.RelativePlacement = RelativePlacement;
	}
	PlacementRelTo: Handle<IfcObjectPlacement> | null;
	RelativePlacement: IfcAxis2Placement ;
	static FromTape(tape: any[]): IfcLocalPlacement
	{
		let PlacementRelTo = tape[0];
		let RelativePlacement = tape[1];
		return new IfcLocalPlacement(PlacementRelTo, RelativePlacement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.PlacementRelTo){
		args.push(REF)
		args.push(this.PlacementRelTo.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcLoop {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcLoop
	{
		return new IfcLoop();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcManifoldSolidBrep {
	constructor(Outer: Handle<IfcClosedShell> )
	{
		this.Outer = Outer;
	}
	Outer: Handle<IfcClosedShell> ;
	static FromTape(tape: any[]): IfcManifoldSolidBrep
	{
		let Outer = tape[0];
		return new IfcManifoldSolidBrep(Outer);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Outer.expressID)
		return args;
	}
};
export class IfcMapConversion {
	constructor(SourceCRS: IfcCoordinateReferenceSystemSelect , TargetCRS: Handle<IfcCoordinateReferenceSystem> , Eastings: IfcLengthMeasure , Northings: IfcLengthMeasure , OrthogonalHeight: IfcLengthMeasure , XAxisAbscissa: IfcReal | null, XAxisOrdinate: IfcReal | null, Scale: IfcReal | null)
	{
		this.SourceCRS = SourceCRS;
		this.TargetCRS = TargetCRS;
		this.Eastings = Eastings;
		this.Northings = Northings;
		this.OrthogonalHeight = OrthogonalHeight;
		this.XAxisAbscissa = XAxisAbscissa;
		this.XAxisOrdinate = XAxisOrdinate;
		this.Scale = Scale;
	}
	SourceCRS: IfcCoordinateReferenceSystemSelect ;
	TargetCRS: Handle<IfcCoordinateReferenceSystem> ;
	Eastings: IfcLengthMeasure ;
	Northings: IfcLengthMeasure ;
	OrthogonalHeight: IfcLengthMeasure ;
	XAxisAbscissa: IfcReal | null;
	XAxisOrdinate: IfcReal | null;
	Scale: IfcReal | null;
	static FromTape(tape: any[]): IfcMapConversion
	{
		let SourceCRS = tape[0];
		let TargetCRS = tape[1];
		let Eastings = tape[2];
		let Northings = tape[3];
		let OrthogonalHeight = tape[4];
		let XAxisAbscissa = tape[5];
		let XAxisOrdinate = tape[6];
		let Scale = tape[7];
		return new IfcMapConversion(SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.TargetCRS.expressID)
		args.push(REAL)
		args.push(this.Eastings)
		args.push(REAL)
		args.push(this.Northings)
		args.push(REAL)
		args.push(this.OrthogonalHeight)
		if(this.XAxisAbscissa){
		args.push(REAL)
		args.push(this.XAxisAbscissa)
		}
		else{ args.push(EMPTY); }
		if(this.XAxisOrdinate){
		args.push(REAL)
		args.push(this.XAxisOrdinate)
		}
		else{ args.push(EMPTY); }
		if(this.Scale){
		args.push(REAL)
		args.push(this.Scale)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMappedItem {
	constructor(MappingSource: Handle<IfcRepresentationMap> , MappingTarget: Handle<IfcCartesianTransformationOperator> )
	{
		this.MappingSource = MappingSource;
		this.MappingTarget = MappingTarget;
	}
	MappingSource: Handle<IfcRepresentationMap> ;
	MappingTarget: Handle<IfcCartesianTransformationOperator> ;
	static FromTape(tape: any[]): IfcMappedItem
	{
		let MappingSource = tape[0];
		let MappingTarget = tape[1];
		return new IfcMappedItem(MappingSource, MappingTarget);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.MappingSource.expressID)
		args.push(REF)
		args.push(this.MappingTarget.expressID)
		return args;
	}
};
export class IfcMaterial {
	constructor(Name: IfcLabel , Description: IfcText | null, Category: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Category = Category;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Category: IfcLabel | null;
	static FromTape(tape: any[]): IfcMaterial
	{
		let Name = tape[0];
		let Description = tape[1];
		let Category = tape[2];
		return new IfcMaterial(Name, Description, Category);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialClassificationRelationship {
	constructor(MaterialClassifications: IfcClassificationSelect[] , ClassifiedMaterial: Handle<IfcMaterial> )
	{
		this.MaterialClassifications = MaterialClassifications;
		this.ClassifiedMaterial = ClassifiedMaterial;
	}
	MaterialClassifications: IfcClassificationSelect[] ;
	ClassifiedMaterial: Handle<IfcMaterial> ;
	static FromTape(tape: any[]): IfcMaterialClassificationRelationship
	{
		let MaterialClassifications = tape[0];
		let ClassifiedMaterial = tape[1];
		return new IfcMaterialClassificationRelationship(MaterialClassifications, ClassifiedMaterial);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ClassifiedMaterial.expressID)
		return args;
	}
};
export class IfcMaterialConstituent {
	constructor(Name: IfcLabel | null, Description: IfcText | null, Material: Handle<IfcMaterial> , Fraction: IfcNormalisedRatioMeasure | null, Category: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Material = Material;
		this.Fraction = Fraction;
		this.Category = Category;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	Material: Handle<IfcMaterial> ;
	Fraction: IfcNormalisedRatioMeasure | null;
	Category: IfcLabel | null;
	static FromTape(tape: any[]): IfcMaterialConstituent
	{
		let Name = tape[0];
		let Description = tape[1];
		let Material = tape[2];
		let Fraction = tape[3];
		let Category = tape[4];
		return new IfcMaterialConstituent(Name, Description, Material, Fraction, Category);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Material.expressID)
		if(this.Fraction){
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialConstituentSet {
	constructor(Name: IfcLabel | null, Description: IfcText | null, MaterialConstituents: Handle<IfcMaterialConstituent>[] | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.MaterialConstituents = MaterialConstituents;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	MaterialConstituents: Handle<IfcMaterialConstituent>[] | null;
	static FromTape(tape: any[]): IfcMaterialConstituentSet
	{
		let Name = tape[0];
		let Description = tape[1];
		let MaterialConstituents = tape[2];
		return new IfcMaterialConstituentSet(Name, Description, MaterialConstituents);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.MaterialConstituents){
		args.push(SET_BEGIN)
		this.MaterialConstituents.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialDefinition {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcMaterialDefinition
	{
		return new IfcMaterialDefinition();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcMaterialDefinitionRepresentation {
	constructor(Name: IfcLabel | null, Description: IfcText | null, Representations: Handle<IfcRepresentation>[] , RepresentedMaterial: Handle<IfcMaterial> )
	{
		this.Name = Name;
		this.Description = Description;
		this.Representations = Representations;
		this.RepresentedMaterial = RepresentedMaterial;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	Representations: Handle<IfcRepresentation>[] ;
	RepresentedMaterial: Handle<IfcMaterial> ;
	static FromTape(tape: any[]): IfcMaterialDefinitionRepresentation
	{
		let Name = tape[0];
		let Description = tape[1];
		let Representations = tape[2];
		let RepresentedMaterial = tape[3];
		return new IfcMaterialDefinitionRepresentation(Name, Description, Representations, RepresentedMaterial);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Representations.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RepresentedMaterial.expressID)
		return args;
	}
};
export class IfcMaterialLayer {
	constructor(Material: Handle<IfcMaterial> | null, LayerThickness: IfcNonNegativeLengthMeasure , IsVentilated: IfcLogical | null, Name: IfcLabel | null, Description: IfcText | null, Category: IfcLabel | null, Priority: IfcInteger | null)
	{
		this.Material = Material;
		this.LayerThickness = LayerThickness;
		this.IsVentilated = IsVentilated;
		this.Name = Name;
		this.Description = Description;
		this.Category = Category;
		this.Priority = Priority;
	}
	Material: Handle<IfcMaterial> | null;
	LayerThickness: IfcNonNegativeLengthMeasure ;
	IsVentilated: IfcLogical | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	Category: IfcLabel | null;
	Priority: IfcInteger | null;
	static FromTape(tape: any[]): IfcMaterialLayer
	{
		let Material = tape[0];
		let LayerThickness = tape[1];
		let IsVentilated = tape[2];
		let Name = tape[3];
		let Description = tape[4];
		let Category = tape[5];
		let Priority = tape[6];
		return new IfcMaterialLayer(Material, LayerThickness, IsVentilated, Name, Description, Category, Priority);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Material){
		args.push(REF)
		args.push(this.Material.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.IsVentilated){
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		if(this.Priority){
		args.push(REAL)
		args.push(this.Priority)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialLayerSet {
	constructor(MaterialLayers: Handle<IfcMaterialLayer>[] , LayerSetName: IfcLabel | null, Description: IfcText | null)
	{
		this.MaterialLayers = MaterialLayers;
		this.LayerSetName = LayerSetName;
		this.Description = Description;
	}
	MaterialLayers: Handle<IfcMaterialLayer>[] ;
	LayerSetName: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcMaterialLayerSet
	{
		let MaterialLayers = tape[0];
		let LayerSetName = tape[1];
		let Description = tape[2];
		return new IfcMaterialLayerSet(MaterialLayers, LayerSetName, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.MaterialLayers.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.LayerSetName){
		args.push(STRING)
		args.push(this.LayerSetName)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialLayerSetUsage {
	constructor(ForLayerSet: Handle<IfcMaterialLayerSet> , LayerSetDirection: IfcLayerSetDirectionEnum , DirectionSense: IfcDirectionSenseEnum , OffsetFromReferenceLine: IfcLengthMeasure , ReferenceExtent: IfcPositiveLengthMeasure | null)
	{
		this.ForLayerSet = ForLayerSet;
		this.LayerSetDirection = LayerSetDirection;
		this.DirectionSense = DirectionSense;
		this.OffsetFromReferenceLine = OffsetFromReferenceLine;
		this.ReferenceExtent = ReferenceExtent;
	}
	ForLayerSet: Handle<IfcMaterialLayerSet> ;
	LayerSetDirection: IfcLayerSetDirectionEnum ;
	DirectionSense: IfcDirectionSenseEnum ;
	OffsetFromReferenceLine: IfcLengthMeasure ;
	ReferenceExtent: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcMaterialLayerSetUsage
	{
		let ForLayerSet = tape[0];
		let LayerSetDirection = tape[1];
		let DirectionSense = tape[2];
		let OffsetFromReferenceLine = tape[3];
		let ReferenceExtent = tape[4];
		return new IfcMaterialLayerSetUsage(ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ForLayerSet.expressID)
		args.push(REAL)
		args.push(this.OffsetFromReferenceLine)
		if(this.ReferenceExtent){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialLayerWithOffsets {
	constructor(Material: Handle<IfcMaterial> | null, LayerThickness: IfcNonNegativeLengthMeasure , IsVentilated: IfcLogical | null, Name: IfcLabel | null, Description: IfcText | null, Category: IfcLabel | null, Priority: IfcInteger | null, OffsetDirection: IfcLayerSetDirectionEnum , OffsetValues: IfcLengthMeasure )
	{
		this.Material = Material;
		this.LayerThickness = LayerThickness;
		this.IsVentilated = IsVentilated;
		this.Name = Name;
		this.Description = Description;
		this.Category = Category;
		this.Priority = Priority;
		this.OffsetDirection = OffsetDirection;
		this.OffsetValues = OffsetValues;
	}
	Material: Handle<IfcMaterial> | null;
	LayerThickness: IfcNonNegativeLengthMeasure ;
	IsVentilated: IfcLogical | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	Category: IfcLabel | null;
	Priority: IfcInteger | null;
	OffsetDirection: IfcLayerSetDirectionEnum ;
	OffsetValues: IfcLengthMeasure ;
	static FromTape(tape: any[]): IfcMaterialLayerWithOffsets
	{
		let Material = tape[0];
		let LayerThickness = tape[1];
		let IsVentilated = tape[2];
		let Name = tape[3];
		let Description = tape[4];
		let Category = tape[5];
		let Priority = tape[6];
		let OffsetDirection = tape[7];
		let OffsetValues = tape[8];
		return new IfcMaterialLayerWithOffsets(Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Material){
		args.push(REF)
		args.push(this.Material.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.IsVentilated){
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		if(this.Priority){
		args.push(REAL)
		args.push(this.Priority)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.OffsetValues)
		return args;
	}
};
export class IfcMaterialList {
	constructor(Materials: Handle<IfcMaterial>[] )
	{
		this.Materials = Materials;
	}
	Materials: Handle<IfcMaterial>[] ;
	static FromTape(tape: any[]): IfcMaterialList
	{
		let Materials = tape[0];
		return new IfcMaterialList(Materials);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Materials.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcMaterialProfile {
	constructor(Name: IfcLabel | null, Description: IfcText | null, Material: Handle<IfcMaterial> | null, Profile: Handle<IfcProfileDef> , Priority: IfcInteger | null, Category: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Material = Material;
		this.Profile = Profile;
		this.Priority = Priority;
		this.Category = Category;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	Material: Handle<IfcMaterial> | null;
	Profile: Handle<IfcProfileDef> ;
	Priority: IfcInteger | null;
	Category: IfcLabel | null;
	static FromTape(tape: any[]): IfcMaterialProfile
	{
		let Name = tape[0];
		let Description = tape[1];
		let Material = tape[2];
		let Profile = tape[3];
		let Priority = tape[4];
		let Category = tape[5];
		return new IfcMaterialProfile(Name, Description, Material, Profile, Priority, Category);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Material){
		args.push(REF)
		args.push(this.Material.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Profile.expressID)
		if(this.Priority){
		args.push(REAL)
		args.push(this.Priority)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialProfileSet {
	constructor(Name: IfcLabel | null, Description: IfcText | null, MaterialProfiles: Handle<IfcMaterialProfile>[] , CompositeProfile: Handle<IfcCompositeProfileDef> | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.MaterialProfiles = MaterialProfiles;
		this.CompositeProfile = CompositeProfile;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	MaterialProfiles: Handle<IfcMaterialProfile>[] ;
	CompositeProfile: Handle<IfcCompositeProfileDef> | null;
	static FromTape(tape: any[]): IfcMaterialProfileSet
	{
		let Name = tape[0];
		let Description = tape[1];
		let MaterialProfiles = tape[2];
		let CompositeProfile = tape[3];
		return new IfcMaterialProfileSet(Name, Description, MaterialProfiles, CompositeProfile);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.MaterialProfiles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.CompositeProfile){
		args.push(REF)
		args.push(this.CompositeProfile.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialProfileSetUsage {
	constructor(ForProfileSet: Handle<IfcMaterialProfileSet> , CardinalPoint: IfcCardinalPointReference | null, ReferenceExtent: IfcPositiveLengthMeasure | null)
	{
		this.ForProfileSet = ForProfileSet;
		this.CardinalPoint = CardinalPoint;
		this.ReferenceExtent = ReferenceExtent;
	}
	ForProfileSet: Handle<IfcMaterialProfileSet> ;
	CardinalPoint: IfcCardinalPointReference | null;
	ReferenceExtent: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcMaterialProfileSetUsage
	{
		let ForProfileSet = tape[0];
		let CardinalPoint = tape[1];
		let ReferenceExtent = tape[2];
		return new IfcMaterialProfileSetUsage(ForProfileSet, CardinalPoint, ReferenceExtent);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ForProfileSet.expressID)
		if(this.CardinalPoint){
		args.push(REAL)
		args.push(this.CardinalPoint)
		}
		else{ args.push(EMPTY); }
		if(this.ReferenceExtent){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialProfileSetUsageTapering {
	constructor(ForProfileSet: Handle<IfcMaterialProfileSet> , CardinalPoint: IfcCardinalPointReference | null, ReferenceExtent: IfcPositiveLengthMeasure | null, ForProfileEndSet: Handle<IfcMaterialProfileSet> , CardinalEndPoint: IfcCardinalPointReference | null)
	{
		this.ForProfileSet = ForProfileSet;
		this.CardinalPoint = CardinalPoint;
		this.ReferenceExtent = ReferenceExtent;
		this.ForProfileEndSet = ForProfileEndSet;
		this.CardinalEndPoint = CardinalEndPoint;
	}
	ForProfileSet: Handle<IfcMaterialProfileSet> ;
	CardinalPoint: IfcCardinalPointReference | null;
	ReferenceExtent: IfcPositiveLengthMeasure | null;
	ForProfileEndSet: Handle<IfcMaterialProfileSet> ;
	CardinalEndPoint: IfcCardinalPointReference | null;
	static FromTape(tape: any[]): IfcMaterialProfileSetUsageTapering
	{
		let ForProfileSet = tape[0];
		let CardinalPoint = tape[1];
		let ReferenceExtent = tape[2];
		let ForProfileEndSet = tape[3];
		let CardinalEndPoint = tape[4];
		return new IfcMaterialProfileSetUsageTapering(ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ForProfileSet.expressID)
		if(this.CardinalPoint){
		args.push(REAL)
		args.push(this.CardinalPoint)
		}
		else{ args.push(EMPTY); }
		if(this.ReferenceExtent){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ForProfileEndSet.expressID)
		if(this.CardinalEndPoint){
		args.push(REAL)
		args.push(this.CardinalEndPoint)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialProfileWithOffsets {
	constructor(Name: IfcLabel | null, Description: IfcText | null, Material: Handle<IfcMaterial> | null, Profile: Handle<IfcProfileDef> , Priority: IfcInteger | null, Category: IfcLabel | null, OffsetValues: IfcLengthMeasure )
	{
		this.Name = Name;
		this.Description = Description;
		this.Material = Material;
		this.Profile = Profile;
		this.Priority = Priority;
		this.Category = Category;
		this.OffsetValues = OffsetValues;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	Material: Handle<IfcMaterial> | null;
	Profile: Handle<IfcProfileDef> ;
	Priority: IfcInteger | null;
	Category: IfcLabel | null;
	OffsetValues: IfcLengthMeasure ;
	static FromTape(tape: any[]): IfcMaterialProfileWithOffsets
	{
		let Name = tape[0];
		let Description = tape[1];
		let Material = tape[2];
		let Profile = tape[3];
		let Priority = tape[4];
		let Category = tape[5];
		let OffsetValues = tape[6];
		return new IfcMaterialProfileWithOffsets(Name, Description, Material, Profile, Priority, Category, OffsetValues);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Material){
		args.push(REF)
		args.push(this.Material.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Profile.expressID)
		if(this.Priority){
		args.push(REAL)
		args.push(this.Priority)
		}
		else{ args.push(EMPTY); }
		if(this.Category){
		args.push(STRING)
		args.push(this.Category)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.OffsetValues)
		return args;
	}
};
export class IfcMaterialProperties {
	constructor(Name: IfcIdentifier | null, Description: IfcText | null, Properties: Handle<IfcProperty>[] , Material: Handle<IfcMaterialDefinition> )
	{
		this.Name = Name;
		this.Description = Description;
		this.Properties = Properties;
		this.Material = Material;
	}
	Name: IfcIdentifier | null;
	Description: IfcText | null;
	Properties: Handle<IfcProperty>[] ;
	Material: Handle<IfcMaterialDefinition> ;
	static FromTape(tape: any[]): IfcMaterialProperties
	{
		let Name = tape[0];
		let Description = tape[1];
		let Properties = tape[2];
		let Material = tape[3];
		return new IfcMaterialProperties(Name, Description, Properties, Material);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Properties.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.Material.expressID)
		return args;
	}
};
export class IfcMaterialRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingMaterial: Handle<IfcMaterial> , RelatedMaterials: Handle<IfcMaterial>[] , Expression: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingMaterial = RelatingMaterial;
		this.RelatedMaterials = RelatedMaterials;
		this.Expression = Expression;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingMaterial: Handle<IfcMaterial> ;
	RelatedMaterials: Handle<IfcMaterial>[] ;
	Expression: IfcLabel | null;
	static FromTape(tape: any[]): IfcMaterialRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingMaterial = tape[2];
		let RelatedMaterials = tape[3];
		let Expression = tape[4];
		return new IfcMaterialRelationship(Name, Description, RelatingMaterial, RelatedMaterials, Expression);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingMaterial.expressID)
		args.push(SET_BEGIN)
		this.RelatedMaterials.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.Expression){
		args.push(STRING)
		args.push(this.Expression)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMaterialUsageDefinition {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcMaterialUsageDefinition
	{
		return new IfcMaterialUsageDefinition();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcMeasureWithUnit {
	constructor(ValueComponent: IfcValue , UnitComponent: IfcUnit )
	{
		this.ValueComponent = ValueComponent;
		this.UnitComponent = UnitComponent;
	}
	ValueComponent: IfcValue ;
	UnitComponent: IfcUnit ;
	static FromTape(tape: any[]): IfcMeasureWithUnit
	{
		let ValueComponent = { t: tape[0], v: tape[1][0]} as any;
		let UnitComponent = tape[2];
		return new IfcMeasureWithUnit(ValueComponent, UnitComponent);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(LABEL)
		//@ts-ignore
		args.push(this.ValueComponent.t)
		args.push(SET_BEGIN)
		args.push(STRING)
		//@ts-ignore
		args.push(this.ValueComponent.v)
		args.push(SET_END)
		return args;
	}
};
export class IfcMechanicalFastener {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, NominalDiameter: IfcPositiveLengthMeasure | null, NominalLength: IfcPositiveLengthMeasure | null, PredefinedType: IfcMechanicalFastenerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.NominalDiameter = NominalDiameter;
		this.NominalLength = NominalLength;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	NominalDiameter: IfcPositiveLengthMeasure | null;
	NominalLength: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcMechanicalFastenerTypeEnum | null;
	static FromTape(tape: any[]): IfcMechanicalFastener
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let NominalDiameter = tape[8];
		let NominalLength = tape[9];
		let PredefinedType = tape[10];
		return new IfcMechanicalFastener(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.NominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.NominalLength){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMechanicalFastenerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcMechanicalFastenerTypeEnum , NominalDiameter: IfcPositiveLengthMeasure | null, NominalLength: IfcPositiveLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.NominalDiameter = NominalDiameter;
		this.NominalLength = NominalLength;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcMechanicalFastenerTypeEnum ;
	NominalDiameter: IfcPositiveLengthMeasure | null;
	NominalLength: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcMechanicalFastenerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let NominalDiameter = tape[10];
		let NominalLength = tape[11];
		return new IfcMechanicalFastenerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.NominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.NominalLength){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMedicalDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcMedicalDeviceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcMedicalDeviceTypeEnum | null;
	static FromTape(tape: any[]): IfcMedicalDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcMedicalDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMedicalDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcMedicalDeviceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcMedicalDeviceTypeEnum ;
	static FromTape(tape: any[]): IfcMedicalDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcMedicalDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMember {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcMemberTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcMemberTypeEnum | null;
	static FromTape(tape: any[]): IfcMember
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcMember(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMemberStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcMemberTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcMemberTypeEnum | null;
	static FromTape(tape: any[]): IfcMemberStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcMemberStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMemberType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcMemberTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcMemberTypeEnum ;
	static FromTape(tape: any[]): IfcMemberType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcMemberType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMetric {
	constructor(Name: IfcLabel , Description: IfcText | null, ConstraintGrade: IfcConstraintEnum , ConstraintSource: IfcLabel | null, CreatingActor: IfcActorSelect | null, CreationTime: IfcDateTime | null, UserDefinedGrade: IfcLabel | null, Benchmark: IfcBenchmarkEnum , ValueSource: IfcLabel | null, DataValue: IfcMetricValueSelect | null, ReferencePath: Handle<IfcReference> | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.ConstraintGrade = ConstraintGrade;
		this.ConstraintSource = ConstraintSource;
		this.CreatingActor = CreatingActor;
		this.CreationTime = CreationTime;
		this.UserDefinedGrade = UserDefinedGrade;
		this.Benchmark = Benchmark;
		this.ValueSource = ValueSource;
		this.DataValue = DataValue;
		this.ReferencePath = ReferencePath;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	ConstraintGrade: IfcConstraintEnum ;
	ConstraintSource: IfcLabel | null;
	CreatingActor: IfcActorSelect | null;
	CreationTime: IfcDateTime | null;
	UserDefinedGrade: IfcLabel | null;
	Benchmark: IfcBenchmarkEnum ;
	ValueSource: IfcLabel | null;
	DataValue: IfcMetricValueSelect | null;
	ReferencePath: Handle<IfcReference> | null;
	static FromTape(tape: any[]): IfcMetric
	{
		let Name = tape[0];
		let Description = tape[1];
		let ConstraintGrade = tape[2];
		let ConstraintSource = tape[3];
		let CreatingActor = tape[4];
		let CreationTime = tape[5];
		let UserDefinedGrade = tape[6];
		let Benchmark = tape[7];
		let ValueSource = tape[8];
		let DataValue = tape[9];
		let ReferencePath = tape[10];
		return new IfcMetric(Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ConstraintSource){
		args.push(STRING)
		args.push(this.ConstraintSource)
		}
		else{ args.push(EMPTY); }
		if(this.CreatingActor){
		}
		else{ args.push(EMPTY); }
		if(this.CreationTime){
		args.push(STRING)
		args.push(this.CreationTime)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedGrade){
		args.push(STRING)
		args.push(this.UserDefinedGrade)
		}
		else{ args.push(EMPTY); }
		if(this.ValueSource){
		args.push(STRING)
		args.push(this.ValueSource)
		}
		else{ args.push(EMPTY); }
		if(this.DataValue){
		}
		else{ args.push(EMPTY); }
		if(this.ReferencePath){
		args.push(REF)
		args.push(this.ReferencePath.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMirroredProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, ParentProfile: Handle<IfcProfileDef> , Operator: Handle<IfcCartesianTransformationOperator2D> , Label: IfcLabel | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.ParentProfile = ParentProfile;
		this.Operator = Operator;
		this.Label = Label;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	ParentProfile: Handle<IfcProfileDef> ;
	Operator: Handle<IfcCartesianTransformationOperator2D> ;
	Label: IfcLabel | null;
	static FromTape(tape: any[]): IfcMirroredProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let ParentProfile = tape[2];
		let Operator = tape[3];
		let Label = tape[4];
		return new IfcMirroredProfileDef(ProfileType, ProfileName, ParentProfile, Operator, Label);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ParentProfile.expressID)
		args.push(REF)
		args.push(this.Operator.expressID)
		if(this.Label){
		args.push(STRING)
		args.push(this.Label)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMonetaryUnit {
	constructor(Currency: IfcLabel )
	{
		this.Currency = Currency;
	}
	Currency: IfcLabel ;
	static FromTape(tape: any[]): IfcMonetaryUnit
	{
		let Currency = tape[0];
		return new IfcMonetaryUnit(Currency);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Currency)
		return args;
	}
};
export class IfcMotorConnection {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcMotorConnectionTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcMotorConnectionTypeEnum | null;
	static FromTape(tape: any[]): IfcMotorConnection
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcMotorConnection(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcMotorConnectionType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcMotorConnectionTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcMotorConnectionTypeEnum ;
	static FromTape(tape: any[]): IfcMotorConnectionType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcMotorConnectionType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcNamedUnit {
	constructor(Dimensions: Handle<IfcDimensionalExponents> , UnitType: IfcUnitEnum )
	{
		this.Dimensions = Dimensions;
		this.UnitType = UnitType;
	}
	Dimensions: Handle<IfcDimensionalExponents> ;
	UnitType: IfcUnitEnum ;
	static FromTape(tape: any[]): IfcNamedUnit
	{
		let Dimensions = tape[0];
		let UnitType = tape[1];
		return new IfcNamedUnit(Dimensions, UnitType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Dimensions.expressID)
		return args;
	}
};
export class IfcObject {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	static FromTape(tape: any[]): IfcObject
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		return new IfcObject(GlobalId, OwnerHistory, Name, Description, ObjectType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcObjectDefinition {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcObjectDefinition
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcObjectDefinition(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcObjectPlacement {
	constructor(PlacementRelTo: Handle<IfcObjectPlacement> | null)
	{
		this.PlacementRelTo = PlacementRelTo;
	}
	PlacementRelTo: Handle<IfcObjectPlacement> | null;
	static FromTape(tape: any[]): IfcObjectPlacement
	{
		let PlacementRelTo = tape[0];
		return new IfcObjectPlacement(PlacementRelTo);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.PlacementRelTo){
		args.push(REF)
		args.push(this.PlacementRelTo.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcObjective {
	constructor(Name: IfcLabel , Description: IfcText | null, ConstraintGrade: IfcConstraintEnum , ConstraintSource: IfcLabel | null, CreatingActor: IfcActorSelect | null, CreationTime: IfcDateTime | null, UserDefinedGrade: IfcLabel | null, BenchmarkValues: Handle<IfcConstraint>[] | null, LogicalAggregator: IfcLogicalOperatorEnum | null, ObjectiveQualifier: IfcObjectiveEnum , UserDefinedQualifier: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.ConstraintGrade = ConstraintGrade;
		this.ConstraintSource = ConstraintSource;
		this.CreatingActor = CreatingActor;
		this.CreationTime = CreationTime;
		this.UserDefinedGrade = UserDefinedGrade;
		this.BenchmarkValues = BenchmarkValues;
		this.LogicalAggregator = LogicalAggregator;
		this.ObjectiveQualifier = ObjectiveQualifier;
		this.UserDefinedQualifier = UserDefinedQualifier;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	ConstraintGrade: IfcConstraintEnum ;
	ConstraintSource: IfcLabel | null;
	CreatingActor: IfcActorSelect | null;
	CreationTime: IfcDateTime | null;
	UserDefinedGrade: IfcLabel | null;
	BenchmarkValues: Handle<IfcConstraint>[] | null;
	LogicalAggregator: IfcLogicalOperatorEnum | null;
	ObjectiveQualifier: IfcObjectiveEnum ;
	UserDefinedQualifier: IfcLabel | null;
	static FromTape(tape: any[]): IfcObjective
	{
		let Name = tape[0];
		let Description = tape[1];
		let ConstraintGrade = tape[2];
		let ConstraintSource = tape[3];
		let CreatingActor = tape[4];
		let CreationTime = tape[5];
		let UserDefinedGrade = tape[6];
		let BenchmarkValues = tape[7];
		let LogicalAggregator = tape[8];
		let ObjectiveQualifier = tape[9];
		let UserDefinedQualifier = tape[10];
		return new IfcObjective(Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ConstraintSource){
		args.push(STRING)
		args.push(this.ConstraintSource)
		}
		else{ args.push(EMPTY); }
		if(this.CreatingActor){
		}
		else{ args.push(EMPTY); }
		if(this.CreationTime){
		args.push(STRING)
		args.push(this.CreationTime)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedGrade){
		args.push(STRING)
		args.push(this.UserDefinedGrade)
		}
		else{ args.push(EMPTY); }
		if(this.BenchmarkValues){
		args.push(SET_BEGIN)
		this.BenchmarkValues.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.LogicalAggregator){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedQualifier){
		args.push(STRING)
		args.push(this.UserDefinedQualifier)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOccupant {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, TheActor: IfcActorSelect , PredefinedType: IfcOccupantTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.TheActor = TheActor;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	TheActor: IfcActorSelect ;
	PredefinedType: IfcOccupantTypeEnum | null;
	static FromTape(tape: any[]): IfcOccupant
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let TheActor = tape[5];
		let PredefinedType = tape[6];
		return new IfcOccupant(GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOffsetCurve {
	constructor(BasisCurve: Handle<IfcCurve> )
	{
		this.BasisCurve = BasisCurve;
	}
	BasisCurve: Handle<IfcCurve> ;
	static FromTape(tape: any[]): IfcOffsetCurve
	{
		let BasisCurve = tape[0];
		return new IfcOffsetCurve(BasisCurve);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisCurve.expressID)
		return args;
	}
};
export class IfcOffsetCurve2D {
	constructor(BasisCurve: Handle<IfcCurve> , Distance: IfcLengthMeasure , SelfIntersect: IfcLogical )
	{
		this.BasisCurve = BasisCurve;
		this.Distance = Distance;
		this.SelfIntersect = SelfIntersect;
	}
	BasisCurve: Handle<IfcCurve> ;
	Distance: IfcLengthMeasure ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcOffsetCurve2D
	{
		let BasisCurve = tape[0];
		let Distance = tape[1];
		let SelfIntersect = tape[2];
		return new IfcOffsetCurve2D(BasisCurve, Distance, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisCurve.expressID)
		args.push(REAL)
		args.push(this.Distance)
		return args;
	}
};
export class IfcOffsetCurve3D {
	constructor(BasisCurve: Handle<IfcCurve> , Distance: IfcLengthMeasure , SelfIntersect: IfcLogical , RefDirection: Handle<IfcDirection> )
	{
		this.BasisCurve = BasisCurve;
		this.Distance = Distance;
		this.SelfIntersect = SelfIntersect;
		this.RefDirection = RefDirection;
	}
	BasisCurve: Handle<IfcCurve> ;
	Distance: IfcLengthMeasure ;
	SelfIntersect: IfcLogical ;
	RefDirection: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcOffsetCurve3D
	{
		let BasisCurve = tape[0];
		let Distance = tape[1];
		let SelfIntersect = tape[2];
		let RefDirection = tape[3];
		return new IfcOffsetCurve3D(BasisCurve, Distance, SelfIntersect, RefDirection);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisCurve.expressID)
		args.push(REAL)
		args.push(this.Distance)
		args.push(REF)
		args.push(this.RefDirection.expressID)
		return args;
	}
};
export class IfcOffsetCurveByDistances {
	constructor(BasisCurve: Handle<IfcCurve> , OffsetValues: Handle<IfcDistanceExpression>[] , Tag: IfcLabel | null)
	{
		this.BasisCurve = BasisCurve;
		this.OffsetValues = OffsetValues;
		this.Tag = Tag;
	}
	BasisCurve: Handle<IfcCurve> ;
	OffsetValues: Handle<IfcDistanceExpression>[] ;
	Tag: IfcLabel | null;
	static FromTape(tape: any[]): IfcOffsetCurveByDistances
	{
		let BasisCurve = tape[0];
		let OffsetValues = tape[1];
		let Tag = tape[2];
		return new IfcOffsetCurveByDistances(BasisCurve, OffsetValues, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisCurve.expressID)
		args.push(SET_BEGIN)
		this.OffsetValues.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOpenShell {
	constructor(CfsFaces: Handle<IfcFace>[] )
	{
		this.CfsFaces = CfsFaces;
	}
	CfsFaces: Handle<IfcFace>[] ;
	static FromTape(tape: any[]): IfcOpenShell
	{
		let CfsFaces = tape[0];
		return new IfcOpenShell(CfsFaces);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.CfsFaces.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcOpeningElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcOpeningElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcOpeningElementTypeEnum | null;
	static FromTape(tape: any[]): IfcOpeningElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcOpeningElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOpeningStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcOpeningElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcOpeningElementTypeEnum | null;
	static FromTape(tape: any[]): IfcOpeningStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcOpeningStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOrganization {
	constructor(Identification: IfcIdentifier | null, Name: IfcLabel , Description: IfcText | null, Roles: Handle<IfcActorRole>[] | null, Addresses: Handle<IfcAddress>[] | null)
	{
		this.Identification = Identification;
		this.Name = Name;
		this.Description = Description;
		this.Roles = Roles;
		this.Addresses = Addresses;
	}
	Identification: IfcIdentifier | null;
	Name: IfcLabel ;
	Description: IfcText | null;
	Roles: Handle<IfcActorRole>[] | null;
	Addresses: Handle<IfcAddress>[] | null;
	static FromTape(tape: any[]): IfcOrganization
	{
		let Identification = tape[0];
		let Name = tape[1];
		let Description = tape[2];
		let Roles = tape[3];
		let Addresses = tape[4];
		return new IfcOrganization(Identification, Name, Description, Roles, Addresses);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Roles){
		args.push(SET_BEGIN)
		this.Roles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Addresses){
		args.push(SET_BEGIN)
		this.Addresses.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOrganizationRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingOrganization: Handle<IfcOrganization> , RelatedOrganizations: Handle<IfcOrganization>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingOrganization = RelatingOrganization;
		this.RelatedOrganizations = RelatedOrganizations;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingOrganization: Handle<IfcOrganization> ;
	RelatedOrganizations: Handle<IfcOrganization>[] ;
	static FromTape(tape: any[]): IfcOrganizationRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingOrganization = tape[2];
		let RelatedOrganizations = tape[3];
		return new IfcOrganizationRelationship(Name, Description, RelatingOrganization, RelatedOrganizations);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingOrganization.expressID)
		args.push(SET_BEGIN)
		this.RelatedOrganizations.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcOrientationExpression {
	constructor(LateralAxisDirection: Handle<IfcDirection> , VerticalAxisDirection: Handle<IfcDirection> )
	{
		this.LateralAxisDirection = LateralAxisDirection;
		this.VerticalAxisDirection = VerticalAxisDirection;
	}
	LateralAxisDirection: Handle<IfcDirection> ;
	VerticalAxisDirection: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcOrientationExpression
	{
		let LateralAxisDirection = tape[0];
		let VerticalAxisDirection = tape[1];
		return new IfcOrientationExpression(LateralAxisDirection, VerticalAxisDirection);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.LateralAxisDirection.expressID)
		args.push(REF)
		args.push(this.VerticalAxisDirection.expressID)
		return args;
	}
};
export class IfcOrientedEdge {
	constructor(EdgeStart: Handle<IfcVertex> , EdgeEnd: Handle<IfcVertex> , EdgeElement: Handle<IfcEdge> , Orientation: IfcBoolean )
	{
		this.EdgeStart = EdgeStart;
		this.EdgeEnd = EdgeEnd;
		this.EdgeElement = EdgeElement;
		this.Orientation = Orientation;
	}
	EdgeStart: Handle<IfcVertex> ;
	EdgeEnd: Handle<IfcVertex> ;
	EdgeElement: Handle<IfcEdge> ;
	Orientation: IfcBoolean ;
	static FromTape(tape: any[]): IfcOrientedEdge
	{
		let EdgeStart = tape[0];
		let EdgeEnd = tape[1];
		let EdgeElement = tape[2];
		let Orientation = tape[3];
		return new IfcOrientedEdge(EdgeStart, EdgeEnd, EdgeElement, Orientation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.EdgeStart.expressID)
		args.push(REF)
		args.push(this.EdgeEnd.expressID)
		args.push(REF)
		args.push(this.EdgeElement.expressID)
		return args;
	}
};
export class IfcOuterBoundaryCurve {
	constructor(Segments: Handle<IfcCompositeCurveSegment>[] , SelfIntersect: IfcLogical )
	{
		this.Segments = Segments;
		this.SelfIntersect = SelfIntersect;
	}
	Segments: Handle<IfcCompositeCurveSegment>[] ;
	SelfIntersect: IfcLogical ;
	static FromTape(tape: any[]): IfcOuterBoundaryCurve
	{
		let Segments = tape[0];
		let SelfIntersect = tape[1];
		return new IfcOuterBoundaryCurve(Segments, SelfIntersect);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Segments.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcOutlet {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcOutletTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcOutletTypeEnum | null;
	static FromTape(tape: any[]): IfcOutlet
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcOutlet(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOutletType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcOutletTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcOutletTypeEnum ;
	static FromTape(tape: any[]): IfcOutletType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcOutletType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcOwnerHistory {
	constructor(OwningUser: Handle<IfcPersonAndOrganization> , OwningApplication: Handle<IfcApplication> , State: IfcStateEnum | null, ChangeAction: IfcChangeActionEnum | null, LastModifiedDate: IfcTimeStamp | null, LastModifyingUser: Handle<IfcPersonAndOrganization> | null, LastModifyingApplication: Handle<IfcApplication> | null, CreationDate: IfcTimeStamp )
	{
		this.OwningUser = OwningUser;
		this.OwningApplication = OwningApplication;
		this.State = State;
		this.ChangeAction = ChangeAction;
		this.LastModifiedDate = LastModifiedDate;
		this.LastModifyingUser = LastModifyingUser;
		this.LastModifyingApplication = LastModifyingApplication;
		this.CreationDate = CreationDate;
	}
	OwningUser: Handle<IfcPersonAndOrganization> ;
	OwningApplication: Handle<IfcApplication> ;
	State: IfcStateEnum | null;
	ChangeAction: IfcChangeActionEnum | null;
	LastModifiedDate: IfcTimeStamp | null;
	LastModifyingUser: Handle<IfcPersonAndOrganization> | null;
	LastModifyingApplication: Handle<IfcApplication> | null;
	CreationDate: IfcTimeStamp ;
	static FromTape(tape: any[]): IfcOwnerHistory
	{
		let OwningUser = tape[0];
		let OwningApplication = tape[1];
		let State = tape[2];
		let ChangeAction = tape[3];
		let LastModifiedDate = tape[4];
		let LastModifyingUser = tape[5];
		let LastModifyingApplication = tape[6];
		let CreationDate = tape[7];
		return new IfcOwnerHistory(OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.OwningUser.expressID)
		args.push(REF)
		args.push(this.OwningApplication.expressID)
		if(this.State){
		}
		else{ args.push(EMPTY); }
		if(this.ChangeAction){
		}
		else{ args.push(EMPTY); }
		if(this.LastModifiedDate){
		args.push(REAL)
		args.push(this.LastModifiedDate)
		}
		else{ args.push(EMPTY); }
		if(this.LastModifyingUser){
		args.push(REF)
		args.push(this.LastModifyingUser.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LastModifyingApplication){
		args.push(REF)
		args.push(this.LastModifyingApplication.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.CreationDate)
		return args;
	}
};
export class IfcParameterizedProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	static FromTape(tape: any[]): IfcParameterizedProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		return new IfcParameterizedProfileDef(ProfileType, ProfileName, Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPath {
	constructor(EdgeList: Handle<IfcOrientedEdge>[] )
	{
		this.EdgeList = EdgeList;
	}
	EdgeList: Handle<IfcOrientedEdge>[] ;
	static FromTape(tape: any[]): IfcPath
	{
		let EdgeList = tape[0];
		return new IfcPath(EdgeList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.EdgeList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcPcurve {
	constructor(BasisSurface: Handle<IfcSurface> , ReferenceCurve: Handle<IfcCurve> )
	{
		this.BasisSurface = BasisSurface;
		this.ReferenceCurve = ReferenceCurve;
	}
	BasisSurface: Handle<IfcSurface> ;
	ReferenceCurve: Handle<IfcCurve> ;
	static FromTape(tape: any[]): IfcPcurve
	{
		let BasisSurface = tape[0];
		let ReferenceCurve = tape[1];
		return new IfcPcurve(BasisSurface, ReferenceCurve);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisSurface.expressID)
		args.push(REF)
		args.push(this.ReferenceCurve.expressID)
		return args;
	}
};
export class IfcPerformanceHistory {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LifeCyclePhase: IfcLabel , PredefinedType: IfcPerformanceHistoryTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LifeCyclePhase = LifeCyclePhase;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LifeCyclePhase: IfcLabel ;
	PredefinedType: IfcPerformanceHistoryTypeEnum | null;
	static FromTape(tape: any[]): IfcPerformanceHistory
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LifeCyclePhase = tape[6];
		let PredefinedType = tape[7];
		return new IfcPerformanceHistory(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.LifeCyclePhase)
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPermeableCoveringProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, OperationType: IfcPermeableCoveringOperationEnum , PanelPosition: IfcWindowPanelPositionEnum , FrameDepth: IfcPositiveLengthMeasure | null, FrameThickness: IfcPositiveLengthMeasure | null, ShapeAspectStyle: Handle<IfcShapeAspect> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.OperationType = OperationType;
		this.PanelPosition = PanelPosition;
		this.FrameDepth = FrameDepth;
		this.FrameThickness = FrameThickness;
		this.ShapeAspectStyle = ShapeAspectStyle;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	OperationType: IfcPermeableCoveringOperationEnum ;
	PanelPosition: IfcWindowPanelPositionEnum ;
	FrameDepth: IfcPositiveLengthMeasure | null;
	FrameThickness: IfcPositiveLengthMeasure | null;
	ShapeAspectStyle: Handle<IfcShapeAspect> | null;
	static FromTape(tape: any[]): IfcPermeableCoveringProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let OperationType = tape[4];
		let PanelPosition = tape[5];
		let FrameDepth = tape[6];
		let FrameThickness = tape[7];
		let ShapeAspectStyle = tape[8];
		return new IfcPermeableCoveringProperties(GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.FrameDepth){
		}
		else{ args.push(EMPTY); }
		if(this.FrameThickness){
		}
		else{ args.push(EMPTY); }
		if(this.ShapeAspectStyle){
		args.push(REF)
		args.push(this.ShapeAspectStyle.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPermit {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, PredefinedType: IfcPermitTypeEnum | null, Status: IfcLabel | null, LongDescription: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.PredefinedType = PredefinedType;
		this.Status = Status;
		this.LongDescription = LongDescription;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	PredefinedType: IfcPermitTypeEnum | null;
	Status: IfcLabel | null;
	LongDescription: IfcText | null;
	static FromTape(tape: any[]): IfcPermit
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let PredefinedType = tape[6];
		let Status = tape[7];
		let LongDescription = tape[8];
		return new IfcPermit(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		args.push(STRING)
		args.push(this.Status)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPerson {
	constructor(Identification: IfcIdentifier | null, FamilyName: IfcLabel | null, GivenName: IfcLabel | null, MiddleNames: IfcLabel[] | null, PrefixTitles: IfcLabel[] | null, SuffixTitles: IfcLabel[] | null, Roles: Handle<IfcActorRole>[] | null, Addresses: Handle<IfcAddress>[] | null)
	{
		this.Identification = Identification;
		this.FamilyName = FamilyName;
		this.GivenName = GivenName;
		this.MiddleNames = MiddleNames;
		this.PrefixTitles = PrefixTitles;
		this.SuffixTitles = SuffixTitles;
		this.Roles = Roles;
		this.Addresses = Addresses;
	}
	Identification: IfcIdentifier | null;
	FamilyName: IfcLabel | null;
	GivenName: IfcLabel | null;
	MiddleNames: IfcLabel[] | null;
	PrefixTitles: IfcLabel[] | null;
	SuffixTitles: IfcLabel[] | null;
	Roles: Handle<IfcActorRole>[] | null;
	Addresses: Handle<IfcAddress>[] | null;
	static FromTape(tape: any[]): IfcPerson
	{
		let Identification = tape[0];
		let FamilyName = tape[1];
		let GivenName = tape[2];
		let MiddleNames = tape[3];
		let PrefixTitles = tape[4];
		let SuffixTitles = tape[5];
		let Roles = tape[6];
		let Addresses = tape[7];
		return new IfcPerson(Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.FamilyName){
		args.push(STRING)
		args.push(this.FamilyName)
		}
		else{ args.push(EMPTY); }
		if(this.GivenName){
		args.push(STRING)
		args.push(this.GivenName)
		}
		else{ args.push(EMPTY); }
		if(this.MiddleNames){
		args.push(STRING)
		args.push(...this.MiddleNames)
		}
		else{ args.push(EMPTY); }
		if(this.PrefixTitles){
		args.push(STRING)
		args.push(...this.PrefixTitles)
		}
		else{ args.push(EMPTY); }
		if(this.SuffixTitles){
		args.push(STRING)
		args.push(...this.SuffixTitles)
		}
		else{ args.push(EMPTY); }
		if(this.Roles){
		args.push(SET_BEGIN)
		this.Roles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Addresses){
		args.push(SET_BEGIN)
		this.Addresses.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPersonAndOrganization {
	constructor(ThePerson: Handle<IfcPerson> , TheOrganization: Handle<IfcOrganization> , Roles: Handle<IfcActorRole>[] | null)
	{
		this.ThePerson = ThePerson;
		this.TheOrganization = TheOrganization;
		this.Roles = Roles;
	}
	ThePerson: Handle<IfcPerson> ;
	TheOrganization: Handle<IfcOrganization> ;
	Roles: Handle<IfcActorRole>[] | null;
	static FromTape(tape: any[]): IfcPersonAndOrganization
	{
		let ThePerson = tape[0];
		let TheOrganization = tape[1];
		let Roles = tape[2];
		return new IfcPersonAndOrganization(ThePerson, TheOrganization, Roles);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ThePerson.expressID)
		args.push(REF)
		args.push(this.TheOrganization.expressID)
		if(this.Roles){
		args.push(SET_BEGIN)
		this.Roles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPhysicalComplexQuantity {
	constructor(Name: IfcLabel , Description: IfcText | null, HasQuantities: Handle<IfcPhysicalQuantity>[] , Discrimination: IfcLabel , Quality: IfcLabel | null, Usage: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.HasQuantities = HasQuantities;
		this.Discrimination = Discrimination;
		this.Quality = Quality;
		this.Usage = Usage;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	HasQuantities: Handle<IfcPhysicalQuantity>[] ;
	Discrimination: IfcLabel ;
	Quality: IfcLabel | null;
	Usage: IfcLabel | null;
	static FromTape(tape: any[]): IfcPhysicalComplexQuantity
	{
		let Name = tape[0];
		let Description = tape[1];
		let HasQuantities = tape[2];
		let Discrimination = tape[3];
		let Quality = tape[4];
		let Usage = tape[5];
		return new IfcPhysicalComplexQuantity(Name, Description, HasQuantities, Discrimination, Quality, Usage);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.HasQuantities.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(STRING)
		args.push(this.Discrimination)
		if(this.Quality){
		args.push(STRING)
		args.push(this.Quality)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(STRING)
		args.push(this.Usage)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPhysicalQuantity {
	constructor(Name: IfcLabel , Description: IfcText | null)
	{
		this.Name = Name;
		this.Description = Description;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcPhysicalQuantity
	{
		let Name = tape[0];
		let Description = tape[1];
		return new IfcPhysicalQuantity(Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPhysicalSimpleQuantity {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	static FromTape(tape: any[]): IfcPhysicalSimpleQuantity
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		return new IfcPhysicalSimpleQuantity(Name, Description, Unit);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPile {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcPileTypeEnum | null, ConstructionType: IfcPileConstructionEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
		this.ConstructionType = ConstructionType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcPileTypeEnum | null;
	ConstructionType: IfcPileConstructionEnum | null;
	static FromTape(tape: any[]): IfcPile
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		let ConstructionType = tape[9];
		return new IfcPile(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.ConstructionType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPileType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcPileTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcPileTypeEnum ;
	static FromTape(tape: any[]): IfcPileType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcPileType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPipeFitting {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcPipeFittingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcPipeFittingTypeEnum | null;
	static FromTape(tape: any[]): IfcPipeFitting
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcPipeFitting(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPipeFittingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcPipeFittingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcPipeFittingTypeEnum ;
	static FromTape(tape: any[]): IfcPipeFittingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcPipeFittingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPipeSegment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcPipeSegmentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcPipeSegmentTypeEnum | null;
	static FromTape(tape: any[]): IfcPipeSegment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcPipeSegment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPipeSegmentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcPipeSegmentTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcPipeSegmentTypeEnum ;
	static FromTape(tape: any[]): IfcPipeSegmentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcPipeSegmentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPixelTexture {
	constructor(RepeatS: IfcBoolean , RepeatT: IfcBoolean , Mode: IfcIdentifier | null, TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null, Parameter: IfcIdentifier[] | null, Width: IfcInteger , Height: IfcInteger , ColourComponents: IfcInteger , Pixel: IfcBinary[] )
	{
		this.RepeatS = RepeatS;
		this.RepeatT = RepeatT;
		this.Mode = Mode;
		this.TextureTransform = TextureTransform;
		this.Parameter = Parameter;
		this.Width = Width;
		this.Height = Height;
		this.ColourComponents = ColourComponents;
		this.Pixel = Pixel;
	}
	RepeatS: IfcBoolean ;
	RepeatT: IfcBoolean ;
	Mode: IfcIdentifier | null;
	TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null;
	Parameter: IfcIdentifier[] | null;
	Width: IfcInteger ;
	Height: IfcInteger ;
	ColourComponents: IfcInteger ;
	Pixel: IfcBinary[] ;
	static FromTape(tape: any[]): IfcPixelTexture
	{
		let RepeatS = tape[0];
		let RepeatT = tape[1];
		let Mode = tape[2];
		let TextureTransform = tape[3];
		let Parameter = tape[4];
		let Width = tape[5];
		let Height = tape[6];
		let ColourComponents = tape[7];
		let Pixel = tape[8];
		return new IfcPixelTexture(RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Mode){
		args.push(STRING)
		args.push(this.Mode)
		}
		else{ args.push(EMPTY); }
		if(this.TextureTransform){
		args.push(REF)
		args.push(this.TextureTransform.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Parameter){
		args.push(STRING)
		args.push(...this.Parameter)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.Width)
		args.push(REAL)
		args.push(this.Height)
		args.push(REAL)
		args.push(this.ColourComponents)
		args.push(REAL)
		args.push(...this.Pixel)
		return args;
	}
};
export class IfcPlacement {
	constructor(Location: Handle<IfcCartesianPoint> )
	{
		this.Location = Location;
	}
	Location: Handle<IfcCartesianPoint> ;
	static FromTape(tape: any[]): IfcPlacement
	{
		let Location = tape[0];
		return new IfcPlacement(Location);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Location.expressID)
		return args;
	}
};
export class IfcPlanarBox {
	constructor(SizeInX: IfcLengthMeasure , SizeInY: IfcLengthMeasure , Placement: IfcAxis2Placement )
	{
		this.SizeInX = SizeInX;
		this.SizeInY = SizeInY;
		this.Placement = Placement;
	}
	SizeInX: IfcLengthMeasure ;
	SizeInY: IfcLengthMeasure ;
	Placement: IfcAxis2Placement ;
	static FromTape(tape: any[]): IfcPlanarBox
	{
		let SizeInX = tape[0];
		let SizeInY = tape[1];
		let Placement = tape[2];
		return new IfcPlanarBox(SizeInX, SizeInY, Placement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.SizeInX)
		args.push(REAL)
		args.push(this.SizeInY)
		return args;
	}
};
export class IfcPlanarExtent {
	constructor(SizeInX: IfcLengthMeasure , SizeInY: IfcLengthMeasure )
	{
		this.SizeInX = SizeInX;
		this.SizeInY = SizeInY;
	}
	SizeInX: IfcLengthMeasure ;
	SizeInY: IfcLengthMeasure ;
	static FromTape(tape: any[]): IfcPlanarExtent
	{
		let SizeInX = tape[0];
		let SizeInY = tape[1];
		return new IfcPlanarExtent(SizeInX, SizeInY);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.SizeInX)
		args.push(REAL)
		args.push(this.SizeInY)
		return args;
	}
};
export class IfcPlane {
	constructor(Position: Handle<IfcAxis2Placement3D> )
	{
		this.Position = Position;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	static FromTape(tape: any[]): IfcPlane
	{
		let Position = tape[0];
		return new IfcPlane(Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcPlate {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcPlateTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcPlateTypeEnum | null;
	static FromTape(tape: any[]): IfcPlate
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcPlate(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPlateStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcPlateTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcPlateTypeEnum | null;
	static FromTape(tape: any[]): IfcPlateStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcPlateStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPlateType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcPlateTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcPlateTypeEnum ;
	static FromTape(tape: any[]): IfcPlateType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcPlateType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPoint {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcPoint
	{
		return new IfcPoint();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcPointOnCurve {
	constructor(BasisCurve: Handle<IfcCurve> , PointParameter: IfcParameterValue )
	{
		this.BasisCurve = BasisCurve;
		this.PointParameter = PointParameter;
	}
	BasisCurve: Handle<IfcCurve> ;
	PointParameter: IfcParameterValue ;
	static FromTape(tape: any[]): IfcPointOnCurve
	{
		let BasisCurve = tape[0];
		let PointParameter = tape[1];
		return new IfcPointOnCurve(BasisCurve, PointParameter);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisCurve.expressID)
		args.push(REAL)
		args.push(this.PointParameter)
		return args;
	}
};
export class IfcPointOnSurface {
	constructor(BasisSurface: Handle<IfcSurface> , PointParameterU: IfcParameterValue , PointParameterV: IfcParameterValue )
	{
		this.BasisSurface = BasisSurface;
		this.PointParameterU = PointParameterU;
		this.PointParameterV = PointParameterV;
	}
	BasisSurface: Handle<IfcSurface> ;
	PointParameterU: IfcParameterValue ;
	PointParameterV: IfcParameterValue ;
	static FromTape(tape: any[]): IfcPointOnSurface
	{
		let BasisSurface = tape[0];
		let PointParameterU = tape[1];
		let PointParameterV = tape[2];
		return new IfcPointOnSurface(BasisSurface, PointParameterU, PointParameterV);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisSurface.expressID)
		args.push(REAL)
		args.push(this.PointParameterU)
		args.push(REAL)
		args.push(this.PointParameterV)
		return args;
	}
};
export class IfcPolyLoop {
	constructor(Polygon: Handle<IfcCartesianPoint>[] )
	{
		this.Polygon = Polygon;
	}
	Polygon: Handle<IfcCartesianPoint>[] ;
	static FromTape(tape: any[]): IfcPolyLoop
	{
		let Polygon = tape[0];
		return new IfcPolyLoop(Polygon);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Polygon.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcPolygonalBoundedHalfSpace {
	constructor(BaseSurface: Handle<IfcSurface> , AgreementFlag: IfcBoolean , Position: Handle<IfcAxis2Placement3D> , PolygonalBoundary: Handle<IfcBoundedCurve> )
	{
		this.BaseSurface = BaseSurface;
		this.AgreementFlag = AgreementFlag;
		this.Position = Position;
		this.PolygonalBoundary = PolygonalBoundary;
	}
	BaseSurface: Handle<IfcSurface> ;
	AgreementFlag: IfcBoolean ;
	Position: Handle<IfcAxis2Placement3D> ;
	PolygonalBoundary: Handle<IfcBoundedCurve> ;
	static FromTape(tape: any[]): IfcPolygonalBoundedHalfSpace
	{
		let BaseSurface = tape[0];
		let AgreementFlag = tape[1];
		let Position = tape[2];
		let PolygonalBoundary = tape[3];
		return new IfcPolygonalBoundedHalfSpace(BaseSurface, AgreementFlag, Position, PolygonalBoundary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BaseSurface.expressID)
		args.push(REF)
		args.push(this.Position.expressID)
		args.push(REF)
		args.push(this.PolygonalBoundary.expressID)
		return args;
	}
};
export class IfcPolygonalFaceSet {
	constructor(Coordinates: Handle<IfcCartesianPointList3D> , Closed: IfcBoolean | null, Faces: Handle<IfcIndexedPolygonalFace>[] , PnIndex: IfcPositiveInteger[] | null)
	{
		this.Coordinates = Coordinates;
		this.Closed = Closed;
		this.Faces = Faces;
		this.PnIndex = PnIndex;
	}
	Coordinates: Handle<IfcCartesianPointList3D> ;
	Closed: IfcBoolean | null;
	Faces: Handle<IfcIndexedPolygonalFace>[] ;
	PnIndex: IfcPositiveInteger[] | null;
	static FromTape(tape: any[]): IfcPolygonalFaceSet
	{
		let Coordinates = tape[0];
		let Closed = tape[1];
		let Faces = tape[2];
		let PnIndex = tape[3];
		return new IfcPolygonalFaceSet(Coordinates, Closed, Faces, PnIndex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Coordinates.expressID)
		if(this.Closed){
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Faces.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.PnIndex){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPolyline {
	constructor(Points: Handle<IfcCartesianPoint>[] )
	{
		this.Points = Points;
	}
	Points: Handle<IfcCartesianPoint>[] ;
	static FromTape(tape: any[]): IfcPolyline
	{
		let Points = tape[0];
		return new IfcPolyline(Points);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Points.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcPort {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	static FromTape(tape: any[]): IfcPort
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		return new IfcPort(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPositioningElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	static FromTape(tape: any[]): IfcPositioningElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		return new IfcPositioningElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPostalAddress {
	constructor(Purpose: IfcAddressTypeEnum | null, Description: IfcText | null, UserDefinedPurpose: IfcLabel | null, InternalLocation: IfcLabel | null, AddressLines: IfcLabel[] | null, PostalBox: IfcLabel | null, Town: IfcLabel | null, Region: IfcLabel | null, PostalCode: IfcLabel | null, Country: IfcLabel | null)
	{
		this.Purpose = Purpose;
		this.Description = Description;
		this.UserDefinedPurpose = UserDefinedPurpose;
		this.InternalLocation = InternalLocation;
		this.AddressLines = AddressLines;
		this.PostalBox = PostalBox;
		this.Town = Town;
		this.Region = Region;
		this.PostalCode = PostalCode;
		this.Country = Country;
	}
	Purpose: IfcAddressTypeEnum | null;
	Description: IfcText | null;
	UserDefinedPurpose: IfcLabel | null;
	InternalLocation: IfcLabel | null;
	AddressLines: IfcLabel[] | null;
	PostalBox: IfcLabel | null;
	Town: IfcLabel | null;
	Region: IfcLabel | null;
	PostalCode: IfcLabel | null;
	Country: IfcLabel | null;
	static FromTape(tape: any[]): IfcPostalAddress
	{
		let Purpose = tape[0];
		let Description = tape[1];
		let UserDefinedPurpose = tape[2];
		let InternalLocation = tape[3];
		let AddressLines = tape[4];
		let PostalBox = tape[5];
		let Town = tape[6];
		let Region = tape[7];
		let PostalCode = tape[8];
		let Country = tape[9];
		return new IfcPostalAddress(Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Purpose){
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedPurpose){
		args.push(STRING)
		args.push(this.UserDefinedPurpose)
		}
		else{ args.push(EMPTY); }
		if(this.InternalLocation){
		args.push(STRING)
		args.push(this.InternalLocation)
		}
		else{ args.push(EMPTY); }
		if(this.AddressLines){
		args.push(STRING)
		args.push(...this.AddressLines)
		}
		else{ args.push(EMPTY); }
		if(this.PostalBox){
		args.push(STRING)
		args.push(this.PostalBox)
		}
		else{ args.push(EMPTY); }
		if(this.Town){
		args.push(STRING)
		args.push(this.Town)
		}
		else{ args.push(EMPTY); }
		if(this.Region){
		args.push(STRING)
		args.push(this.Region)
		}
		else{ args.push(EMPTY); }
		if(this.PostalCode){
		args.push(STRING)
		args.push(this.PostalCode)
		}
		else{ args.push(EMPTY); }
		if(this.Country){
		args.push(STRING)
		args.push(this.Country)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPreDefinedColour {
	constructor(Name: IfcLabel )
	{
		this.Name = Name;
	}
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcPreDefinedColour
	{
		let Name = tape[0];
		return new IfcPreDefinedColour(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcPreDefinedCurveFont {
	constructor(Name: IfcLabel )
	{
		this.Name = Name;
	}
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcPreDefinedCurveFont
	{
		let Name = tape[0];
		return new IfcPreDefinedCurveFont(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcPreDefinedItem {
	constructor(Name: IfcLabel )
	{
		this.Name = Name;
	}
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcPreDefinedItem
	{
		let Name = tape[0];
		return new IfcPreDefinedItem(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcPreDefinedProperties {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcPreDefinedProperties
	{
		return new IfcPreDefinedProperties();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcPreDefinedPropertySet {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcPreDefinedPropertySet
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcPreDefinedPropertySet(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPreDefinedTextFont {
	constructor(Name: IfcLabel )
	{
		this.Name = Name;
	}
	Name: IfcLabel ;
	static FromTape(tape: any[]): IfcPreDefinedTextFont
	{
		let Name = tape[0];
		return new IfcPreDefinedTextFont(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		return args;
	}
};
export class IfcPresentationItem {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcPresentationItem
	{
		return new IfcPresentationItem();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcPresentationLayerAssignment {
	constructor(Name: IfcLabel , Description: IfcText | null, AssignedItems: IfcLayeredItem[] , Identifier: IfcIdentifier | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.AssignedItems = AssignedItems;
		this.Identifier = Identifier;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	AssignedItems: IfcLayeredItem[] ;
	Identifier: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcPresentationLayerAssignment
	{
		let Name = tape[0];
		let Description = tape[1];
		let AssignedItems = tape[2];
		let Identifier = tape[3];
		return new IfcPresentationLayerAssignment(Name, Description, AssignedItems, Identifier);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Identifier){
		args.push(STRING)
		args.push(this.Identifier)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPresentationLayerWithStyle {
	constructor(Name: IfcLabel , Description: IfcText | null, AssignedItems: IfcLayeredItem[] , Identifier: IfcIdentifier | null, LayerOn: IfcLogical , LayerFrozen: IfcLogical , LayerBlocked: IfcLogical , LayerStyles: Handle<IfcPresentationStyle>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.AssignedItems = AssignedItems;
		this.Identifier = Identifier;
		this.LayerOn = LayerOn;
		this.LayerFrozen = LayerFrozen;
		this.LayerBlocked = LayerBlocked;
		this.LayerStyles = LayerStyles;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	AssignedItems: IfcLayeredItem[] ;
	Identifier: IfcIdentifier | null;
	LayerOn: IfcLogical ;
	LayerFrozen: IfcLogical ;
	LayerBlocked: IfcLogical ;
	LayerStyles: Handle<IfcPresentationStyle>[] ;
	static FromTape(tape: any[]): IfcPresentationLayerWithStyle
	{
		let Name = tape[0];
		let Description = tape[1];
		let AssignedItems = tape[2];
		let Identifier = tape[3];
		let LayerOn = tape[4];
		let LayerFrozen = tape[5];
		let LayerBlocked = tape[6];
		let LayerStyles = tape[7];
		return new IfcPresentationLayerWithStyle(Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Identifier){
		args.push(STRING)
		args.push(this.Identifier)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.LayerStyles.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcPresentationStyle {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcPresentationStyle
	{
		let Name = tape[0];
		return new IfcPresentationStyle(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPresentationStyleAssignment {
	constructor(Styles: IfcPresentationStyleSelect[] )
	{
		this.Styles = Styles;
	}
	Styles: IfcPresentationStyleSelect[] ;
	static FromTape(tape: any[]): IfcPresentationStyleAssignment
	{
		let Styles = tape[0];
		return new IfcPresentationStyleAssignment(Styles);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcProcedure {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, PredefinedType: IfcProcedureTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	PredefinedType: IfcProcedureTypeEnum | null;
	static FromTape(tape: any[]): IfcProcedure
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let PredefinedType = tape[7];
		return new IfcProcedure(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProcedureType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ProcessType: IfcLabel | null, PredefinedType: IfcProcedureTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ProcessType = ProcessType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ProcessType: IfcLabel | null;
	PredefinedType: IfcProcedureTypeEnum ;
	static FromTape(tape: any[]): IfcProcedureType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ProcessType = tape[8];
		let PredefinedType = tape[9];
		return new IfcProcedureType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ProcessType){
		args.push(STRING)
		args.push(this.ProcessType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProcess {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	static FromTape(tape: any[]): IfcProcess
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		return new IfcProcess(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProduct {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	static FromTape(tape: any[]): IfcProduct
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		return new IfcProduct(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProductDefinitionShape {
	constructor(Name: IfcLabel | null, Description: IfcText | null, Representations: Handle<IfcRepresentation>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.Representations = Representations;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	Representations: Handle<IfcRepresentation>[] ;
	static FromTape(tape: any[]): IfcProductDefinitionShape
	{
		let Name = tape[0];
		let Description = tape[1];
		let Representations = tape[2];
		return new IfcProductDefinitionShape(Name, Description, Representations);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Representations.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcProductRepresentation {
	constructor(Name: IfcLabel | null, Description: IfcText | null, Representations: Handle<IfcRepresentation>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.Representations = Representations;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	Representations: Handle<IfcRepresentation>[] ;
	static FromTape(tape: any[]): IfcProductRepresentation
	{
		let Name = tape[0];
		let Description = tape[1];
		let Representations = tape[2];
		return new IfcProductRepresentation(Name, Description, Representations);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Representations.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	static FromTape(tape: any[]): IfcProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		return new IfcProfileDef(ProfileType, ProfileName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProfileProperties {
	constructor(Name: IfcIdentifier | null, Description: IfcText | null, Properties: Handle<IfcProperty>[] , ProfileDefinition: Handle<IfcProfileDef> )
	{
		this.Name = Name;
		this.Description = Description;
		this.Properties = Properties;
		this.ProfileDefinition = ProfileDefinition;
	}
	Name: IfcIdentifier | null;
	Description: IfcText | null;
	Properties: Handle<IfcProperty>[] ;
	ProfileDefinition: Handle<IfcProfileDef> ;
	static FromTape(tape: any[]): IfcProfileProperties
	{
		let Name = tape[0];
		let Description = tape[1];
		let Properties = tape[2];
		let ProfileDefinition = tape[3];
		return new IfcProfileProperties(Name, Description, Properties, ProfileDefinition);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Properties.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.ProfileDefinition.expressID)
		return args;
	}
};
export class IfcProject {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, LongName: IfcLabel | null, Phase: IfcLabel | null, RepresentationContexts: Handle<IfcRepresentationContext>[] | null, UnitsInContext: Handle<IfcUnitAssignment> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.LongName = LongName;
		this.Phase = Phase;
		this.RepresentationContexts = RepresentationContexts;
		this.UnitsInContext = UnitsInContext;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	LongName: IfcLabel | null;
	Phase: IfcLabel | null;
	RepresentationContexts: Handle<IfcRepresentationContext>[] | null;
	UnitsInContext: Handle<IfcUnitAssignment> | null;
	static FromTape(tape: any[]): IfcProject
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let LongName = tape[5];
		let Phase = tape[6];
		let RepresentationContexts = tape[7];
		let UnitsInContext = tape[8];
		return new IfcProject(GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.Phase){
		args.push(STRING)
		args.push(this.Phase)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationContexts){
		args.push(SET_BEGIN)
		this.RepresentationContexts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.UnitsInContext){
		args.push(REF)
		args.push(this.UnitsInContext.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProjectLibrary {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, LongName: IfcLabel | null, Phase: IfcLabel | null, RepresentationContexts: Handle<IfcRepresentationContext>[] | null, UnitsInContext: Handle<IfcUnitAssignment> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.LongName = LongName;
		this.Phase = Phase;
		this.RepresentationContexts = RepresentationContexts;
		this.UnitsInContext = UnitsInContext;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	LongName: IfcLabel | null;
	Phase: IfcLabel | null;
	RepresentationContexts: Handle<IfcRepresentationContext>[] | null;
	UnitsInContext: Handle<IfcUnitAssignment> | null;
	static FromTape(tape: any[]): IfcProjectLibrary
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let LongName = tape[5];
		let Phase = tape[6];
		let RepresentationContexts = tape[7];
		let UnitsInContext = tape[8];
		return new IfcProjectLibrary(GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.Phase){
		args.push(STRING)
		args.push(this.Phase)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationContexts){
		args.push(SET_BEGIN)
		this.RepresentationContexts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.UnitsInContext){
		args.push(REF)
		args.push(this.UnitsInContext.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProjectOrder {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, PredefinedType: IfcProjectOrderTypeEnum | null, Status: IfcLabel | null, LongDescription: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.PredefinedType = PredefinedType;
		this.Status = Status;
		this.LongDescription = LongDescription;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	PredefinedType: IfcProjectOrderTypeEnum | null;
	Status: IfcLabel | null;
	LongDescription: IfcText | null;
	static FromTape(tape: any[]): IfcProjectOrder
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let PredefinedType = tape[6];
		let Status = tape[7];
		let LongDescription = tape[8];
		return new IfcProjectOrder(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		args.push(STRING)
		args.push(this.Status)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProjectedCRS {
	constructor(Name: IfcLabel , Description: IfcText | null, GeodeticDatum: IfcIdentifier | null, VerticalDatum: IfcIdentifier | null, MapProjection: IfcIdentifier | null, MapZone: IfcIdentifier | null, MapUnit: Handle<IfcNamedUnit> | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.GeodeticDatum = GeodeticDatum;
		this.VerticalDatum = VerticalDatum;
		this.MapProjection = MapProjection;
		this.MapZone = MapZone;
		this.MapUnit = MapUnit;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	GeodeticDatum: IfcIdentifier | null;
	VerticalDatum: IfcIdentifier | null;
	MapProjection: IfcIdentifier | null;
	MapZone: IfcIdentifier | null;
	MapUnit: Handle<IfcNamedUnit> | null;
	static FromTape(tape: any[]): IfcProjectedCRS
	{
		let Name = tape[0];
		let Description = tape[1];
		let GeodeticDatum = tape[2];
		let VerticalDatum = tape[3];
		let MapProjection = tape[4];
		let MapZone = tape[5];
		let MapUnit = tape[6];
		return new IfcProjectedCRS(Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.GeodeticDatum){
		args.push(STRING)
		args.push(this.GeodeticDatum)
		}
		else{ args.push(EMPTY); }
		if(this.VerticalDatum){
		args.push(STRING)
		args.push(this.VerticalDatum)
		}
		else{ args.push(EMPTY); }
		if(this.MapProjection){
		args.push(STRING)
		args.push(this.MapProjection)
		}
		else{ args.push(EMPTY); }
		if(this.MapZone){
		args.push(STRING)
		args.push(this.MapZone)
		}
		else{ args.push(EMPTY); }
		if(this.MapUnit){
		args.push(REF)
		args.push(this.MapUnit.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProjectionElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcProjectionElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcProjectionElementTypeEnum | null;
	static FromTape(tape: any[]): IfcProjectionElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcProjectionElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProperty {
	constructor(Name: IfcIdentifier , Description: IfcText | null)
	{
		this.Name = Name;
		this.Description = Description;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcProperty
	{
		let Name = tape[0];
		let Description = tape[1];
		return new IfcProperty(Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyAbstraction {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcPropertyAbstraction
	{
		return new IfcPropertyAbstraction();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcPropertyBoundedValue {
	constructor(Name: IfcIdentifier , Description: IfcText | null, UpperBoundValue: IfcValue | null, LowerBoundValue: IfcValue | null, Unit: IfcUnit | null, SetPointValue: IfcValue | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.UpperBoundValue = UpperBoundValue;
		this.LowerBoundValue = LowerBoundValue;
		this.Unit = Unit;
		this.SetPointValue = SetPointValue;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	UpperBoundValue: IfcValue | null;
	LowerBoundValue: IfcValue | null;
	Unit: IfcUnit | null;
	SetPointValue: IfcValue | null;
	static FromTape(tape: any[]): IfcPropertyBoundedValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let UpperBoundValue = tape[2] ? { t: tape[2], v: tape[3][0]} as any : null;
		let LowerBoundValue = tape[4] ? { t: tape[4], v: tape[5][0]} as any : null;
		let Unit = tape[6];
		let SetPointValue = tape[7] ? { t: tape[7], v: tape[8][0]} as any : null;
		return new IfcPropertyBoundedValue(Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.UpperBoundValue){
		args.push(LABEL)
		//@ts-ignore
		args.push(this.UpperBoundValue.t)
		args.push(SET_BEGIN)
		args.push(STRING)
		//@ts-ignore
		args.push(this.UpperBoundValue.v)
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.LowerBoundValue){
		args.push(LABEL)
		//@ts-ignore
		args.push(this.LowerBoundValue.t)
		args.push(SET_BEGIN)
		args.push(STRING)
		//@ts-ignore
		args.push(this.LowerBoundValue.v)
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		if(this.SetPointValue){
		args.push(LABEL)
		//@ts-ignore
		args.push(this.SetPointValue.t)
		args.push(SET_BEGIN)
		args.push(STRING)
		//@ts-ignore
		args.push(this.SetPointValue.v)
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyDefinition {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcPropertyDefinition
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcPropertyDefinition(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyDependencyRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, DependingProperty: Handle<IfcProperty> , DependantProperty: Handle<IfcProperty> , Expression: IfcText | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.DependingProperty = DependingProperty;
		this.DependantProperty = DependantProperty;
		this.Expression = Expression;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	DependingProperty: Handle<IfcProperty> ;
	DependantProperty: Handle<IfcProperty> ;
	Expression: IfcText | null;
	static FromTape(tape: any[]): IfcPropertyDependencyRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let DependingProperty = tape[2];
		let DependantProperty = tape[3];
		let Expression = tape[4];
		return new IfcPropertyDependencyRelationship(Name, Description, DependingProperty, DependantProperty, Expression);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.DependingProperty.expressID)
		args.push(REF)
		args.push(this.DependantProperty.expressID)
		if(this.Expression){
		args.push(STRING)
		args.push(this.Expression)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyEnumeratedValue {
	constructor(Name: IfcIdentifier , Description: IfcText | null, EnumerationValues: IfcValue[] | null, EnumerationReference: Handle<IfcPropertyEnumeration> | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.EnumerationValues = EnumerationValues;
		this.EnumerationReference = EnumerationReference;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	EnumerationValues: IfcValue[] | null;
	EnumerationReference: Handle<IfcPropertyEnumeration> | null;
	static FromTape(tape: any[]): IfcPropertyEnumeratedValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let EnumerationValues = tape[2] ? { t: tape[2], v: tape[3][0]} as any : null;
		let EnumerationReference = tape[4];
		return new IfcPropertyEnumeratedValue(Name, Description, EnumerationValues, EnumerationReference);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.EnumerationValues){
		}
		else{ args.push(EMPTY); }
		if(this.EnumerationReference){
		args.push(REF)
		args.push(this.EnumerationReference.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyEnumeration {
	constructor(Name: IfcLabel , EnumerationValues: IfcValue[] , Unit: IfcUnit | null)
	{
		this.Name = Name;
		this.EnumerationValues = EnumerationValues;
		this.Unit = Unit;
	}
	Name: IfcLabel ;
	EnumerationValues: IfcValue[] ;
	Unit: IfcUnit | null;
	static FromTape(tape: any[]): IfcPropertyEnumeration
	{
		let Name = tape[0];
		let EnumerationValues = { t: tape[1], v: tape[2][0]} as any;
		let Unit = tape[3];
		return new IfcPropertyEnumeration(Name, EnumerationValues, Unit);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyListValue {
	constructor(Name: IfcIdentifier , Description: IfcText | null, ListValues: IfcValue[] | null, Unit: IfcUnit | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.ListValues = ListValues;
		this.Unit = Unit;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	ListValues: IfcValue[] | null;
	Unit: IfcUnit | null;
	static FromTape(tape: any[]): IfcPropertyListValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let ListValues = tape[2] ? { t: tape[2], v: tape[3][0]} as any : null;
		let Unit = tape[4];
		return new IfcPropertyListValue(Name, Description, ListValues, Unit);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ListValues){
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyReferenceValue {
	constructor(Name: IfcIdentifier , Description: IfcText | null, UsageName: IfcText | null, PropertyReference: IfcObjectReferenceSelect | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.UsageName = UsageName;
		this.PropertyReference = PropertyReference;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	UsageName: IfcText | null;
	PropertyReference: IfcObjectReferenceSelect | null;
	static FromTape(tape: any[]): IfcPropertyReferenceValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let UsageName = tape[2];
		let PropertyReference = tape[3];
		return new IfcPropertyReferenceValue(Name, Description, UsageName, PropertyReference);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.UsageName){
		args.push(STRING)
		args.push(this.UsageName)
		}
		else{ args.push(EMPTY); }
		if(this.PropertyReference){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertySet {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, HasProperties: Handle<IfcProperty>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.HasProperties = HasProperties;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	HasProperties: Handle<IfcProperty>[] ;
	static FromTape(tape: any[]): IfcPropertySet
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let HasProperties = tape[4];
		return new IfcPropertySet(GlobalId, OwnerHistory, Name, Description, HasProperties);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.HasProperties.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcPropertySetDefinition {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcPropertySetDefinition
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcPropertySetDefinition(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertySetTemplate {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, TemplateType: IfcPropertySetTemplateTypeEnum | null, ApplicableEntity: IfcIdentifier | null, HasPropertyTemplates: Handle<IfcPropertyTemplate>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.TemplateType = TemplateType;
		this.ApplicableEntity = ApplicableEntity;
		this.HasPropertyTemplates = HasPropertyTemplates;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	TemplateType: IfcPropertySetTemplateTypeEnum | null;
	ApplicableEntity: IfcIdentifier | null;
	HasPropertyTemplates: Handle<IfcPropertyTemplate>[] ;
	static FromTape(tape: any[]): IfcPropertySetTemplate
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let TemplateType = tape[4];
		let ApplicableEntity = tape[5];
		let HasPropertyTemplates = tape[6];
		return new IfcPropertySetTemplate(GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.TemplateType){
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableEntity){
		args.push(STRING)
		args.push(this.ApplicableEntity)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.HasPropertyTemplates.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcPropertySingleValue {
	constructor(Name: IfcIdentifier , Description: IfcText | null, NominalValue: IfcValue | null, Unit: IfcUnit | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.NominalValue = NominalValue;
		this.Unit = Unit;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	NominalValue: IfcValue | null;
	Unit: IfcUnit | null;
	static FromTape(tape: any[]): IfcPropertySingleValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let NominalValue = tape[2] ? { t: tape[2], v: tape[3][0]} as any : null;
		let Unit = tape[4];
		return new IfcPropertySingleValue(Name, Description, NominalValue, Unit);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.NominalValue){
		args.push(LABEL)
		//@ts-ignore
		args.push(this.NominalValue.t)
		args.push(SET_BEGIN)
		args.push(STRING)
		//@ts-ignore
		args.push(this.NominalValue.v)
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyTableValue {
	constructor(Name: IfcIdentifier , Description: IfcText | null, DefiningValues: IfcValue[] | null, DefinedValues: IfcValue[] | null, Expression: IfcText | null, DefiningUnit: IfcUnit | null, DefinedUnit: IfcUnit | null, CurveInterpolation: IfcCurveInterpolationEnum | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.DefiningValues = DefiningValues;
		this.DefinedValues = DefinedValues;
		this.Expression = Expression;
		this.DefiningUnit = DefiningUnit;
		this.DefinedUnit = DefinedUnit;
		this.CurveInterpolation = CurveInterpolation;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	DefiningValues: IfcValue[] | null;
	DefinedValues: IfcValue[] | null;
	Expression: IfcText | null;
	DefiningUnit: IfcUnit | null;
	DefinedUnit: IfcUnit | null;
	CurveInterpolation: IfcCurveInterpolationEnum | null;
	static FromTape(tape: any[]): IfcPropertyTableValue
	{
		let Name = tape[0];
		let Description = tape[1];
		let DefiningValues = tape[2] ? { t: tape[2], v: tape[3][0]} as any : null;
		let DefinedValues = tape[4] ? { t: tape[4], v: tape[5][0]} as any : null;
		let Expression = tape[6];
		let DefiningUnit = tape[7];
		let DefinedUnit = tape[8];
		let CurveInterpolation = tape[9];
		return new IfcPropertyTableValue(Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.DefiningValues){
		}
		else{ args.push(EMPTY); }
		if(this.DefinedValues){
		}
		else{ args.push(EMPTY); }
		if(this.Expression){
		args.push(STRING)
		args.push(this.Expression)
		}
		else{ args.push(EMPTY); }
		if(this.DefiningUnit){
		}
		else{ args.push(EMPTY); }
		if(this.DefinedUnit){
		}
		else{ args.push(EMPTY); }
		if(this.CurveInterpolation){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyTemplate {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcPropertyTemplate
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcPropertyTemplate(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPropertyTemplateDefinition {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcPropertyTemplateDefinition
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcPropertyTemplateDefinition(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProtectiveDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcProtectiveDeviceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcProtectiveDeviceTypeEnum | null;
	static FromTape(tape: any[]): IfcProtectiveDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcProtectiveDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProtectiveDeviceTrippingUnit {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcProtectiveDeviceTrippingUnitTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcProtectiveDeviceTrippingUnitTypeEnum | null;
	static FromTape(tape: any[]): IfcProtectiveDeviceTrippingUnit
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcProtectiveDeviceTrippingUnit(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProtectiveDeviceTrippingUnitType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcProtectiveDeviceTrippingUnitTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcProtectiveDeviceTrippingUnitTypeEnum ;
	static FromTape(tape: any[]): IfcProtectiveDeviceTrippingUnitType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcProtectiveDeviceTrippingUnitType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProtectiveDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcProtectiveDeviceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcProtectiveDeviceTypeEnum ;
	static FromTape(tape: any[]): IfcProtectiveDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcProtectiveDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcProxy {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, ProxyType: IfcObjectTypeEnum , Tag: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.ProxyType = ProxyType;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	ProxyType: IfcObjectTypeEnum ;
	Tag: IfcLabel | null;
	static FromTape(tape: any[]): IfcProxy
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let ProxyType = tape[7];
		let Tag = tape[8];
		return new IfcProxy(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPump {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcPumpTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcPumpTypeEnum | null;
	static FromTape(tape: any[]): IfcPump
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcPump(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcPumpType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcPumpTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcPumpTypeEnum ;
	static FromTape(tape: any[]): IfcPumpType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcPumpType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantityArea {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null, AreaValue: IfcAreaMeasure , Formula: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.AreaValue = AreaValue;
		this.Formula = Formula;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	AreaValue: IfcAreaMeasure ;
	Formula: IfcLabel | null;
	static FromTape(tape: any[]): IfcQuantityArea
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		let AreaValue = tape[3];
		let Formula = tape[4];
		return new IfcQuantityArea(Name, Description, Unit, AreaValue, Formula);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.AreaValue)
		if(this.Formula){
		args.push(STRING)
		args.push(this.Formula)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantityCount {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null, CountValue: IfcCountMeasure , Formula: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.CountValue = CountValue;
		this.Formula = Formula;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	CountValue: IfcCountMeasure ;
	Formula: IfcLabel | null;
	static FromTape(tape: any[]): IfcQuantityCount
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		let CountValue = tape[3];
		let Formula = tape[4];
		return new IfcQuantityCount(Name, Description, Unit, CountValue, Formula);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.CountValue)
		if(this.Formula){
		args.push(STRING)
		args.push(this.Formula)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantityLength {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null, LengthValue: IfcLengthMeasure , Formula: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.LengthValue = LengthValue;
		this.Formula = Formula;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	LengthValue: IfcLengthMeasure ;
	Formula: IfcLabel | null;
	static FromTape(tape: any[]): IfcQuantityLength
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		let LengthValue = tape[3];
		let Formula = tape[4];
		return new IfcQuantityLength(Name, Description, Unit, LengthValue, Formula);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.LengthValue)
		if(this.Formula){
		args.push(STRING)
		args.push(this.Formula)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantitySet {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcQuantitySet
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcQuantitySet(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantityTime {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null, TimeValue: IfcTimeMeasure , Formula: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.TimeValue = TimeValue;
		this.Formula = Formula;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	TimeValue: IfcTimeMeasure ;
	Formula: IfcLabel | null;
	static FromTape(tape: any[]): IfcQuantityTime
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		let TimeValue = tape[3];
		let Formula = tape[4];
		return new IfcQuantityTime(Name, Description, Unit, TimeValue, Formula);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.TimeValue)
		if(this.Formula){
		args.push(STRING)
		args.push(this.Formula)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantityVolume {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null, VolumeValue: IfcVolumeMeasure , Formula: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.VolumeValue = VolumeValue;
		this.Formula = Formula;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	VolumeValue: IfcVolumeMeasure ;
	Formula: IfcLabel | null;
	static FromTape(tape: any[]): IfcQuantityVolume
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		let VolumeValue = tape[3];
		let Formula = tape[4];
		return new IfcQuantityVolume(Name, Description, Unit, VolumeValue, Formula);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.VolumeValue)
		if(this.Formula){
		args.push(STRING)
		args.push(this.Formula)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcQuantityWeight {
	constructor(Name: IfcLabel , Description: IfcText | null, Unit: Handle<IfcNamedUnit> | null, WeightValue: IfcMassMeasure , Formula: IfcLabel | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.WeightValue = WeightValue;
		this.Formula = Formula;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	Unit: Handle<IfcNamedUnit> | null;
	WeightValue: IfcMassMeasure ;
	Formula: IfcLabel | null;
	static FromTape(tape: any[]): IfcQuantityWeight
	{
		let Name = tape[0];
		let Description = tape[1];
		let Unit = tape[2];
		let WeightValue = tape[3];
		let Formula = tape[4];
		return new IfcQuantityWeight(Name, Description, Unit, WeightValue, Formula);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		args.push(REF)
		args.push(this.Unit.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.WeightValue)
		if(this.Formula){
		args.push(STRING)
		args.push(this.Formula)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRailing {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcRailingTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcRailingTypeEnum | null;
	static FromTape(tape: any[]): IfcRailing
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcRailing(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRailingType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcRailingTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcRailingTypeEnum ;
	static FromTape(tape: any[]): IfcRailingType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcRailingType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRamp {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcRampTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcRampTypeEnum | null;
	static FromTape(tape: any[]): IfcRamp
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcRamp(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRampFlight {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcRampFlightTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcRampFlightTypeEnum | null;
	static FromTape(tape: any[]): IfcRampFlight
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcRampFlight(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRampFlightType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcRampFlightTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcRampFlightTypeEnum ;
	static FromTape(tape: any[]): IfcRampFlightType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcRampFlightType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRampType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcRampTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcRampTypeEnum ;
	static FromTape(tape: any[]): IfcRampType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcRampType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRationalBSplineCurveWithKnots {
	constructor(Degree: IfcInteger , ControlPointsList: Handle<IfcCartesianPoint>[] , CurveForm: IfcBSplineCurveForm , ClosedCurve: IfcLogical , SelfIntersect: IfcLogical , KnotMultiplicities: IfcInteger[] , Knots: IfcParameterValue[] , KnotSpec: IfcKnotType , WeightsData: IfcReal[] )
	{
		this.Degree = Degree;
		this.ControlPointsList = ControlPointsList;
		this.CurveForm = CurveForm;
		this.ClosedCurve = ClosedCurve;
		this.SelfIntersect = SelfIntersect;
		this.KnotMultiplicities = KnotMultiplicities;
		this.Knots = Knots;
		this.KnotSpec = KnotSpec;
		this.WeightsData = WeightsData;
	}
	Degree: IfcInteger ;
	ControlPointsList: Handle<IfcCartesianPoint>[] ;
	CurveForm: IfcBSplineCurveForm ;
	ClosedCurve: IfcLogical ;
	SelfIntersect: IfcLogical ;
	KnotMultiplicities: IfcInteger[] ;
	Knots: IfcParameterValue[] ;
	KnotSpec: IfcKnotType ;
	WeightsData: IfcReal[] ;
	static FromTape(tape: any[]): IfcRationalBSplineCurveWithKnots
	{
		let Degree = tape[0];
		let ControlPointsList = tape[1];
		let CurveForm = tape[2];
		let ClosedCurve = tape[3];
		let SelfIntersect = tape[4];
		let KnotMultiplicities = tape[5];
		let Knots = tape[6];
		let KnotSpec = tape[7];
		let WeightsData = tape[8];
		return new IfcRationalBSplineCurveWithKnots(Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.Degree)
		args.push(SET_BEGIN)
		this.ControlPointsList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REAL)
		args.push(...this.KnotMultiplicities)
		args.push(REAL)
		args.push(...this.Knots)
		args.push(REAL)
		args.push(...this.WeightsData)
		return args;
	}
};
export class IfcRationalBSplineSurfaceWithKnots {
	constructor(UDegree: IfcInteger , VDegree: IfcInteger , ControlPointsList: Handle<IfcCartesianPoint>[] , SurfaceForm: IfcBSplineSurfaceForm , UClosed: IfcLogical , VClosed: IfcLogical , SelfIntersect: IfcLogical , UMultiplicities: IfcInteger[] , VMultiplicities: IfcInteger[] , UKnots: IfcParameterValue[] , VKnots: IfcParameterValue[] , KnotSpec: IfcKnotType , WeightsData: IfcReal[] )
	{
		this.UDegree = UDegree;
		this.VDegree = VDegree;
		this.ControlPointsList = ControlPointsList;
		this.SurfaceForm = SurfaceForm;
		this.UClosed = UClosed;
		this.VClosed = VClosed;
		this.SelfIntersect = SelfIntersect;
		this.UMultiplicities = UMultiplicities;
		this.VMultiplicities = VMultiplicities;
		this.UKnots = UKnots;
		this.VKnots = VKnots;
		this.KnotSpec = KnotSpec;
		this.WeightsData = WeightsData;
	}
	UDegree: IfcInteger ;
	VDegree: IfcInteger ;
	ControlPointsList: Handle<IfcCartesianPoint>[] ;
	SurfaceForm: IfcBSplineSurfaceForm ;
	UClosed: IfcLogical ;
	VClosed: IfcLogical ;
	SelfIntersect: IfcLogical ;
	UMultiplicities: IfcInteger[] ;
	VMultiplicities: IfcInteger[] ;
	UKnots: IfcParameterValue[] ;
	VKnots: IfcParameterValue[] ;
	KnotSpec: IfcKnotType ;
	WeightsData: IfcReal[] ;
	static FromTape(tape: any[]): IfcRationalBSplineSurfaceWithKnots
	{
		let UDegree = tape[0];
		let VDegree = tape[1];
		let ControlPointsList = tape[2];
		let SurfaceForm = tape[3];
		let UClosed = tape[4];
		let VClosed = tape[5];
		let SelfIntersect = tape[6];
		let UMultiplicities = tape[7];
		let VMultiplicities = tape[8];
		let UKnots = tape[9];
		let VKnots = tape[10];
		let KnotSpec = tape[11];
		let WeightsData = tape[12];
		return new IfcRationalBSplineSurfaceWithKnots(UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.UDegree)
		args.push(REAL)
		args.push(this.VDegree)
		args.push(SET_BEGIN)
		this.ControlPointsList.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REAL)
		args.push(...this.UMultiplicities)
		args.push(REAL)
		args.push(...this.VMultiplicities)
		args.push(REAL)
		args.push(...this.UKnots)
		args.push(REAL)
		args.push(...this.VKnots)
		args.push(REAL)
		args.push(...this.WeightsData)
		return args;
	}
};
export class IfcRectangleHollowProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, XDim: IfcPositiveLengthMeasure , YDim: IfcPositiveLengthMeasure , WallThickness: IfcPositiveLengthMeasure , InnerFilletRadius: IfcNonNegativeLengthMeasure | null, OuterFilletRadius: IfcNonNegativeLengthMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.XDim = XDim;
		this.YDim = YDim;
		this.WallThickness = WallThickness;
		this.InnerFilletRadius = InnerFilletRadius;
		this.OuterFilletRadius = OuterFilletRadius;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	XDim: IfcPositiveLengthMeasure ;
	YDim: IfcPositiveLengthMeasure ;
	WallThickness: IfcPositiveLengthMeasure ;
	InnerFilletRadius: IfcNonNegativeLengthMeasure | null;
	OuterFilletRadius: IfcNonNegativeLengthMeasure | null;
	static FromTape(tape: any[]): IfcRectangleHollowProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let XDim = tape[3];
		let YDim = tape[4];
		let WallThickness = tape[5];
		let InnerFilletRadius = tape[6];
		let OuterFilletRadius = tape[7];
		return new IfcRectangleHollowProfileDef(ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.InnerFilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.OuterFilletRadius){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRectangleProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, XDim: IfcPositiveLengthMeasure , YDim: IfcPositiveLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.XDim = XDim;
		this.YDim = YDim;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	XDim: IfcPositiveLengthMeasure ;
	YDim: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcRectangleProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let XDim = tape[3];
		let YDim = tape[4];
		return new IfcRectangleProfileDef(ProfileType, ProfileName, Position, XDim, YDim);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRectangularPyramid {
	constructor(Position: Handle<IfcAxis2Placement3D> , XLength: IfcPositiveLengthMeasure , YLength: IfcPositiveLengthMeasure , Height: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.XLength = XLength;
		this.YLength = YLength;
		this.Height = Height;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	XLength: IfcPositiveLengthMeasure ;
	YLength: IfcPositiveLengthMeasure ;
	Height: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcRectangularPyramid
	{
		let Position = tape[0];
		let XLength = tape[1];
		let YLength = tape[2];
		let Height = tape[3];
		return new IfcRectangularPyramid(Position, XLength, YLength, Height);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcRectangularTrimmedSurface {
	constructor(BasisSurface: Handle<IfcSurface> , U1: IfcParameterValue , V1: IfcParameterValue , U2: IfcParameterValue , V2: IfcParameterValue , Usense: IfcBoolean , Vsense: IfcBoolean )
	{
		this.BasisSurface = BasisSurface;
		this.U1 = U1;
		this.V1 = V1;
		this.U2 = U2;
		this.V2 = V2;
		this.Usense = Usense;
		this.Vsense = Vsense;
	}
	BasisSurface: Handle<IfcSurface> ;
	U1: IfcParameterValue ;
	V1: IfcParameterValue ;
	U2: IfcParameterValue ;
	V2: IfcParameterValue ;
	Usense: IfcBoolean ;
	Vsense: IfcBoolean ;
	static FromTape(tape: any[]): IfcRectangularTrimmedSurface
	{
		let BasisSurface = tape[0];
		let U1 = tape[1];
		let V1 = tape[2];
		let U2 = tape[3];
		let V2 = tape[4];
		let Usense = tape[5];
		let Vsense = tape[6];
		return new IfcRectangularTrimmedSurface(BasisSurface, U1, V1, U2, V2, Usense, Vsense);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisSurface.expressID)
		args.push(REAL)
		args.push(this.U1)
		args.push(REAL)
		args.push(this.V1)
		args.push(REAL)
		args.push(this.U2)
		args.push(REAL)
		args.push(this.V2)
		return args;
	}
};
export class IfcRecurrencePattern {
	constructor(RecurrenceType: IfcRecurrenceTypeEnum , DayComponent: IfcDayInMonthNumber[] | null, WeekdayComponent: IfcDayInWeekNumber[] | null, MonthComponent: IfcMonthInYearNumber[] | null, Position: IfcInteger | null, Interval: IfcInteger | null, Occurrences: IfcInteger | null, TimePeriods: Handle<IfcTimePeriod>[] | null)
	{
		this.RecurrenceType = RecurrenceType;
		this.DayComponent = DayComponent;
		this.WeekdayComponent = WeekdayComponent;
		this.MonthComponent = MonthComponent;
		this.Position = Position;
		this.Interval = Interval;
		this.Occurrences = Occurrences;
		this.TimePeriods = TimePeriods;
	}
	RecurrenceType: IfcRecurrenceTypeEnum ;
	DayComponent: IfcDayInMonthNumber[] | null;
	WeekdayComponent: IfcDayInWeekNumber[] | null;
	MonthComponent: IfcMonthInYearNumber[] | null;
	Position: IfcInteger | null;
	Interval: IfcInteger | null;
	Occurrences: IfcInteger | null;
	TimePeriods: Handle<IfcTimePeriod>[] | null;
	static FromTape(tape: any[]): IfcRecurrencePattern
	{
		let RecurrenceType = tape[0];
		let DayComponent = tape[1];
		let WeekdayComponent = tape[2];
		let MonthComponent = tape[3];
		let Position = tape[4];
		let Interval = tape[5];
		let Occurrences = tape[6];
		let TimePeriods = tape[7];
		return new IfcRecurrencePattern(RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.DayComponent){
		args.push(REAL)
		args.push(...this.DayComponent)
		}
		else{ args.push(EMPTY); }
		if(this.WeekdayComponent){
		args.push(REAL)
		args.push(...this.WeekdayComponent)
		}
		else{ args.push(EMPTY); }
		if(this.MonthComponent){
		args.push(REAL)
		args.push(...this.MonthComponent)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REAL)
		args.push(this.Position)
		}
		else{ args.push(EMPTY); }
		if(this.Interval){
		args.push(REAL)
		args.push(this.Interval)
		}
		else{ args.push(EMPTY); }
		if(this.Occurrences){
		args.push(REAL)
		args.push(this.Occurrences)
		}
		else{ args.push(EMPTY); }
		if(this.TimePeriods){
		args.push(SET_BEGIN)
		this.TimePeriods.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReference {
	constructor(TypeIdentifier: IfcIdentifier | null, AttributeIdentifier: IfcIdentifier | null, InstanceName: IfcLabel | null, ListPositions: IfcInteger[] | null, InnerReference: Handle<IfcReference> | null)
	{
		this.TypeIdentifier = TypeIdentifier;
		this.AttributeIdentifier = AttributeIdentifier;
		this.InstanceName = InstanceName;
		this.ListPositions = ListPositions;
		this.InnerReference = InnerReference;
	}
	TypeIdentifier: IfcIdentifier | null;
	AttributeIdentifier: IfcIdentifier | null;
	InstanceName: IfcLabel | null;
	ListPositions: IfcInteger[] | null;
	InnerReference: Handle<IfcReference> | null;
	static FromTape(tape: any[]): IfcReference
	{
		let TypeIdentifier = tape[0];
		let AttributeIdentifier = tape[1];
		let InstanceName = tape[2];
		let ListPositions = tape[3];
		let InnerReference = tape[4];
		return new IfcReference(TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TypeIdentifier){
		args.push(STRING)
		args.push(this.TypeIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.AttributeIdentifier){
		args.push(STRING)
		args.push(this.AttributeIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.InstanceName){
		args.push(STRING)
		args.push(this.InstanceName)
		}
		else{ args.push(EMPTY); }
		if(this.ListPositions){
		args.push(REAL)
		args.push(...this.ListPositions)
		}
		else{ args.push(EMPTY); }
		if(this.InnerReference){
		args.push(REF)
		args.push(this.InnerReference.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReferent {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, PredefinedType: IfcReferentTypeEnum | null, RestartDistance: IfcLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.PredefinedType = PredefinedType;
		this.RestartDistance = RestartDistance;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	PredefinedType: IfcReferentTypeEnum | null;
	RestartDistance: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcReferent
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let PredefinedType = tape[7];
		let RestartDistance = tape[8];
		return new IfcReferent(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.RestartDistance){
		args.push(REAL)
		args.push(this.RestartDistance)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRegularTimeSeries {
	constructor(Name: IfcLabel , Description: IfcText | null, StartTime: IfcDateTime , EndTime: IfcDateTime , TimeSeriesDataType: IfcTimeSeriesDataTypeEnum , DataOrigin: IfcDataOriginEnum , UserDefinedDataOrigin: IfcLabel | null, Unit: IfcUnit | null, TimeStep: IfcTimeMeasure , Values: Handle<IfcTimeSeriesValue>[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.StartTime = StartTime;
		this.EndTime = EndTime;
		this.TimeSeriesDataType = TimeSeriesDataType;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.Unit = Unit;
		this.TimeStep = TimeStep;
		this.Values = Values;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	StartTime: IfcDateTime ;
	EndTime: IfcDateTime ;
	TimeSeriesDataType: IfcTimeSeriesDataTypeEnum ;
	DataOrigin: IfcDataOriginEnum ;
	UserDefinedDataOrigin: IfcLabel | null;
	Unit: IfcUnit | null;
	TimeStep: IfcTimeMeasure ;
	Values: Handle<IfcTimeSeriesValue>[] ;
	static FromTape(tape: any[]): IfcRegularTimeSeries
	{
		let Name = tape[0];
		let Description = tape[1];
		let StartTime = tape[2];
		let EndTime = tape[3];
		let TimeSeriesDataType = tape[4];
		let DataOrigin = tape[5];
		let UserDefinedDataOrigin = tape[6];
		let Unit = tape[7];
		let TimeStep = tape[8];
		let Values = tape[9];
		return new IfcRegularTimeSeries(Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.StartTime)
		args.push(STRING)
		args.push(this.EndTime)
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.TimeStep)
		args.push(SET_BEGIN)
		this.Values.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcReinforcementBarProperties {
	constructor(TotalCrossSectionArea: IfcAreaMeasure , SteelGrade: IfcLabel , BarSurface: IfcReinforcingBarSurfaceEnum | null, EffectiveDepth: IfcLengthMeasure | null, NominalBarDiameter: IfcPositiveLengthMeasure | null, BarCount: IfcCountMeasure | null)
	{
		this.TotalCrossSectionArea = TotalCrossSectionArea;
		this.SteelGrade = SteelGrade;
		this.BarSurface = BarSurface;
		this.EffectiveDepth = EffectiveDepth;
		this.NominalBarDiameter = NominalBarDiameter;
		this.BarCount = BarCount;
	}
	TotalCrossSectionArea: IfcAreaMeasure ;
	SteelGrade: IfcLabel ;
	BarSurface: IfcReinforcingBarSurfaceEnum | null;
	EffectiveDepth: IfcLengthMeasure | null;
	NominalBarDiameter: IfcPositiveLengthMeasure | null;
	BarCount: IfcCountMeasure | null;
	static FromTape(tape: any[]): IfcReinforcementBarProperties
	{
		let TotalCrossSectionArea = tape[0];
		let SteelGrade = tape[1];
		let BarSurface = tape[2];
		let EffectiveDepth = tape[3];
		let NominalBarDiameter = tape[4];
		let BarCount = tape[5];
		return new IfcReinforcementBarProperties(TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.TotalCrossSectionArea)
		args.push(STRING)
		args.push(this.SteelGrade)
		if(this.BarSurface){
		}
		else{ args.push(EMPTY); }
		if(this.EffectiveDepth){
		args.push(REAL)
		args.push(this.EffectiveDepth)
		}
		else{ args.push(EMPTY); }
		if(this.NominalBarDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.BarCount){
		args.push(REAL)
		args.push(this.BarCount)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReinforcementDefinitionProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, DefinitionType: IfcLabel | null, ReinforcementSectionDefinitions: Handle<IfcSectionReinforcementProperties>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.DefinitionType = DefinitionType;
		this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	DefinitionType: IfcLabel | null;
	ReinforcementSectionDefinitions: Handle<IfcSectionReinforcementProperties>[] ;
	static FromTape(tape: any[]): IfcReinforcementDefinitionProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let DefinitionType = tape[4];
		let ReinforcementSectionDefinitions = tape[5];
		return new IfcReinforcementDefinitionProperties(GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.DefinitionType){
		args.push(STRING)
		args.push(this.DefinitionType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.ReinforcementSectionDefinitions.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcReinforcingBar {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, SteelGrade: IfcLabel | null, NominalDiameter: IfcPositiveLengthMeasure | null, CrossSectionArea: IfcAreaMeasure | null, BarLength: IfcPositiveLengthMeasure | null, PredefinedType: IfcReinforcingBarTypeEnum | null, BarSurface: IfcReinforcingBarSurfaceEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.SteelGrade = SteelGrade;
		this.NominalDiameter = NominalDiameter;
		this.CrossSectionArea = CrossSectionArea;
		this.BarLength = BarLength;
		this.PredefinedType = PredefinedType;
		this.BarSurface = BarSurface;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	SteelGrade: IfcLabel | null;
	NominalDiameter: IfcPositiveLengthMeasure | null;
	CrossSectionArea: IfcAreaMeasure | null;
	BarLength: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcReinforcingBarTypeEnum | null;
	BarSurface: IfcReinforcingBarSurfaceEnum | null;
	static FromTape(tape: any[]): IfcReinforcingBar
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let SteelGrade = tape[8];
		let NominalDiameter = tape[9];
		let CrossSectionArea = tape[10];
		let BarLength = tape[11];
		let PredefinedType = tape[12];
		let BarSurface = tape[13];
		return new IfcReinforcingBar(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.SteelGrade){
		args.push(STRING)
		args.push(this.SteelGrade)
		}
		else{ args.push(EMPTY); }
		if(this.NominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.CrossSectionArea){
		args.push(REAL)
		args.push(this.CrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.BarLength){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.BarSurface){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReinforcingBarType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcReinforcingBarTypeEnum , NominalDiameter: IfcPositiveLengthMeasure | null, CrossSectionArea: IfcAreaMeasure | null, BarLength: IfcPositiveLengthMeasure | null, BarSurface: IfcReinforcingBarSurfaceEnum | null, BendingShapeCode: IfcLabel | null, BendingParameters: IfcBendingParameterSelect[] | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.NominalDiameter = NominalDiameter;
		this.CrossSectionArea = CrossSectionArea;
		this.BarLength = BarLength;
		this.BarSurface = BarSurface;
		this.BendingShapeCode = BendingShapeCode;
		this.BendingParameters = BendingParameters;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcReinforcingBarTypeEnum ;
	NominalDiameter: IfcPositiveLengthMeasure | null;
	CrossSectionArea: IfcAreaMeasure | null;
	BarLength: IfcPositiveLengthMeasure | null;
	BarSurface: IfcReinforcingBarSurfaceEnum | null;
	BendingShapeCode: IfcLabel | null;
	BendingParameters: IfcBendingParameterSelect[] | null;
	static FromTape(tape: any[]): IfcReinforcingBarType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let NominalDiameter = tape[10];
		let CrossSectionArea = tape[11];
		let BarLength = tape[12];
		let BarSurface = tape[13];
		let BendingShapeCode = tape[14];
		let BendingParameters = tape[15];
		return new IfcReinforcingBarType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.NominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.CrossSectionArea){
		args.push(REAL)
		args.push(this.CrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.BarLength){
		}
		else{ args.push(EMPTY); }
		if(this.BarSurface){
		}
		else{ args.push(EMPTY); }
		if(this.BendingShapeCode){
		args.push(STRING)
		args.push(this.BendingShapeCode)
		}
		else{ args.push(EMPTY); }
		if(this.BendingParameters){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReinforcingElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, SteelGrade: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.SteelGrade = SteelGrade;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	SteelGrade: IfcLabel | null;
	static FromTape(tape: any[]): IfcReinforcingElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let SteelGrade = tape[8];
		return new IfcReinforcingElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.SteelGrade){
		args.push(STRING)
		args.push(this.SteelGrade)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReinforcingElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcReinforcingElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcReinforcingElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReinforcingMesh {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, SteelGrade: IfcLabel | null, MeshLength: IfcPositiveLengthMeasure | null, MeshWidth: IfcPositiveLengthMeasure | null, LongitudinalBarNominalDiameter: IfcPositiveLengthMeasure | null, TransverseBarNominalDiameter: IfcPositiveLengthMeasure | null, LongitudinalBarCrossSectionArea: IfcAreaMeasure | null, TransverseBarCrossSectionArea: IfcAreaMeasure | null, LongitudinalBarSpacing: IfcPositiveLengthMeasure | null, TransverseBarSpacing: IfcPositiveLengthMeasure | null, PredefinedType: IfcReinforcingMeshTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.SteelGrade = SteelGrade;
		this.MeshLength = MeshLength;
		this.MeshWidth = MeshWidth;
		this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
		this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
		this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
		this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
		this.LongitudinalBarSpacing = LongitudinalBarSpacing;
		this.TransverseBarSpacing = TransverseBarSpacing;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	SteelGrade: IfcLabel | null;
	MeshLength: IfcPositiveLengthMeasure | null;
	MeshWidth: IfcPositiveLengthMeasure | null;
	LongitudinalBarNominalDiameter: IfcPositiveLengthMeasure | null;
	TransverseBarNominalDiameter: IfcPositiveLengthMeasure | null;
	LongitudinalBarCrossSectionArea: IfcAreaMeasure | null;
	TransverseBarCrossSectionArea: IfcAreaMeasure | null;
	LongitudinalBarSpacing: IfcPositiveLengthMeasure | null;
	TransverseBarSpacing: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcReinforcingMeshTypeEnum | null;
	static FromTape(tape: any[]): IfcReinforcingMesh
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let SteelGrade = tape[8];
		let MeshLength = tape[9];
		let MeshWidth = tape[10];
		let LongitudinalBarNominalDiameter = tape[11];
		let TransverseBarNominalDiameter = tape[12];
		let LongitudinalBarCrossSectionArea = tape[13];
		let TransverseBarCrossSectionArea = tape[14];
		let LongitudinalBarSpacing = tape[15];
		let TransverseBarSpacing = tape[16];
		let PredefinedType = tape[17];
		return new IfcReinforcingMesh(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.SteelGrade){
		args.push(STRING)
		args.push(this.SteelGrade)
		}
		else{ args.push(EMPTY); }
		if(this.MeshLength){
		}
		else{ args.push(EMPTY); }
		if(this.MeshWidth){
		}
		else{ args.push(EMPTY); }
		if(this.LongitudinalBarNominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.TransverseBarNominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.LongitudinalBarCrossSectionArea){
		args.push(REAL)
		args.push(this.LongitudinalBarCrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.TransverseBarCrossSectionArea){
		args.push(REAL)
		args.push(this.TransverseBarCrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.LongitudinalBarSpacing){
		}
		else{ args.push(EMPTY); }
		if(this.TransverseBarSpacing){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReinforcingMeshType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcReinforcingMeshTypeEnum , MeshLength: IfcPositiveLengthMeasure | null, MeshWidth: IfcPositiveLengthMeasure | null, LongitudinalBarNominalDiameter: IfcPositiveLengthMeasure | null, TransverseBarNominalDiameter: IfcPositiveLengthMeasure | null, LongitudinalBarCrossSectionArea: IfcAreaMeasure | null, TransverseBarCrossSectionArea: IfcAreaMeasure | null, LongitudinalBarSpacing: IfcPositiveLengthMeasure | null, TransverseBarSpacing: IfcPositiveLengthMeasure | null, BendingShapeCode: IfcLabel | null, BendingParameters: IfcBendingParameterSelect[] | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.MeshLength = MeshLength;
		this.MeshWidth = MeshWidth;
		this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
		this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
		this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
		this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
		this.LongitudinalBarSpacing = LongitudinalBarSpacing;
		this.TransverseBarSpacing = TransverseBarSpacing;
		this.BendingShapeCode = BendingShapeCode;
		this.BendingParameters = BendingParameters;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcReinforcingMeshTypeEnum ;
	MeshLength: IfcPositiveLengthMeasure | null;
	MeshWidth: IfcPositiveLengthMeasure | null;
	LongitudinalBarNominalDiameter: IfcPositiveLengthMeasure | null;
	TransverseBarNominalDiameter: IfcPositiveLengthMeasure | null;
	LongitudinalBarCrossSectionArea: IfcAreaMeasure | null;
	TransverseBarCrossSectionArea: IfcAreaMeasure | null;
	LongitudinalBarSpacing: IfcPositiveLengthMeasure | null;
	TransverseBarSpacing: IfcPositiveLengthMeasure | null;
	BendingShapeCode: IfcLabel | null;
	BendingParameters: IfcBendingParameterSelect[] | null;
	static FromTape(tape: any[]): IfcReinforcingMeshType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let MeshLength = tape[10];
		let MeshWidth = tape[11];
		let LongitudinalBarNominalDiameter = tape[12];
		let TransverseBarNominalDiameter = tape[13];
		let LongitudinalBarCrossSectionArea = tape[14];
		let TransverseBarCrossSectionArea = tape[15];
		let LongitudinalBarSpacing = tape[16];
		let TransverseBarSpacing = tape[17];
		let BendingShapeCode = tape[18];
		let BendingParameters = tape[19];
		return new IfcReinforcingMeshType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.MeshLength){
		}
		else{ args.push(EMPTY); }
		if(this.MeshWidth){
		}
		else{ args.push(EMPTY); }
		if(this.LongitudinalBarNominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.TransverseBarNominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.LongitudinalBarCrossSectionArea){
		args.push(REAL)
		args.push(this.LongitudinalBarCrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.TransverseBarCrossSectionArea){
		args.push(REAL)
		args.push(this.TransverseBarCrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.LongitudinalBarSpacing){
		}
		else{ args.push(EMPTY); }
		if(this.TransverseBarSpacing){
		}
		else{ args.push(EMPTY); }
		if(this.BendingShapeCode){
		args.push(STRING)
		args.push(this.BendingShapeCode)
		}
		else{ args.push(EMPTY); }
		if(this.BendingParameters){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAggregates {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingObject: Handle<IfcObjectDefinition> , RelatedObjects: Handle<IfcObjectDefinition>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingObject = RelatingObject;
		this.RelatedObjects = RelatedObjects;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingObject: Handle<IfcObjectDefinition> ;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	static FromTape(tape: any[]): IfcRelAggregates
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingObject = tape[4];
		let RelatedObjects = tape[5];
		return new IfcRelAggregates(GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingObject.expressID)
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelAssigns {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	static FromTape(tape: any[]): IfcRelAssigns
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		return new IfcRelAssigns(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssignsToActor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingActor: Handle<IfcActor> , ActingRole: Handle<IfcActorRole> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingActor = RelatingActor;
		this.ActingRole = ActingRole;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingActor: Handle<IfcActor> ;
	ActingRole: Handle<IfcActorRole> | null;
	static FromTape(tape: any[]): IfcRelAssignsToActor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingActor = tape[6];
		let ActingRole = tape[7];
		return new IfcRelAssignsToActor(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingActor.expressID)
		if(this.ActingRole){
		args.push(REF)
		args.push(this.ActingRole.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssignsToControl {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingControl: Handle<IfcControl> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingControl = RelatingControl;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingControl: Handle<IfcControl> ;
	static FromTape(tape: any[]): IfcRelAssignsToControl
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingControl = tape[6];
		return new IfcRelAssignsToControl(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingControl.expressID)
		return args;
	}
};
export class IfcRelAssignsToGroup {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingGroup: Handle<IfcGroup> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingGroup = RelatingGroup;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingGroup: Handle<IfcGroup> ;
	static FromTape(tape: any[]): IfcRelAssignsToGroup
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingGroup = tape[6];
		return new IfcRelAssignsToGroup(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingGroup.expressID)
		return args;
	}
};
export class IfcRelAssignsToGroupByFactor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingGroup: Handle<IfcGroup> , Factor: IfcRatioMeasure )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingGroup = RelatingGroup;
		this.Factor = Factor;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingGroup: Handle<IfcGroup> ;
	Factor: IfcRatioMeasure ;
	static FromTape(tape: any[]): IfcRelAssignsToGroupByFactor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingGroup = tape[6];
		let Factor = tape[7];
		return new IfcRelAssignsToGroupByFactor(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingGroup.expressID)
		args.push(REAL)
		args.push(this.Factor)
		return args;
	}
};
export class IfcRelAssignsToProcess {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingProcess: IfcProcessSelect , QuantityInProcess: Handle<IfcMeasureWithUnit> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingProcess = RelatingProcess;
		this.QuantityInProcess = QuantityInProcess;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingProcess: IfcProcessSelect ;
	QuantityInProcess: Handle<IfcMeasureWithUnit> | null;
	static FromTape(tape: any[]): IfcRelAssignsToProcess
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingProcess = tape[6];
		let QuantityInProcess = tape[7];
		return new IfcRelAssignsToProcess(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		if(this.QuantityInProcess){
		args.push(REF)
		args.push(this.QuantityInProcess.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssignsToProduct {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingProduct: IfcProductSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingProduct = RelatingProduct;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingProduct: IfcProductSelect ;
	static FromTape(tape: any[]): IfcRelAssignsToProduct
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingProduct = tape[6];
		return new IfcRelAssignsToProduct(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssignsToResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatedObjectsType: IfcObjectTypeEnum | null, RelatingResource: IfcResourceSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatedObjectsType = RelatedObjectsType;
		this.RelatingResource = RelatingResource;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatedObjectsType: IfcObjectTypeEnum | null;
	RelatingResource: IfcResourceSelect ;
	static FromTape(tape: any[]): IfcRelAssignsToResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatedObjectsType = tape[5];
		let RelatingResource = tape[6];
		return new IfcRelAssignsToResource(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.RelatedObjectsType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssociates {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	static FromTape(tape: any[]): IfcRelAssociates
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		return new IfcRelAssociates(GlobalId, OwnerHistory, Name, Description, RelatedObjects);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssociatesApproval {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] , RelatingApproval: Handle<IfcApproval> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingApproval = RelatingApproval;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	RelatingApproval: Handle<IfcApproval> ;
	static FromTape(tape: any[]): IfcRelAssociatesApproval
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingApproval = tape[5];
		return new IfcRelAssociatesApproval(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingApproval.expressID)
		return args;
	}
};
export class IfcRelAssociatesClassification {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] , RelatingClassification: IfcClassificationSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingClassification = RelatingClassification;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	RelatingClassification: IfcClassificationSelect ;
	static FromTape(tape: any[]): IfcRelAssociatesClassification
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingClassification = tape[5];
		return new IfcRelAssociatesClassification(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssociatesConstraint {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] , Intent: IfcLabel | null, RelatingConstraint: Handle<IfcConstraint> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.Intent = Intent;
		this.RelatingConstraint = RelatingConstraint;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	Intent: IfcLabel | null;
	RelatingConstraint: Handle<IfcConstraint> ;
	static FromTape(tape: any[]): IfcRelAssociatesConstraint
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let Intent = tape[5];
		let RelatingConstraint = tape[6];
		return new IfcRelAssociatesConstraint(GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Intent){
		args.push(STRING)
		args.push(this.Intent)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingConstraint.expressID)
		return args;
	}
};
export class IfcRelAssociatesDocument {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] , RelatingDocument: IfcDocumentSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingDocument = RelatingDocument;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	RelatingDocument: IfcDocumentSelect ;
	static FromTape(tape: any[]): IfcRelAssociatesDocument
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingDocument = tape[5];
		return new IfcRelAssociatesDocument(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssociatesLibrary {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] , RelatingLibrary: IfcLibrarySelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingLibrary = RelatingLibrary;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	RelatingLibrary: IfcLibrarySelect ;
	static FromTape(tape: any[]): IfcRelAssociatesLibrary
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingLibrary = tape[5];
		return new IfcRelAssociatesLibrary(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelAssociatesMaterial {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: IfcDefinitionSelect[] , RelatingMaterial: IfcMaterialSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingMaterial = RelatingMaterial;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: IfcDefinitionSelect[] ;
	RelatingMaterial: IfcMaterialSelect ;
	static FromTape(tape: any[]): IfcRelAssociatesMaterial
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingMaterial = tape[5];
		return new IfcRelAssociatesMaterial(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelConnects {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcRelConnects
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcRelConnects(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelConnectsElements {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ConnectionGeometry: Handle<IfcConnectionGeometry> | null, RelatingElement: Handle<IfcElement> , RelatedElement: Handle<IfcElement> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ConnectionGeometry = ConnectionGeometry;
		this.RelatingElement = RelatingElement;
		this.RelatedElement = RelatedElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ConnectionGeometry: Handle<IfcConnectionGeometry> | null;
	RelatingElement: Handle<IfcElement> ;
	RelatedElement: Handle<IfcElement> ;
	static FromTape(tape: any[]): IfcRelConnectsElements
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ConnectionGeometry = tape[4];
		let RelatingElement = tape[5];
		let RelatedElement = tape[6];
		return new IfcRelConnectsElements(GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ConnectionGeometry){
		args.push(REF)
		args.push(this.ConnectionGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingElement.expressID)
		args.push(REF)
		args.push(this.RelatedElement.expressID)
		return args;
	}
};
export class IfcRelConnectsPathElements {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ConnectionGeometry: Handle<IfcConnectionGeometry> | null, RelatingElement: Handle<IfcElement> , RelatedElement: Handle<IfcElement> , RelatingPriorities: IfcInteger[] , RelatedPriorities: IfcInteger[] , RelatedConnectionType: IfcConnectionTypeEnum , RelatingConnectionType: IfcConnectionTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ConnectionGeometry = ConnectionGeometry;
		this.RelatingElement = RelatingElement;
		this.RelatedElement = RelatedElement;
		this.RelatingPriorities = RelatingPriorities;
		this.RelatedPriorities = RelatedPriorities;
		this.RelatedConnectionType = RelatedConnectionType;
		this.RelatingConnectionType = RelatingConnectionType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ConnectionGeometry: Handle<IfcConnectionGeometry> | null;
	RelatingElement: Handle<IfcElement> ;
	RelatedElement: Handle<IfcElement> ;
	RelatingPriorities: IfcInteger[] ;
	RelatedPriorities: IfcInteger[] ;
	RelatedConnectionType: IfcConnectionTypeEnum ;
	RelatingConnectionType: IfcConnectionTypeEnum ;
	static FromTape(tape: any[]): IfcRelConnectsPathElements
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ConnectionGeometry = tape[4];
		let RelatingElement = tape[5];
		let RelatedElement = tape[6];
		let RelatingPriorities = tape[7];
		let RelatedPriorities = tape[8];
		let RelatedConnectionType = tape[9];
		let RelatingConnectionType = tape[10];
		return new IfcRelConnectsPathElements(GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ConnectionGeometry){
		args.push(REF)
		args.push(this.ConnectionGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingElement.expressID)
		args.push(REF)
		args.push(this.RelatedElement.expressID)
		args.push(REAL)
		args.push(...this.RelatingPriorities)
		args.push(REAL)
		args.push(...this.RelatedPriorities)
		return args;
	}
};
export class IfcRelConnectsPortToElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingPort: Handle<IfcPort> , RelatedElement: Handle<IfcDistributionElement> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingPort = RelatingPort;
		this.RelatedElement = RelatedElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingPort: Handle<IfcPort> ;
	RelatedElement: Handle<IfcDistributionElement> ;
	static FromTape(tape: any[]): IfcRelConnectsPortToElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingPort = tape[4];
		let RelatedElement = tape[5];
		return new IfcRelConnectsPortToElement(GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingPort.expressID)
		args.push(REF)
		args.push(this.RelatedElement.expressID)
		return args;
	}
};
export class IfcRelConnectsPorts {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingPort: Handle<IfcPort> , RelatedPort: Handle<IfcPort> , RealizingElement: Handle<IfcElement> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingPort = RelatingPort;
		this.RelatedPort = RelatedPort;
		this.RealizingElement = RealizingElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingPort: Handle<IfcPort> ;
	RelatedPort: Handle<IfcPort> ;
	RealizingElement: Handle<IfcElement> | null;
	static FromTape(tape: any[]): IfcRelConnectsPorts
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingPort = tape[4];
		let RelatedPort = tape[5];
		let RealizingElement = tape[6];
		return new IfcRelConnectsPorts(GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingPort.expressID)
		args.push(REF)
		args.push(this.RelatedPort.expressID)
		if(this.RealizingElement){
		args.push(REF)
		args.push(this.RealizingElement.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelConnectsStructuralActivity {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingElement: IfcStructuralActivityAssignmentSelect , RelatedStructuralActivity: Handle<IfcStructuralActivity> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingElement = RelatingElement;
		this.RelatedStructuralActivity = RelatedStructuralActivity;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingElement: IfcStructuralActivityAssignmentSelect ;
	RelatedStructuralActivity: Handle<IfcStructuralActivity> ;
	static FromTape(tape: any[]): IfcRelConnectsStructuralActivity
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingElement = tape[4];
		let RelatedStructuralActivity = tape[5];
		return new IfcRelConnectsStructuralActivity(GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatedStructuralActivity.expressID)
		return args;
	}
};
export class IfcRelConnectsStructuralMember {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingStructuralMember: Handle<IfcStructuralMember> , RelatedStructuralConnection: Handle<IfcStructuralConnection> , AppliedCondition: Handle<IfcBoundaryCondition> | null, AdditionalConditions: Handle<IfcStructuralConnectionCondition> | null, SupportedLength: IfcLengthMeasure | null, ConditionCoordinateSystem: Handle<IfcAxis2Placement3D> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingStructuralMember = RelatingStructuralMember;
		this.RelatedStructuralConnection = RelatedStructuralConnection;
		this.AppliedCondition = AppliedCondition;
		this.AdditionalConditions = AdditionalConditions;
		this.SupportedLength = SupportedLength;
		this.ConditionCoordinateSystem = ConditionCoordinateSystem;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingStructuralMember: Handle<IfcStructuralMember> ;
	RelatedStructuralConnection: Handle<IfcStructuralConnection> ;
	AppliedCondition: Handle<IfcBoundaryCondition> | null;
	AdditionalConditions: Handle<IfcStructuralConnectionCondition> | null;
	SupportedLength: IfcLengthMeasure | null;
	ConditionCoordinateSystem: Handle<IfcAxis2Placement3D> | null;
	static FromTape(tape: any[]): IfcRelConnectsStructuralMember
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingStructuralMember = tape[4];
		let RelatedStructuralConnection = tape[5];
		let AppliedCondition = tape[6];
		let AdditionalConditions = tape[7];
		let SupportedLength = tape[8];
		let ConditionCoordinateSystem = tape[9];
		return new IfcRelConnectsStructuralMember(GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingStructuralMember.expressID)
		args.push(REF)
		args.push(this.RelatedStructuralConnection.expressID)
		if(this.AppliedCondition){
		args.push(REF)
		args.push(this.AppliedCondition.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.AdditionalConditions){
		args.push(REF)
		args.push(this.AdditionalConditions.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.SupportedLength){
		args.push(REAL)
		args.push(this.SupportedLength)
		}
		else{ args.push(EMPTY); }
		if(this.ConditionCoordinateSystem){
		args.push(REF)
		args.push(this.ConditionCoordinateSystem.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelConnectsWithEccentricity {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingStructuralMember: Handle<IfcStructuralMember> , RelatedStructuralConnection: Handle<IfcStructuralConnection> , AppliedCondition: Handle<IfcBoundaryCondition> | null, AdditionalConditions: Handle<IfcStructuralConnectionCondition> | null, SupportedLength: IfcLengthMeasure | null, ConditionCoordinateSystem: Handle<IfcAxis2Placement3D> | null, ConnectionConstraint: Handle<IfcConnectionGeometry> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingStructuralMember = RelatingStructuralMember;
		this.RelatedStructuralConnection = RelatedStructuralConnection;
		this.AppliedCondition = AppliedCondition;
		this.AdditionalConditions = AdditionalConditions;
		this.SupportedLength = SupportedLength;
		this.ConditionCoordinateSystem = ConditionCoordinateSystem;
		this.ConnectionConstraint = ConnectionConstraint;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingStructuralMember: Handle<IfcStructuralMember> ;
	RelatedStructuralConnection: Handle<IfcStructuralConnection> ;
	AppliedCondition: Handle<IfcBoundaryCondition> | null;
	AdditionalConditions: Handle<IfcStructuralConnectionCondition> | null;
	SupportedLength: IfcLengthMeasure | null;
	ConditionCoordinateSystem: Handle<IfcAxis2Placement3D> | null;
	ConnectionConstraint: Handle<IfcConnectionGeometry> ;
	static FromTape(tape: any[]): IfcRelConnectsWithEccentricity
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingStructuralMember = tape[4];
		let RelatedStructuralConnection = tape[5];
		let AppliedCondition = tape[6];
		let AdditionalConditions = tape[7];
		let SupportedLength = tape[8];
		let ConditionCoordinateSystem = tape[9];
		let ConnectionConstraint = tape[10];
		return new IfcRelConnectsWithEccentricity(GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingStructuralMember.expressID)
		args.push(REF)
		args.push(this.RelatedStructuralConnection.expressID)
		if(this.AppliedCondition){
		args.push(REF)
		args.push(this.AppliedCondition.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.AdditionalConditions){
		args.push(REF)
		args.push(this.AdditionalConditions.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.SupportedLength){
		args.push(REAL)
		args.push(this.SupportedLength)
		}
		else{ args.push(EMPTY); }
		if(this.ConditionCoordinateSystem){
		args.push(REF)
		args.push(this.ConditionCoordinateSystem.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ConnectionConstraint.expressID)
		return args;
	}
};
export class IfcRelConnectsWithRealizingElements {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ConnectionGeometry: Handle<IfcConnectionGeometry> | null, RelatingElement: Handle<IfcElement> , RelatedElement: Handle<IfcElement> , RealizingElements: Handle<IfcElement>[] , ConnectionType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ConnectionGeometry = ConnectionGeometry;
		this.RelatingElement = RelatingElement;
		this.RelatedElement = RelatedElement;
		this.RealizingElements = RealizingElements;
		this.ConnectionType = ConnectionType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ConnectionGeometry: Handle<IfcConnectionGeometry> | null;
	RelatingElement: Handle<IfcElement> ;
	RelatedElement: Handle<IfcElement> ;
	RealizingElements: Handle<IfcElement>[] ;
	ConnectionType: IfcLabel | null;
	static FromTape(tape: any[]): IfcRelConnectsWithRealizingElements
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ConnectionGeometry = tape[4];
		let RelatingElement = tape[5];
		let RelatedElement = tape[6];
		let RealizingElements = tape[7];
		let ConnectionType = tape[8];
		return new IfcRelConnectsWithRealizingElements(GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ConnectionGeometry){
		args.push(REF)
		args.push(this.ConnectionGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingElement.expressID)
		args.push(REF)
		args.push(this.RelatedElement.expressID)
		args.push(SET_BEGIN)
		this.RealizingElements.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.ConnectionType){
		args.push(STRING)
		args.push(this.ConnectionType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelContainedInSpatialStructure {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedElements: Handle<IfcProduct>[] , RelatingStructure: Handle<IfcSpatialElement> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedElements = RelatedElements;
		this.RelatingStructure = RelatingStructure;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedElements: Handle<IfcProduct>[] ;
	RelatingStructure: Handle<IfcSpatialElement> ;
	static FromTape(tape: any[]): IfcRelContainedInSpatialStructure
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedElements = tape[4];
		let RelatingStructure = tape[5];
		return new IfcRelContainedInSpatialStructure(GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedElements.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RelatingStructure.expressID)
		return args;
	}
};
export class IfcRelCoversBldgElements {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingBuildingElement: Handle<IfcElement> , RelatedCoverings: Handle<IfcCovering>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingBuildingElement = RelatingBuildingElement;
		this.RelatedCoverings = RelatedCoverings;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingBuildingElement: Handle<IfcElement> ;
	RelatedCoverings: Handle<IfcCovering>[] ;
	static FromTape(tape: any[]): IfcRelCoversBldgElements
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingBuildingElement = tape[4];
		let RelatedCoverings = tape[5];
		return new IfcRelCoversBldgElements(GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingBuildingElement.expressID)
		args.push(SET_BEGIN)
		this.RelatedCoverings.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelCoversSpaces {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingSpace: Handle<IfcSpace> , RelatedCoverings: Handle<IfcCovering>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingSpace = RelatingSpace;
		this.RelatedCoverings = RelatedCoverings;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingSpace: Handle<IfcSpace> ;
	RelatedCoverings: Handle<IfcCovering>[] ;
	static FromTape(tape: any[]): IfcRelCoversSpaces
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingSpace = tape[4];
		let RelatedCoverings = tape[5];
		return new IfcRelCoversSpaces(GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingSpace.expressID)
		args.push(SET_BEGIN)
		this.RelatedCoverings.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelDeclares {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingContext: Handle<IfcContext> , RelatedDefinitions: IfcDefinitionSelect[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingContext = RelatingContext;
		this.RelatedDefinitions = RelatedDefinitions;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingContext: Handle<IfcContext> ;
	RelatedDefinitions: IfcDefinitionSelect[] ;
	static FromTape(tape: any[]): IfcRelDeclares
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingContext = tape[4];
		let RelatedDefinitions = tape[5];
		return new IfcRelDeclares(GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingContext.expressID)
		return args;
	}
};
export class IfcRelDecomposes {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcRelDecomposes
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcRelDecomposes(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelDefines {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcRelDefines
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcRelDefines(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelDefinesByObject {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObject>[] , RelatingObject: Handle<IfcObject> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingObject = RelatingObject;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObject>[] ;
	RelatingObject: Handle<IfcObject> ;
	static FromTape(tape: any[]): IfcRelDefinesByObject
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingObject = tape[5];
		return new IfcRelDefinesByObject(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RelatingObject.expressID)
		return args;
	}
};
export class IfcRelDefinesByProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObjectDefinition>[] , RelatingPropertyDefinition: IfcPropertySetDefinitionSelect )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingPropertyDefinition = RelatingPropertyDefinition;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	RelatingPropertyDefinition: IfcPropertySetDefinitionSelect ;
	static FromTape(tape: any[]): IfcRelDefinesByProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingPropertyDefinition = tape[5];
		return new IfcRelDefinesByProperties(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelDefinesByTemplate {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedPropertySets: Handle<IfcPropertySetDefinition>[] , RelatingTemplate: Handle<IfcPropertySetTemplate> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedPropertySets = RelatedPropertySets;
		this.RelatingTemplate = RelatingTemplate;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedPropertySets: Handle<IfcPropertySetDefinition>[] ;
	RelatingTemplate: Handle<IfcPropertySetTemplate> ;
	static FromTape(tape: any[]): IfcRelDefinesByTemplate
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedPropertySets = tape[4];
		let RelatingTemplate = tape[5];
		return new IfcRelDefinesByTemplate(GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RelatingTemplate.expressID)
		return args;
	}
};
export class IfcRelDefinesByType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedObjects: Handle<IfcObject>[] , RelatingType: Handle<IfcTypeObject> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedObjects = RelatedObjects;
		this.RelatingType = RelatingType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedObjects: Handle<IfcObject>[] ;
	RelatingType: Handle<IfcTypeObject> ;
	static FromTape(tape: any[]): IfcRelDefinesByType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedObjects = tape[4];
		let RelatingType = tape[5];
		return new IfcRelDefinesByType(GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RelatingType.expressID)
		return args;
	}
};
export class IfcRelFillsElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingOpeningElement: Handle<IfcOpeningElement> , RelatedBuildingElement: Handle<IfcElement> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingOpeningElement = RelatingOpeningElement;
		this.RelatedBuildingElement = RelatedBuildingElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingOpeningElement: Handle<IfcOpeningElement> ;
	RelatedBuildingElement: Handle<IfcElement> ;
	static FromTape(tape: any[]): IfcRelFillsElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingOpeningElement = tape[4];
		let RelatedBuildingElement = tape[5];
		return new IfcRelFillsElement(GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingOpeningElement.expressID)
		args.push(REF)
		args.push(this.RelatedBuildingElement.expressID)
		return args;
	}
};
export class IfcRelFlowControlElements {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedControlElements: Handle<IfcDistributionControlElement>[] , RelatingFlowElement: Handle<IfcDistributionFlowElement> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedControlElements = RelatedControlElements;
		this.RelatingFlowElement = RelatingFlowElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedControlElements: Handle<IfcDistributionControlElement>[] ;
	RelatingFlowElement: Handle<IfcDistributionFlowElement> ;
	static FromTape(tape: any[]): IfcRelFlowControlElements
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedControlElements = tape[4];
		let RelatingFlowElement = tape[5];
		return new IfcRelFlowControlElements(GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedControlElements.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RelatingFlowElement.expressID)
		return args;
	}
};
export class IfcRelInterferesElements {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingElement: Handle<IfcElement> , RelatedElement: Handle<IfcElement> , InterferenceGeometry: Handle<IfcConnectionGeometry> | null, InterferenceType: IfcIdentifier | null, ImpliedOrder: Handle<boolean> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingElement = RelatingElement;
		this.RelatedElement = RelatedElement;
		this.InterferenceGeometry = InterferenceGeometry;
		this.InterferenceType = InterferenceType;
		this.ImpliedOrder = ImpliedOrder;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingElement: Handle<IfcElement> ;
	RelatedElement: Handle<IfcElement> ;
	InterferenceGeometry: Handle<IfcConnectionGeometry> | null;
	InterferenceType: IfcIdentifier | null;
	ImpliedOrder: Handle<boolean> ;
	static FromTape(tape: any[]): IfcRelInterferesElements
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingElement = tape[4];
		let RelatedElement = tape[5];
		let InterferenceGeometry = tape[6];
		let InterferenceType = tape[7];
		let ImpliedOrder = tape[8];
		return new IfcRelInterferesElements(GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingElement.expressID)
		args.push(REF)
		args.push(this.RelatedElement.expressID)
		if(this.InterferenceGeometry){
		args.push(REF)
		args.push(this.InterferenceGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.InterferenceType){
		args.push(STRING)
		args.push(this.InterferenceType)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ImpliedOrder.expressID)
		return args;
	}
};
export class IfcRelNests {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingObject: Handle<IfcObjectDefinition> , RelatedObjects: Handle<IfcObjectDefinition>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingObject = RelatingObject;
		this.RelatedObjects = RelatedObjects;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingObject: Handle<IfcObjectDefinition> ;
	RelatedObjects: Handle<IfcObjectDefinition>[] ;
	static FromTape(tape: any[]): IfcRelNests
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingObject = tape[4];
		let RelatedObjects = tape[5];
		return new IfcRelNests(GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingObject.expressID)
		args.push(SET_BEGIN)
		this.RelatedObjects.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelPositions {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingPositioningElement: Handle<IfcPositioningElement> , RelatedProducts: Handle<IfcProduct>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingPositioningElement = RelatingPositioningElement;
		this.RelatedProducts = RelatedProducts;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingPositioningElement: Handle<IfcPositioningElement> ;
	RelatedProducts: Handle<IfcProduct>[] ;
	static FromTape(tape: any[]): IfcRelPositions
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingPositioningElement = tape[4];
		let RelatedProducts = tape[5];
		return new IfcRelPositions(GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingPositioningElement.expressID)
		args.push(SET_BEGIN)
		this.RelatedProducts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelProjectsElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingElement: Handle<IfcElement> , RelatedFeatureElement: Handle<IfcFeatureElementAddition> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingElement = RelatingElement;
		this.RelatedFeatureElement = RelatedFeatureElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingElement: Handle<IfcElement> ;
	RelatedFeatureElement: Handle<IfcFeatureElementAddition> ;
	static FromTape(tape: any[]): IfcRelProjectsElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingElement = tape[4];
		let RelatedFeatureElement = tape[5];
		return new IfcRelProjectsElement(GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingElement.expressID)
		args.push(REF)
		args.push(this.RelatedFeatureElement.expressID)
		return args;
	}
};
export class IfcRelReferencedInSpatialStructure {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatedElements: Handle<IfcProduct>[] , RelatingStructure: Handle<IfcSpatialElement> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatedElements = RelatedElements;
		this.RelatingStructure = RelatingStructure;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedElements: Handle<IfcProduct>[] ;
	RelatingStructure: Handle<IfcSpatialElement> ;
	static FromTape(tape: any[]): IfcRelReferencedInSpatialStructure
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatedElements = tape[4];
		let RelatingStructure = tape[5];
		return new IfcRelReferencedInSpatialStructure(GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.RelatedElements.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.RelatingStructure.expressID)
		return args;
	}
};
export class IfcRelSequence {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingProcess: Handle<IfcProcess> , RelatedProcess: Handle<IfcProcess> , TimeLag: Handle<IfcLagTime> | null, SequenceType: IfcSequenceEnum | null, UserDefinedSequenceType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingProcess = RelatingProcess;
		this.RelatedProcess = RelatedProcess;
		this.TimeLag = TimeLag;
		this.SequenceType = SequenceType;
		this.UserDefinedSequenceType = UserDefinedSequenceType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingProcess: Handle<IfcProcess> ;
	RelatedProcess: Handle<IfcProcess> ;
	TimeLag: Handle<IfcLagTime> | null;
	SequenceType: IfcSequenceEnum | null;
	UserDefinedSequenceType: IfcLabel | null;
	static FromTape(tape: any[]): IfcRelSequence
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingProcess = tape[4];
		let RelatedProcess = tape[5];
		let TimeLag = tape[6];
		let SequenceType = tape[7];
		let UserDefinedSequenceType = tape[8];
		return new IfcRelSequence(GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingProcess.expressID)
		args.push(REF)
		args.push(this.RelatedProcess.expressID)
		if(this.TimeLag){
		args.push(REF)
		args.push(this.TimeLag.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.SequenceType){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedSequenceType){
		args.push(STRING)
		args.push(this.UserDefinedSequenceType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelServicesBuildings {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingSystem: Handle<IfcSystem> , RelatedBuildings: Handle<IfcSpatialElement>[] )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingSystem = RelatingSystem;
		this.RelatedBuildings = RelatedBuildings;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingSystem: Handle<IfcSystem> ;
	RelatedBuildings: Handle<IfcSpatialElement>[] ;
	static FromTape(tape: any[]): IfcRelServicesBuildings
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingSystem = tape[4];
		let RelatedBuildings = tape[5];
		return new IfcRelServicesBuildings(GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingSystem.expressID)
		args.push(SET_BEGIN)
		this.RelatedBuildings.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRelSpaceBoundary {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingSpace: IfcSpaceBoundarySelect , RelatedBuildingElement: Handle<IfcElement> , ConnectionGeometry: Handle<IfcConnectionGeometry> | null, PhysicalOrVirtualBoundary: IfcPhysicalOrVirtualEnum , InternalOrExternalBoundary: IfcInternalOrExternalEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingSpace = RelatingSpace;
		this.RelatedBuildingElement = RelatedBuildingElement;
		this.ConnectionGeometry = ConnectionGeometry;
		this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
		this.InternalOrExternalBoundary = InternalOrExternalBoundary;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingSpace: IfcSpaceBoundarySelect ;
	RelatedBuildingElement: Handle<IfcElement> ;
	ConnectionGeometry: Handle<IfcConnectionGeometry> | null;
	PhysicalOrVirtualBoundary: IfcPhysicalOrVirtualEnum ;
	InternalOrExternalBoundary: IfcInternalOrExternalEnum ;
	static FromTape(tape: any[]): IfcRelSpaceBoundary
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingSpace = tape[4];
		let RelatedBuildingElement = tape[5];
		let ConnectionGeometry = tape[6];
		let PhysicalOrVirtualBoundary = tape[7];
		let InternalOrExternalBoundary = tape[8];
		return new IfcRelSpaceBoundary(GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatedBuildingElement.expressID)
		if(this.ConnectionGeometry){
		args.push(REF)
		args.push(this.ConnectionGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelSpaceBoundary1stLevel {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingSpace: IfcSpaceBoundarySelect , RelatedBuildingElement: Handle<IfcElement> , ConnectionGeometry: Handle<IfcConnectionGeometry> | null, PhysicalOrVirtualBoundary: IfcPhysicalOrVirtualEnum , InternalOrExternalBoundary: IfcInternalOrExternalEnum , ParentBoundary: Handle<IfcRelSpaceBoundary1stLevel> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingSpace = RelatingSpace;
		this.RelatedBuildingElement = RelatedBuildingElement;
		this.ConnectionGeometry = ConnectionGeometry;
		this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
		this.InternalOrExternalBoundary = InternalOrExternalBoundary;
		this.ParentBoundary = ParentBoundary;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingSpace: IfcSpaceBoundarySelect ;
	RelatedBuildingElement: Handle<IfcElement> ;
	ConnectionGeometry: Handle<IfcConnectionGeometry> | null;
	PhysicalOrVirtualBoundary: IfcPhysicalOrVirtualEnum ;
	InternalOrExternalBoundary: IfcInternalOrExternalEnum ;
	ParentBoundary: Handle<IfcRelSpaceBoundary1stLevel> | null;
	static FromTape(tape: any[]): IfcRelSpaceBoundary1stLevel
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingSpace = tape[4];
		let RelatedBuildingElement = tape[5];
		let ConnectionGeometry = tape[6];
		let PhysicalOrVirtualBoundary = tape[7];
		let InternalOrExternalBoundary = tape[8];
		let ParentBoundary = tape[9];
		return new IfcRelSpaceBoundary1stLevel(GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatedBuildingElement.expressID)
		if(this.ConnectionGeometry){
		args.push(REF)
		args.push(this.ConnectionGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.ParentBoundary){
		args.push(REF)
		args.push(this.ParentBoundary.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelSpaceBoundary2ndLevel {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingSpace: IfcSpaceBoundarySelect , RelatedBuildingElement: Handle<IfcElement> , ConnectionGeometry: Handle<IfcConnectionGeometry> | null, PhysicalOrVirtualBoundary: IfcPhysicalOrVirtualEnum , InternalOrExternalBoundary: IfcInternalOrExternalEnum , ParentBoundary: Handle<IfcRelSpaceBoundary1stLevel> | null, CorrespondingBoundary: Handle<IfcRelSpaceBoundary2ndLevel> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingSpace = RelatingSpace;
		this.RelatedBuildingElement = RelatedBuildingElement;
		this.ConnectionGeometry = ConnectionGeometry;
		this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
		this.InternalOrExternalBoundary = InternalOrExternalBoundary;
		this.ParentBoundary = ParentBoundary;
		this.CorrespondingBoundary = CorrespondingBoundary;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingSpace: IfcSpaceBoundarySelect ;
	RelatedBuildingElement: Handle<IfcElement> ;
	ConnectionGeometry: Handle<IfcConnectionGeometry> | null;
	PhysicalOrVirtualBoundary: IfcPhysicalOrVirtualEnum ;
	InternalOrExternalBoundary: IfcInternalOrExternalEnum ;
	ParentBoundary: Handle<IfcRelSpaceBoundary1stLevel> | null;
	CorrespondingBoundary: Handle<IfcRelSpaceBoundary2ndLevel> | null;
	static FromTape(tape: any[]): IfcRelSpaceBoundary2ndLevel
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingSpace = tape[4];
		let RelatedBuildingElement = tape[5];
		let ConnectionGeometry = tape[6];
		let PhysicalOrVirtualBoundary = tape[7];
		let InternalOrExternalBoundary = tape[8];
		let ParentBoundary = tape[9];
		let CorrespondingBoundary = tape[10];
		return new IfcRelSpaceBoundary2ndLevel(GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatedBuildingElement.expressID)
		if(this.ConnectionGeometry){
		args.push(REF)
		args.push(this.ConnectionGeometry.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.ParentBoundary){
		args.push(REF)
		args.push(this.ParentBoundary.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.CorrespondingBoundary){
		args.push(REF)
		args.push(this.CorrespondingBoundary.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRelVoidsElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, RelatingBuildingElement: Handle<IfcElement> , RelatedOpeningElement: Handle<IfcFeatureElementSubtraction> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.RelatingBuildingElement = RelatingBuildingElement;
		this.RelatedOpeningElement = RelatedOpeningElement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingBuildingElement: Handle<IfcElement> ;
	RelatedOpeningElement: Handle<IfcFeatureElementSubtraction> ;
	static FromTape(tape: any[]): IfcRelVoidsElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let RelatingBuildingElement = tape[4];
		let RelatedOpeningElement = tape[5];
		return new IfcRelVoidsElement(GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingBuildingElement.expressID)
		args.push(REF)
		args.push(this.RelatedOpeningElement.expressID)
		return args;
	}
};
export class IfcRelationship {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcRelationship
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcRelationship(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcReparametrisedCompositeCurveSegment {
	constructor(Transition: IfcTransitionCode , SameSense: IfcBoolean , ParentCurve: Handle<IfcCurve> , ParamLength: IfcParameterValue )
	{
		this.Transition = Transition;
		this.SameSense = SameSense;
		this.ParentCurve = ParentCurve;
		this.ParamLength = ParamLength;
	}
	Transition: IfcTransitionCode ;
	SameSense: IfcBoolean ;
	ParentCurve: Handle<IfcCurve> ;
	ParamLength: IfcParameterValue ;
	static FromTape(tape: any[]): IfcReparametrisedCompositeCurveSegment
	{
		let Transition = tape[0];
		let SameSense = tape[1];
		let ParentCurve = tape[2];
		let ParamLength = tape[3];
		return new IfcReparametrisedCompositeCurveSegment(Transition, SameSense, ParentCurve, ParamLength);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ParentCurve.expressID)
		args.push(REAL)
		args.push(this.ParamLength)
		return args;
	}
};
export class IfcRepresentation {
	constructor(ContextOfItems: Handle<IfcRepresentationContext> , RepresentationIdentifier: IfcLabel | null, RepresentationType: IfcLabel | null, Items: Handle<IfcRepresentationItem>[] )
	{
		this.ContextOfItems = ContextOfItems;
		this.RepresentationIdentifier = RepresentationIdentifier;
		this.RepresentationType = RepresentationType;
		this.Items = Items;
	}
	ContextOfItems: Handle<IfcRepresentationContext> ;
	RepresentationIdentifier: IfcLabel | null;
	RepresentationType: IfcLabel | null;
	Items: Handle<IfcRepresentationItem>[] ;
	static FromTape(tape: any[]): IfcRepresentation
	{
		let ContextOfItems = tape[0];
		let RepresentationIdentifier = tape[1];
		let RepresentationType = tape[2];
		let Items = tape[3];
		return new IfcRepresentation(ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ContextOfItems.expressID)
		if(this.RepresentationIdentifier){
		args.push(STRING)
		args.push(this.RepresentationIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationType){
		args.push(STRING)
		args.push(this.RepresentationType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Items.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcRepresentationContext {
	constructor(ContextIdentifier: IfcLabel | null, ContextType: IfcLabel | null)
	{
		this.ContextIdentifier = ContextIdentifier;
		this.ContextType = ContextType;
	}
	ContextIdentifier: IfcLabel | null;
	ContextType: IfcLabel | null;
	static FromTape(tape: any[]): IfcRepresentationContext
	{
		let ContextIdentifier = tape[0];
		let ContextType = tape[1];
		return new IfcRepresentationContext(ContextIdentifier, ContextType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ContextIdentifier){
		args.push(STRING)
		args.push(this.ContextIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.ContextType){
		args.push(STRING)
		args.push(this.ContextType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRepresentationItem {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcRepresentationItem
	{
		return new IfcRepresentationItem();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcRepresentationMap {
	constructor(MappingOrigin: IfcAxis2Placement , MappedRepresentation: Handle<IfcRepresentation> )
	{
		this.MappingOrigin = MappingOrigin;
		this.MappedRepresentation = MappedRepresentation;
	}
	MappingOrigin: IfcAxis2Placement ;
	MappedRepresentation: Handle<IfcRepresentation> ;
	static FromTape(tape: any[]): IfcRepresentationMap
	{
		let MappingOrigin = tape[0];
		let MappedRepresentation = tape[1];
		return new IfcRepresentationMap(MappingOrigin, MappedRepresentation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.MappedRepresentation.expressID)
		return args;
	}
};
export class IfcResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	static FromTape(tape: any[]): IfcResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		return new IfcResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcResourceApprovalRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatedResourceObjects: IfcResourceObjectSelect[] , RelatingApproval: Handle<IfcApproval> )
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatedResourceObjects = RelatedResourceObjects;
		this.RelatingApproval = RelatingApproval;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatedResourceObjects: IfcResourceObjectSelect[] ;
	RelatingApproval: Handle<IfcApproval> ;
	static FromTape(tape: any[]): IfcResourceApprovalRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatedResourceObjects = tape[2];
		let RelatingApproval = tape[3];
		return new IfcResourceApprovalRelationship(Name, Description, RelatedResourceObjects, RelatingApproval);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingApproval.expressID)
		return args;
	}
};
export class IfcResourceConstraintRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null, RelatingConstraint: Handle<IfcConstraint> , RelatedResourceObjects: IfcResourceObjectSelect[] )
	{
		this.Name = Name;
		this.Description = Description;
		this.RelatingConstraint = RelatingConstraint;
		this.RelatedResourceObjects = RelatedResourceObjects;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	RelatingConstraint: Handle<IfcConstraint> ;
	RelatedResourceObjects: IfcResourceObjectSelect[] ;
	static FromTape(tape: any[]): IfcResourceConstraintRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		let RelatingConstraint = tape[2];
		let RelatedResourceObjects = tape[3];
		return new IfcResourceConstraintRelationship(Name, Description, RelatingConstraint, RelatedResourceObjects);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.RelatingConstraint.expressID)
		return args;
	}
};
export class IfcResourceLevelRelationship {
	constructor(Name: IfcLabel | null, Description: IfcText | null)
	{
		this.Name = Name;
		this.Description = Description;
	}
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcResourceLevelRelationship
	{
		let Name = tape[0];
		let Description = tape[1];
		return new IfcResourceLevelRelationship(Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcResourceTime {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null, ScheduleWork: IfcDuration | null, ScheduleUsage: IfcPositiveRatioMeasure | null, ScheduleStart: IfcDateTime | null, ScheduleFinish: IfcDateTime | null, ScheduleContour: IfcLabel | null, LevelingDelay: IfcDuration | null, IsOverAllocated: IfcBoolean | null, StatusTime: IfcDateTime | null, ActualWork: IfcDuration | null, ActualUsage: IfcPositiveRatioMeasure | null, ActualStart: IfcDateTime | null, ActualFinish: IfcDateTime | null, RemainingWork: IfcDuration | null, RemainingUsage: IfcPositiveRatioMeasure | null, Completion: IfcPositiveRatioMeasure | null)
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.ScheduleWork = ScheduleWork;
		this.ScheduleUsage = ScheduleUsage;
		this.ScheduleStart = ScheduleStart;
		this.ScheduleFinish = ScheduleFinish;
		this.ScheduleContour = ScheduleContour;
		this.LevelingDelay = LevelingDelay;
		this.IsOverAllocated = IsOverAllocated;
		this.StatusTime = StatusTime;
		this.ActualWork = ActualWork;
		this.ActualUsage = ActualUsage;
		this.ActualStart = ActualStart;
		this.ActualFinish = ActualFinish;
		this.RemainingWork = RemainingWork;
		this.RemainingUsage = RemainingUsage;
		this.Completion = Completion;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	ScheduleWork: IfcDuration | null;
	ScheduleUsage: IfcPositiveRatioMeasure | null;
	ScheduleStart: IfcDateTime | null;
	ScheduleFinish: IfcDateTime | null;
	ScheduleContour: IfcLabel | null;
	LevelingDelay: IfcDuration | null;
	IsOverAllocated: IfcBoolean | null;
	StatusTime: IfcDateTime | null;
	ActualWork: IfcDuration | null;
	ActualUsage: IfcPositiveRatioMeasure | null;
	ActualStart: IfcDateTime | null;
	ActualFinish: IfcDateTime | null;
	RemainingWork: IfcDuration | null;
	RemainingUsage: IfcPositiveRatioMeasure | null;
	Completion: IfcPositiveRatioMeasure | null;
	static FromTape(tape: any[]): IfcResourceTime
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		let ScheduleWork = tape[3];
		let ScheduleUsage = tape[4];
		let ScheduleStart = tape[5];
		let ScheduleFinish = tape[6];
		let ScheduleContour = tape[7];
		let LevelingDelay = tape[8];
		let IsOverAllocated = tape[9];
		let StatusTime = tape[10];
		let ActualWork = tape[11];
		let ActualUsage = tape[12];
		let ActualStart = tape[13];
		let ActualFinish = tape[14];
		let RemainingWork = tape[15];
		let RemainingUsage = tape[16];
		let Completion = tape[17];
		return new IfcResourceTime(Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleWork){
		args.push(STRING)
		args.push(this.ScheduleWork)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleUsage){
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleStart){
		args.push(STRING)
		args.push(this.ScheduleStart)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleFinish){
		args.push(STRING)
		args.push(this.ScheduleFinish)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleContour){
		args.push(STRING)
		args.push(this.ScheduleContour)
		}
		else{ args.push(EMPTY); }
		if(this.LevelingDelay){
		args.push(STRING)
		args.push(this.LevelingDelay)
		}
		else{ args.push(EMPTY); }
		if(this.IsOverAllocated){
		}
		else{ args.push(EMPTY); }
		if(this.StatusTime){
		args.push(STRING)
		args.push(this.StatusTime)
		}
		else{ args.push(EMPTY); }
		if(this.ActualWork){
		args.push(STRING)
		args.push(this.ActualWork)
		}
		else{ args.push(EMPTY); }
		if(this.ActualUsage){
		}
		else{ args.push(EMPTY); }
		if(this.ActualStart){
		args.push(STRING)
		args.push(this.ActualStart)
		}
		else{ args.push(EMPTY); }
		if(this.ActualFinish){
		args.push(STRING)
		args.push(this.ActualFinish)
		}
		else{ args.push(EMPTY); }
		if(this.RemainingWork){
		args.push(STRING)
		args.push(this.RemainingWork)
		}
		else{ args.push(EMPTY); }
		if(this.RemainingUsage){
		}
		else{ args.push(EMPTY); }
		if(this.Completion){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRevolvedAreaSolid {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, Axis: Handle<IfcAxis1Placement> , Angle: IfcPlaneAngleMeasure )
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
		this.Axis = Axis;
		this.Angle = Angle;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	Axis: Handle<IfcAxis1Placement> ;
	Angle: IfcPlaneAngleMeasure ;
	static FromTape(tape: any[]): IfcRevolvedAreaSolid
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		let Axis = tape[2];
		let Angle = tape[3];
		return new IfcRevolvedAreaSolid(SweptArea, Position, Axis, Angle);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		args.push(REAL)
		args.push(this.Angle)
		return args;
	}
};
export class IfcRevolvedAreaSolidTapered {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, Axis: Handle<IfcAxis1Placement> , Angle: IfcPlaneAngleMeasure , EndSweptArea: Handle<IfcProfileDef> )
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
		this.Axis = Axis;
		this.Angle = Angle;
		this.EndSweptArea = EndSweptArea;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	Axis: Handle<IfcAxis1Placement> ;
	Angle: IfcPlaneAngleMeasure ;
	EndSweptArea: Handle<IfcProfileDef> ;
	static FromTape(tape: any[]): IfcRevolvedAreaSolidTapered
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		let Axis = tape[2];
		let Angle = tape[3];
		let EndSweptArea = tape[4];
		return new IfcRevolvedAreaSolidTapered(SweptArea, Position, Axis, Angle, EndSweptArea);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		args.push(REAL)
		args.push(this.Angle)
		args.push(REF)
		args.push(this.EndSweptArea.expressID)
		return args;
	}
};
export class IfcRightCircularCone {
	constructor(Position: Handle<IfcAxis2Placement3D> , Height: IfcPositiveLengthMeasure , BottomRadius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.Height = Height;
		this.BottomRadius = BottomRadius;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	Height: IfcPositiveLengthMeasure ;
	BottomRadius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcRightCircularCone
	{
		let Position = tape[0];
		let Height = tape[1];
		let BottomRadius = tape[2];
		return new IfcRightCircularCone(Position, Height, BottomRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcRightCircularCylinder {
	constructor(Position: Handle<IfcAxis2Placement3D> , Height: IfcPositiveLengthMeasure , Radius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.Height = Height;
		this.Radius = Radius;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	Height: IfcPositiveLengthMeasure ;
	Radius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcRightCircularCylinder
	{
		let Position = tape[0];
		let Height = tape[1];
		let Radius = tape[2];
		return new IfcRightCircularCylinder(Position, Height, Radius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcRoof {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcRoofTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcRoofTypeEnum | null;
	static FromTape(tape: any[]): IfcRoof
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcRoof(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRoofType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcRoofTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcRoofTypeEnum ;
	static FromTape(tape: any[]): IfcRoofType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcRoofType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRoot {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcRoot
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		return new IfcRoot(GlobalId, OwnerHistory, Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcRoundedRectangleProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, XDim: IfcPositiveLengthMeasure , YDim: IfcPositiveLengthMeasure , RoundingRadius: IfcPositiveLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.XDim = XDim;
		this.YDim = YDim;
		this.RoundingRadius = RoundingRadius;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	XDim: IfcPositiveLengthMeasure ;
	YDim: IfcPositiveLengthMeasure ;
	RoundingRadius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcRoundedRectangleProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let XDim = tape[3];
		let YDim = tape[4];
		let RoundingRadius = tape[5];
		return new IfcRoundedRectangleProfileDef(ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSIUnit {
	constructor(Dimensions: Handle<IfcDimensionalExponents> , UnitType: IfcUnitEnum , Prefix: IfcSIPrefix | null, Name: IfcSIUnitName )
	{
		this.Dimensions = Dimensions;
		this.UnitType = UnitType;
		this.Prefix = Prefix;
		this.Name = Name;
	}
	Dimensions: Handle<IfcDimensionalExponents> ;
	UnitType: IfcUnitEnum ;
	Prefix: IfcSIPrefix | null;
	Name: IfcSIUnitName ;
	static FromTape(tape: any[]): IfcSIUnit
	{
		let Dimensions = tape[0];
		let UnitType = tape[1];
		let Prefix = tape[2];
		let Name = tape[3];
		return new IfcSIUnit(Dimensions, UnitType, Prefix, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Dimensions.expressID)
		if(this.Prefix){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSanitaryTerminal {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSanitaryTerminalTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSanitaryTerminalTypeEnum | null;
	static FromTape(tape: any[]): IfcSanitaryTerminal
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSanitaryTerminal(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSanitaryTerminalType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSanitaryTerminalTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSanitaryTerminalTypeEnum ;
	static FromTape(tape: any[]): IfcSanitaryTerminalType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSanitaryTerminalType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSchedulingTime {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null)
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	static FromTape(tape: any[]): IfcSchedulingTime
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		return new IfcSchedulingTime(Name, DataOrigin, UserDefinedDataOrigin);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSeamCurve {
	constructor(Curve3D: Handle<IfcCurve> , AssociatedGeometry: Handle<IfcPcurve>[] , MasterRepresentation: IfcPreferredSurfaceCurveRepresentation )
	{
		this.Curve3D = Curve3D;
		this.AssociatedGeometry = AssociatedGeometry;
		this.MasterRepresentation = MasterRepresentation;
	}
	Curve3D: Handle<IfcCurve> ;
	AssociatedGeometry: Handle<IfcPcurve>[] ;
	MasterRepresentation: IfcPreferredSurfaceCurveRepresentation ;
	static FromTape(tape: any[]): IfcSeamCurve
	{
		let Curve3D = tape[0];
		let AssociatedGeometry = tape[1];
		let MasterRepresentation = tape[2];
		return new IfcSeamCurve(Curve3D, AssociatedGeometry, MasterRepresentation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Curve3D.expressID)
		args.push(SET_BEGIN)
		this.AssociatedGeometry.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSectionProperties {
	constructor(SectionType: IfcSectionTypeEnum , StartProfile: Handle<IfcProfileDef> , EndProfile: Handle<IfcProfileDef> | null)
	{
		this.SectionType = SectionType;
		this.StartProfile = StartProfile;
		this.EndProfile = EndProfile;
	}
	SectionType: IfcSectionTypeEnum ;
	StartProfile: Handle<IfcProfileDef> ;
	EndProfile: Handle<IfcProfileDef> | null;
	static FromTape(tape: any[]): IfcSectionProperties
	{
		let SectionType = tape[0];
		let StartProfile = tape[1];
		let EndProfile = tape[2];
		return new IfcSectionProperties(SectionType, StartProfile, EndProfile);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.StartProfile.expressID)
		if(this.EndProfile){
		args.push(REF)
		args.push(this.EndProfile.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSectionReinforcementProperties {
	constructor(LongitudinalStartPosition: IfcLengthMeasure , LongitudinalEndPosition: IfcLengthMeasure , TransversePosition: IfcLengthMeasure | null, ReinforcementRole: IfcReinforcingBarRoleEnum , SectionDefinition: Handle<IfcSectionProperties> , CrossSectionReinforcementDefinitions: Handle<IfcReinforcementBarProperties>[] )
	{
		this.LongitudinalStartPosition = LongitudinalStartPosition;
		this.LongitudinalEndPosition = LongitudinalEndPosition;
		this.TransversePosition = TransversePosition;
		this.ReinforcementRole = ReinforcementRole;
		this.SectionDefinition = SectionDefinition;
		this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
	}
	LongitudinalStartPosition: IfcLengthMeasure ;
	LongitudinalEndPosition: IfcLengthMeasure ;
	TransversePosition: IfcLengthMeasure | null;
	ReinforcementRole: IfcReinforcingBarRoleEnum ;
	SectionDefinition: Handle<IfcSectionProperties> ;
	CrossSectionReinforcementDefinitions: Handle<IfcReinforcementBarProperties>[] ;
	static FromTape(tape: any[]): IfcSectionReinforcementProperties
	{
		let LongitudinalStartPosition = tape[0];
		let LongitudinalEndPosition = tape[1];
		let TransversePosition = tape[2];
		let ReinforcementRole = tape[3];
		let SectionDefinition = tape[4];
		let CrossSectionReinforcementDefinitions = tape[5];
		return new IfcSectionReinforcementProperties(LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(this.LongitudinalStartPosition)
		args.push(REAL)
		args.push(this.LongitudinalEndPosition)
		if(this.TransversePosition){
		args.push(REAL)
		args.push(this.TransversePosition)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.SectionDefinition.expressID)
		args.push(SET_BEGIN)
		this.CrossSectionReinforcementDefinitions.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSectionedSolid {
	constructor(Directrix: Handle<IfcCurve> , CrossSections: Handle<IfcProfileDef>[] )
	{
		this.Directrix = Directrix;
		this.CrossSections = CrossSections;
	}
	Directrix: Handle<IfcCurve> ;
	CrossSections: Handle<IfcProfileDef>[] ;
	static FromTape(tape: any[]): IfcSectionedSolid
	{
		let Directrix = tape[0];
		let CrossSections = tape[1];
		return new IfcSectionedSolid(Directrix, CrossSections);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Directrix.expressID)
		args.push(SET_BEGIN)
		this.CrossSections.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSectionedSolidHorizontal {
	constructor(Directrix: Handle<IfcCurve> , CrossSections: Handle<IfcProfileDef>[] , CrossSectionPositions: Handle<IfcDistanceExpression>[] , FixedAxisVertical: IfcBoolean )
	{
		this.Directrix = Directrix;
		this.CrossSections = CrossSections;
		this.CrossSectionPositions = CrossSectionPositions;
		this.FixedAxisVertical = FixedAxisVertical;
	}
	Directrix: Handle<IfcCurve> ;
	CrossSections: Handle<IfcProfileDef>[] ;
	CrossSectionPositions: Handle<IfcDistanceExpression>[] ;
	FixedAxisVertical: IfcBoolean ;
	static FromTape(tape: any[]): IfcSectionedSolidHorizontal
	{
		let Directrix = tape[0];
		let CrossSections = tape[1];
		let CrossSectionPositions = tape[2];
		let FixedAxisVertical = tape[3];
		return new IfcSectionedSolidHorizontal(Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Directrix.expressID)
		args.push(SET_BEGIN)
		this.CrossSections.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(SET_BEGIN)
		this.CrossSectionPositions.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSectionedSpine {
	constructor(SpineCurve: Handle<IfcCompositeCurve> , CrossSections: Handle<IfcProfileDef>[] , CrossSectionPositions: Handle<IfcAxis2Placement3D>[] )
	{
		this.SpineCurve = SpineCurve;
		this.CrossSections = CrossSections;
		this.CrossSectionPositions = CrossSectionPositions;
	}
	SpineCurve: Handle<IfcCompositeCurve> ;
	CrossSections: Handle<IfcProfileDef>[] ;
	CrossSectionPositions: Handle<IfcAxis2Placement3D>[] ;
	static FromTape(tape: any[]): IfcSectionedSpine
	{
		let SpineCurve = tape[0];
		let CrossSections = tape[1];
		let CrossSectionPositions = tape[2];
		return new IfcSectionedSpine(SpineCurve, CrossSections, CrossSectionPositions);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SpineCurve.expressID)
		args.push(SET_BEGIN)
		this.CrossSections.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(SET_BEGIN)
		this.CrossSectionPositions.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSensor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSensorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSensorTypeEnum | null;
	static FromTape(tape: any[]): IfcSensor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSensor(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSensorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSensorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSensorTypeEnum ;
	static FromTape(tape: any[]): IfcSensorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSensorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcShadingDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcShadingDeviceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcShadingDeviceTypeEnum | null;
	static FromTape(tape: any[]): IfcShadingDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcShadingDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcShadingDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcShadingDeviceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcShadingDeviceTypeEnum ;
	static FromTape(tape: any[]): IfcShadingDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcShadingDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcShapeAspect {
	constructor(ShapeRepresentations: Handle<IfcShapeModel>[] , Name: IfcLabel | null, Description: IfcText | null, ProductDefinitional: IfcLogical , PartOfProductDefinitionShape: IfcProductRepresentationSelect | null)
	{
		this.ShapeRepresentations = ShapeRepresentations;
		this.Name = Name;
		this.Description = Description;
		this.ProductDefinitional = ProductDefinitional;
		this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
	}
	ShapeRepresentations: Handle<IfcShapeModel>[] ;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ProductDefinitional: IfcLogical ;
	PartOfProductDefinitionShape: IfcProductRepresentationSelect | null;
	static FromTape(tape: any[]): IfcShapeAspect
	{
		let ShapeRepresentations = tape[0];
		let Name = tape[1];
		let Description = tape[2];
		let ProductDefinitional = tape[3];
		let PartOfProductDefinitionShape = tape[4];
		return new IfcShapeAspect(ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.ShapeRepresentations.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.PartOfProductDefinitionShape){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcShapeModel {
	constructor(ContextOfItems: Handle<IfcRepresentationContext> , RepresentationIdentifier: IfcLabel | null, RepresentationType: IfcLabel | null, Items: Handle<IfcRepresentationItem>[] )
	{
		this.ContextOfItems = ContextOfItems;
		this.RepresentationIdentifier = RepresentationIdentifier;
		this.RepresentationType = RepresentationType;
		this.Items = Items;
	}
	ContextOfItems: Handle<IfcRepresentationContext> ;
	RepresentationIdentifier: IfcLabel | null;
	RepresentationType: IfcLabel | null;
	Items: Handle<IfcRepresentationItem>[] ;
	static FromTape(tape: any[]): IfcShapeModel
	{
		let ContextOfItems = tape[0];
		let RepresentationIdentifier = tape[1];
		let RepresentationType = tape[2];
		let Items = tape[3];
		return new IfcShapeModel(ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ContextOfItems.expressID)
		if(this.RepresentationIdentifier){
		args.push(STRING)
		args.push(this.RepresentationIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationType){
		args.push(STRING)
		args.push(this.RepresentationType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Items.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcShapeRepresentation {
	constructor(ContextOfItems: Handle<IfcRepresentationContext> , RepresentationIdentifier: IfcLabel | null, RepresentationType: IfcLabel | null, Items: Handle<IfcRepresentationItem>[] )
	{
		this.ContextOfItems = ContextOfItems;
		this.RepresentationIdentifier = RepresentationIdentifier;
		this.RepresentationType = RepresentationType;
		this.Items = Items;
	}
	ContextOfItems: Handle<IfcRepresentationContext> ;
	RepresentationIdentifier: IfcLabel | null;
	RepresentationType: IfcLabel | null;
	Items: Handle<IfcRepresentationItem>[] ;
	static FromTape(tape: any[]): IfcShapeRepresentation
	{
		let ContextOfItems = tape[0];
		let RepresentationIdentifier = tape[1];
		let RepresentationType = tape[2];
		let Items = tape[3];
		return new IfcShapeRepresentation(ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ContextOfItems.expressID)
		if(this.RepresentationIdentifier){
		args.push(STRING)
		args.push(this.RepresentationIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationType){
		args.push(STRING)
		args.push(this.RepresentationType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Items.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcShellBasedSurfaceModel {
	constructor(SbsmBoundary: IfcShell[] )
	{
		this.SbsmBoundary = SbsmBoundary;
	}
	SbsmBoundary: IfcShell[] ;
	static FromTape(tape: any[]): IfcShellBasedSurfaceModel
	{
		let SbsmBoundary = tape[0];
		return new IfcShellBasedSurfaceModel(SbsmBoundary);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcSimpleProperty {
	constructor(Name: IfcIdentifier , Description: IfcText | null)
	{
		this.Name = Name;
		this.Description = Description;
	}
	Name: IfcIdentifier ;
	Description: IfcText | null;
	static FromTape(tape: any[]): IfcSimpleProperty
	{
		let Name = tape[0];
		let Description = tape[1];
		return new IfcSimpleProperty(Name, Description);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSimplePropertyTemplate {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, TemplateType: IfcSimplePropertyTemplateTypeEnum | null, PrimaryMeasureType: IfcLabel | null, SecondaryMeasureType: IfcLabel | null, Enumerators: Handle<IfcPropertyEnumeration> | null, PrimaryUnit: IfcUnit | null, SecondaryUnit: IfcUnit | null, Expression: IfcLabel | null, AccessState: IfcStateEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.TemplateType = TemplateType;
		this.PrimaryMeasureType = PrimaryMeasureType;
		this.SecondaryMeasureType = SecondaryMeasureType;
		this.Enumerators = Enumerators;
		this.PrimaryUnit = PrimaryUnit;
		this.SecondaryUnit = SecondaryUnit;
		this.Expression = Expression;
		this.AccessState = AccessState;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	TemplateType: IfcSimplePropertyTemplateTypeEnum | null;
	PrimaryMeasureType: IfcLabel | null;
	SecondaryMeasureType: IfcLabel | null;
	Enumerators: Handle<IfcPropertyEnumeration> | null;
	PrimaryUnit: IfcUnit | null;
	SecondaryUnit: IfcUnit | null;
	Expression: IfcLabel | null;
	AccessState: IfcStateEnum | null;
	static FromTape(tape: any[]): IfcSimplePropertyTemplate
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let TemplateType = tape[4];
		let PrimaryMeasureType = tape[5];
		let SecondaryMeasureType = tape[6];
		let Enumerators = tape[7];
		let PrimaryUnit = tape[8];
		let SecondaryUnit = tape[9];
		let Expression = tape[10];
		let AccessState = tape[11];
		return new IfcSimplePropertyTemplate(GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.TemplateType){
		}
		else{ args.push(EMPTY); }
		if(this.PrimaryMeasureType){
		args.push(STRING)
		args.push(this.PrimaryMeasureType)
		}
		else{ args.push(EMPTY); }
		if(this.SecondaryMeasureType){
		args.push(STRING)
		args.push(this.SecondaryMeasureType)
		}
		else{ args.push(EMPTY); }
		if(this.Enumerators){
		args.push(REF)
		args.push(this.Enumerators.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PrimaryUnit){
		}
		else{ args.push(EMPTY); }
		if(this.SecondaryUnit){
		}
		else{ args.push(EMPTY); }
		if(this.Expression){
		args.push(STRING)
		args.push(this.Expression)
		}
		else{ args.push(EMPTY); }
		if(this.AccessState){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSite {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null, RefLatitude: IfcCompoundPlaneAngleMeasure | null, RefLongitude: IfcCompoundPlaneAngleMeasure | null, RefElevation: IfcLengthMeasure | null, LandTitleNumber: IfcLabel | null, SiteAddress: Handle<IfcPostalAddress> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
		this.RefLatitude = RefLatitude;
		this.RefLongitude = RefLongitude;
		this.RefElevation = RefElevation;
		this.LandTitleNumber = LandTitleNumber;
		this.SiteAddress = SiteAddress;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	RefLatitude: IfcCompoundPlaneAngleMeasure | null;
	RefLongitude: IfcCompoundPlaneAngleMeasure | null;
	RefElevation: IfcLengthMeasure | null;
	LandTitleNumber: IfcLabel | null;
	SiteAddress: Handle<IfcPostalAddress> | null;
	static FromTape(tape: any[]): IfcSite
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		let RefLatitude = tape[9];
		let RefLongitude = tape[10];
		let RefElevation = tape[11];
		let LandTitleNumber = tape[12];
		let SiteAddress = tape[13];
		return new IfcSite(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		if(this.RefLatitude){
		args.push(REAL)
		args.push(this.RefLatitude)
		}
		else{ args.push(EMPTY); }
		if(this.RefLongitude){
		args.push(REAL)
		args.push(this.RefLongitude)
		}
		else{ args.push(EMPTY); }
		if(this.RefElevation){
		args.push(REAL)
		args.push(this.RefElevation)
		}
		else{ args.push(EMPTY); }
		if(this.LandTitleNumber){
		args.push(STRING)
		args.push(this.LandTitleNumber)
		}
		else{ args.push(EMPTY); }
		if(this.SiteAddress){
		args.push(REF)
		args.push(this.SiteAddress.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSlab {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSlabTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSlabTypeEnum | null;
	static FromTape(tape: any[]): IfcSlab
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSlab(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSlabElementedCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSlabTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSlabTypeEnum | null;
	static FromTape(tape: any[]): IfcSlabElementedCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSlabElementedCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSlabStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSlabTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSlabTypeEnum | null;
	static FromTape(tape: any[]): IfcSlabStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSlabStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSlabType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSlabTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSlabTypeEnum ;
	static FromTape(tape: any[]): IfcSlabType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSlabType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSlippageConnectionCondition {
	constructor(Name: IfcLabel | null, SlippageX: IfcLengthMeasure | null, SlippageY: IfcLengthMeasure | null, SlippageZ: IfcLengthMeasure | null)
	{
		this.Name = Name;
		this.SlippageX = SlippageX;
		this.SlippageY = SlippageY;
		this.SlippageZ = SlippageZ;
	}
	Name: IfcLabel | null;
	SlippageX: IfcLengthMeasure | null;
	SlippageY: IfcLengthMeasure | null;
	SlippageZ: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcSlippageConnectionCondition
	{
		let Name = tape[0];
		let SlippageX = tape[1];
		let SlippageY = tape[2];
		let SlippageZ = tape[3];
		return new IfcSlippageConnectionCondition(Name, SlippageX, SlippageY, SlippageZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.SlippageX){
		args.push(REAL)
		args.push(this.SlippageX)
		}
		else{ args.push(EMPTY); }
		if(this.SlippageY){
		args.push(REAL)
		args.push(this.SlippageY)
		}
		else{ args.push(EMPTY); }
		if(this.SlippageZ){
		args.push(REAL)
		args.push(this.SlippageZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSolarDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSolarDeviceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSolarDeviceTypeEnum | null;
	static FromTape(tape: any[]): IfcSolarDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSolarDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSolarDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSolarDeviceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSolarDeviceTypeEnum ;
	static FromTape(tape: any[]): IfcSolarDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSolarDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSolidModel {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcSolidModel
	{
		return new IfcSolidModel();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcSpace {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null, PredefinedType: IfcSpaceTypeEnum | null, ElevationWithFlooring: IfcLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
		this.PredefinedType = PredefinedType;
		this.ElevationWithFlooring = ElevationWithFlooring;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	PredefinedType: IfcSpaceTypeEnum | null;
	ElevationWithFlooring: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcSpace
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		let PredefinedType = tape[9];
		let ElevationWithFlooring = tape[10];
		return new IfcSpace(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.ElevationWithFlooring){
		args.push(REAL)
		args.push(this.ElevationWithFlooring)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpaceHeater {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSpaceHeaterTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSpaceHeaterTypeEnum | null;
	static FromTape(tape: any[]): IfcSpaceHeater
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSpaceHeater(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpaceHeaterType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSpaceHeaterTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSpaceHeaterTypeEnum ;
	static FromTape(tape: any[]): IfcSpaceHeaterType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSpaceHeaterType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpaceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSpaceTypeEnum , LongName: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.LongName = LongName;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSpaceTypeEnum ;
	LongName: IfcLabel | null;
	static FromTape(tape: any[]): IfcSpaceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let LongName = tape[10];
		return new IfcSpaceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpatialElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	static FromTape(tape: any[]): IfcSpatialElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		return new IfcSpatialElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpatialElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcSpatialElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcSpatialElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpatialStructureElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, CompositionType: IfcElementCompositionEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.CompositionType = CompositionType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	CompositionType: IfcElementCompositionEnum | null;
	static FromTape(tape: any[]): IfcSpatialStructureElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let CompositionType = tape[8];
		return new IfcSpatialStructureElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.CompositionType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpatialStructureElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	static FromTape(tape: any[]): IfcSpatialStructureElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		return new IfcSpatialStructureElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpatialZone {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, LongName: IfcLabel | null, PredefinedType: IfcSpatialZoneTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.LongName = LongName;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	LongName: IfcLabel | null;
	PredefinedType: IfcSpatialZoneTypeEnum | null;
	static FromTape(tape: any[]): IfcSpatialZone
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let LongName = tape[7];
		let PredefinedType = tape[8];
		return new IfcSpatialZone(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSpatialZoneType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSpatialZoneTypeEnum , LongName: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.LongName = LongName;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSpatialZoneTypeEnum ;
	LongName: IfcLabel | null;
	static FromTape(tape: any[]): IfcSpatialZoneType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let LongName = tape[10];
		return new IfcSpatialZoneType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSphere {
	constructor(Position: Handle<IfcAxis2Placement3D> , Radius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.Radius = Radius;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	Radius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcSphere
	{
		let Position = tape[0];
		let Radius = tape[1];
		return new IfcSphere(Position, Radius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcSphericalSurface {
	constructor(Position: Handle<IfcAxis2Placement3D> , Radius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.Radius = Radius;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	Radius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcSphericalSurface
	{
		let Position = tape[0];
		let Radius = tape[1];
		return new IfcSphericalSurface(Position, Radius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcStackTerminal {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcStackTerminalTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcStackTerminalTypeEnum | null;
	static FromTape(tape: any[]): IfcStackTerminal
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcStackTerminal(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStackTerminalType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcStackTerminalTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcStackTerminalTypeEnum ;
	static FromTape(tape: any[]): IfcStackTerminalType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcStackTerminalType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStair {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcStairTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcStairTypeEnum | null;
	static FromTape(tape: any[]): IfcStair
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcStair(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStairFlight {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, NumberOfRisers: IfcInteger | null, NumberOfTreads: IfcInteger | null, RiserHeight: IfcPositiveLengthMeasure | null, TreadLength: IfcPositiveLengthMeasure | null, PredefinedType: IfcStairFlightTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.NumberOfRisers = NumberOfRisers;
		this.NumberOfTreads = NumberOfTreads;
		this.RiserHeight = RiserHeight;
		this.TreadLength = TreadLength;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	NumberOfRisers: IfcInteger | null;
	NumberOfTreads: IfcInteger | null;
	RiserHeight: IfcPositiveLengthMeasure | null;
	TreadLength: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcStairFlightTypeEnum | null;
	static FromTape(tape: any[]): IfcStairFlight
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let NumberOfRisers = tape[8];
		let NumberOfTreads = tape[9];
		let RiserHeight = tape[10];
		let TreadLength = tape[11];
		let PredefinedType = tape[12];
		return new IfcStairFlight(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.NumberOfRisers){
		args.push(REAL)
		args.push(this.NumberOfRisers)
		}
		else{ args.push(EMPTY); }
		if(this.NumberOfTreads){
		args.push(REAL)
		args.push(this.NumberOfTreads)
		}
		else{ args.push(EMPTY); }
		if(this.RiserHeight){
		}
		else{ args.push(EMPTY); }
		if(this.TreadLength){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStairFlightType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcStairFlightTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcStairFlightTypeEnum ;
	static FromTape(tape: any[]): IfcStairFlightType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcStairFlightType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStairType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcStairTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcStairTypeEnum ;
	static FromTape(tape: any[]): IfcStairType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcStairType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralAction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , DestabilizingLoad: IfcBoolean | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.DestabilizingLoad = DestabilizingLoad;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	DestabilizingLoad: IfcBoolean | null;
	static FromTape(tape: any[]): IfcStructuralAction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let DestabilizingLoad = tape[9];
		return new IfcStructuralAction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		if(this.DestabilizingLoad){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralActivity {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	static FromTape(tape: any[]): IfcStructuralActivity
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		return new IfcStructuralActivity(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		return args;
	}
};
export class IfcStructuralAnalysisModel {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, PredefinedType: IfcAnalysisModelTypeEnum , OrientationOf2DPlane: Handle<IfcAxis2Placement3D> | null, LoadedBy: Handle<IfcStructuralLoadGroup>[] | null, HasResults: Handle<IfcStructuralResultGroup>[] | null, SharedPlacement: Handle<IfcObjectPlacement> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.PredefinedType = PredefinedType;
		this.OrientationOf2DPlane = OrientationOf2DPlane;
		this.LoadedBy = LoadedBy;
		this.HasResults = HasResults;
		this.SharedPlacement = SharedPlacement;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	PredefinedType: IfcAnalysisModelTypeEnum ;
	OrientationOf2DPlane: Handle<IfcAxis2Placement3D> | null;
	LoadedBy: Handle<IfcStructuralLoadGroup>[] | null;
	HasResults: Handle<IfcStructuralResultGroup>[] | null;
	SharedPlacement: Handle<IfcObjectPlacement> | null;
	static FromTape(tape: any[]): IfcStructuralAnalysisModel
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let PredefinedType = tape[5];
		let OrientationOf2DPlane = tape[6];
		let LoadedBy = tape[7];
		let HasResults = tape[8];
		let SharedPlacement = tape[9];
		return new IfcStructuralAnalysisModel(GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.OrientationOf2DPlane){
		args.push(REF)
		args.push(this.OrientationOf2DPlane.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LoadedBy){
		args.push(SET_BEGIN)
		this.LoadedBy.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.HasResults){
		args.push(SET_BEGIN)
		this.HasResults.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.SharedPlacement){
		args.push(REF)
		args.push(this.SharedPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralConnection {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedCondition: Handle<IfcBoundaryCondition> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedCondition = AppliedCondition;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedCondition: Handle<IfcBoundaryCondition> | null;
	static FromTape(tape: any[]): IfcStructuralConnection
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedCondition = tape[7];
		return new IfcStructuralConnection(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.AppliedCondition){
		args.push(REF)
		args.push(this.AppliedCondition.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralConnectionCondition {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcStructuralConnectionCondition
	{
		let Name = tape[0];
		return new IfcStructuralConnectionCondition(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralCurveAction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , DestabilizingLoad: IfcBoolean | null, ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null, PredefinedType: IfcStructuralCurveActivityTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.DestabilizingLoad = DestabilizingLoad;
		this.ProjectedOrTrue = ProjectedOrTrue;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	DestabilizingLoad: IfcBoolean | null;
	ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null;
	PredefinedType: IfcStructuralCurveActivityTypeEnum ;
	static FromTape(tape: any[]): IfcStructuralCurveAction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let DestabilizingLoad = tape[9];
		let ProjectedOrTrue = tape[10];
		let PredefinedType = tape[11];
		return new IfcStructuralCurveAction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		if(this.DestabilizingLoad){
		}
		else{ args.push(EMPTY); }
		if(this.ProjectedOrTrue){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralCurveConnection {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedCondition: Handle<IfcBoundaryCondition> | null, Axis: Handle<IfcDirection> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedCondition = AppliedCondition;
		this.Axis = Axis;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedCondition: Handle<IfcBoundaryCondition> | null;
	Axis: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcStructuralCurveConnection
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedCondition = tape[7];
		let Axis = tape[8];
		return new IfcStructuralCurveConnection(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.AppliedCondition){
		args.push(REF)
		args.push(this.AppliedCondition.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		return args;
	}
};
export class IfcStructuralCurveMember {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, PredefinedType: IfcStructuralCurveMemberTypeEnum , Axis: Handle<IfcDirection> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.PredefinedType = PredefinedType;
		this.Axis = Axis;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	PredefinedType: IfcStructuralCurveMemberTypeEnum ;
	Axis: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcStructuralCurveMember
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let PredefinedType = tape[7];
		let Axis = tape[8];
		return new IfcStructuralCurveMember(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		return args;
	}
};
export class IfcStructuralCurveMemberVarying {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, PredefinedType: IfcStructuralCurveMemberTypeEnum , Axis: Handle<IfcDirection> )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.PredefinedType = PredefinedType;
		this.Axis = Axis;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	PredefinedType: IfcStructuralCurveMemberTypeEnum ;
	Axis: Handle<IfcDirection> ;
	static FromTape(tape: any[]): IfcStructuralCurveMemberVarying
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let PredefinedType = tape[7];
		let Axis = tape[8];
		return new IfcStructuralCurveMemberVarying(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Axis.expressID)
		return args;
	}
};
export class IfcStructuralCurveReaction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , PredefinedType: IfcStructuralCurveActivityTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	PredefinedType: IfcStructuralCurveActivityTypeEnum ;
	static FromTape(tape: any[]): IfcStructuralCurveReaction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let PredefinedType = tape[9];
		return new IfcStructuralCurveReaction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		return args;
	}
};
export class IfcStructuralItem {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	static FromTape(tape: any[]): IfcStructuralItem
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		return new IfcStructuralItem(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLinearAction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , DestabilizingLoad: IfcBoolean | null, ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null, PredefinedType: IfcStructuralCurveActivityTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.DestabilizingLoad = DestabilizingLoad;
		this.ProjectedOrTrue = ProjectedOrTrue;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	DestabilizingLoad: IfcBoolean | null;
	ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null;
	PredefinedType: IfcStructuralCurveActivityTypeEnum ;
	static FromTape(tape: any[]): IfcStructuralLinearAction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let DestabilizingLoad = tape[9];
		let ProjectedOrTrue = tape[10];
		let PredefinedType = tape[11];
		return new IfcStructuralLinearAction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		if(this.DestabilizingLoad){
		}
		else{ args.push(EMPTY); }
		if(this.ProjectedOrTrue){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoad {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcStructuralLoad
	{
		let Name = tape[0];
		return new IfcStructuralLoad(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, PredefinedType: IfcLoadGroupTypeEnum , ActionType: IfcActionTypeEnum , ActionSource: IfcActionSourceTypeEnum , Coefficient: IfcRatioMeasure | null, Purpose: IfcLabel | null, SelfWeightCoefficients: IfcRatioMeasure[] | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.PredefinedType = PredefinedType;
		this.ActionType = ActionType;
		this.ActionSource = ActionSource;
		this.Coefficient = Coefficient;
		this.Purpose = Purpose;
		this.SelfWeightCoefficients = SelfWeightCoefficients;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	PredefinedType: IfcLoadGroupTypeEnum ;
	ActionType: IfcActionTypeEnum ;
	ActionSource: IfcActionSourceTypeEnum ;
	Coefficient: IfcRatioMeasure | null;
	Purpose: IfcLabel | null;
	SelfWeightCoefficients: IfcRatioMeasure[] | null;
	static FromTape(tape: any[]): IfcStructuralLoadCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let PredefinedType = tape[5];
		let ActionType = tape[6];
		let ActionSource = tape[7];
		let Coefficient = tape[8];
		let Purpose = tape[9];
		let SelfWeightCoefficients = tape[10];
		return new IfcStructuralLoadCase(GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Coefficient){
		args.push(REAL)
		args.push(this.Coefficient)
		}
		else{ args.push(EMPTY); }
		if(this.Purpose){
		args.push(STRING)
		args.push(this.Purpose)
		}
		else{ args.push(EMPTY); }
		if(this.SelfWeightCoefficients){
		args.push(REAL)
		args.push(...this.SelfWeightCoefficients)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadConfiguration {
	constructor(Name: IfcLabel | null, Values: Handle<IfcStructuralLoadOrResult>[] , Locations: IfcLengthMeasure[] | null)
	{
		this.Name = Name;
		this.Values = Values;
		this.Locations = Locations;
	}
	Name: IfcLabel | null;
	Values: Handle<IfcStructuralLoadOrResult>[] ;
	Locations: IfcLengthMeasure[] | null;
	static FromTape(tape: any[]): IfcStructuralLoadConfiguration
	{
		let Name = tape[0];
		let Values = tape[1];
		let Locations = tape[2];
		return new IfcStructuralLoadConfiguration(Name, Values, Locations);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Values.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		if(this.Locations){
		args.push(REAL)
		args.push(...this.Locations)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadGroup {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, PredefinedType: IfcLoadGroupTypeEnum , ActionType: IfcActionTypeEnum , ActionSource: IfcActionSourceTypeEnum , Coefficient: IfcRatioMeasure | null, Purpose: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.PredefinedType = PredefinedType;
		this.ActionType = ActionType;
		this.ActionSource = ActionSource;
		this.Coefficient = Coefficient;
		this.Purpose = Purpose;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	PredefinedType: IfcLoadGroupTypeEnum ;
	ActionType: IfcActionTypeEnum ;
	ActionSource: IfcActionSourceTypeEnum ;
	Coefficient: IfcRatioMeasure | null;
	Purpose: IfcLabel | null;
	static FromTape(tape: any[]): IfcStructuralLoadGroup
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let PredefinedType = tape[5];
		let ActionType = tape[6];
		let ActionSource = tape[7];
		let Coefficient = tape[8];
		let Purpose = tape[9];
		return new IfcStructuralLoadGroup(GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Coefficient){
		args.push(REAL)
		args.push(this.Coefficient)
		}
		else{ args.push(EMPTY); }
		if(this.Purpose){
		args.push(STRING)
		args.push(this.Purpose)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadLinearForce {
	constructor(Name: IfcLabel | null, LinearForceX: IfcLinearForceMeasure | null, LinearForceY: IfcLinearForceMeasure | null, LinearForceZ: IfcLinearForceMeasure | null, LinearMomentX: IfcLinearMomentMeasure | null, LinearMomentY: IfcLinearMomentMeasure | null, LinearMomentZ: IfcLinearMomentMeasure | null)
	{
		this.Name = Name;
		this.LinearForceX = LinearForceX;
		this.LinearForceY = LinearForceY;
		this.LinearForceZ = LinearForceZ;
		this.LinearMomentX = LinearMomentX;
		this.LinearMomentY = LinearMomentY;
		this.LinearMomentZ = LinearMomentZ;
	}
	Name: IfcLabel | null;
	LinearForceX: IfcLinearForceMeasure | null;
	LinearForceY: IfcLinearForceMeasure | null;
	LinearForceZ: IfcLinearForceMeasure | null;
	LinearMomentX: IfcLinearMomentMeasure | null;
	LinearMomentY: IfcLinearMomentMeasure | null;
	LinearMomentZ: IfcLinearMomentMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadLinearForce
	{
		let Name = tape[0];
		let LinearForceX = tape[1];
		let LinearForceY = tape[2];
		let LinearForceZ = tape[3];
		let LinearMomentX = tape[4];
		let LinearMomentY = tape[5];
		let LinearMomentZ = tape[6];
		return new IfcStructuralLoadLinearForce(Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.LinearForceX){
		args.push(REAL)
		args.push(this.LinearForceX)
		}
		else{ args.push(EMPTY); }
		if(this.LinearForceY){
		args.push(REAL)
		args.push(this.LinearForceY)
		}
		else{ args.push(EMPTY); }
		if(this.LinearForceZ){
		args.push(REAL)
		args.push(this.LinearForceZ)
		}
		else{ args.push(EMPTY); }
		if(this.LinearMomentX){
		args.push(REAL)
		args.push(this.LinearMomentX)
		}
		else{ args.push(EMPTY); }
		if(this.LinearMomentY){
		args.push(REAL)
		args.push(this.LinearMomentY)
		}
		else{ args.push(EMPTY); }
		if(this.LinearMomentZ){
		args.push(REAL)
		args.push(this.LinearMomentZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadOrResult {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcStructuralLoadOrResult
	{
		let Name = tape[0];
		return new IfcStructuralLoadOrResult(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadPlanarForce {
	constructor(Name: IfcLabel | null, PlanarForceX: IfcPlanarForceMeasure | null, PlanarForceY: IfcPlanarForceMeasure | null, PlanarForceZ: IfcPlanarForceMeasure | null)
	{
		this.Name = Name;
		this.PlanarForceX = PlanarForceX;
		this.PlanarForceY = PlanarForceY;
		this.PlanarForceZ = PlanarForceZ;
	}
	Name: IfcLabel | null;
	PlanarForceX: IfcPlanarForceMeasure | null;
	PlanarForceY: IfcPlanarForceMeasure | null;
	PlanarForceZ: IfcPlanarForceMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadPlanarForce
	{
		let Name = tape[0];
		let PlanarForceX = tape[1];
		let PlanarForceY = tape[2];
		let PlanarForceZ = tape[3];
		return new IfcStructuralLoadPlanarForce(Name, PlanarForceX, PlanarForceY, PlanarForceZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.PlanarForceX){
		args.push(REAL)
		args.push(this.PlanarForceX)
		}
		else{ args.push(EMPTY); }
		if(this.PlanarForceY){
		args.push(REAL)
		args.push(this.PlanarForceY)
		}
		else{ args.push(EMPTY); }
		if(this.PlanarForceZ){
		args.push(REAL)
		args.push(this.PlanarForceZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadSingleDisplacement {
	constructor(Name: IfcLabel | null, DisplacementX: IfcLengthMeasure | null, DisplacementY: IfcLengthMeasure | null, DisplacementZ: IfcLengthMeasure | null, RotationalDisplacementRX: IfcPlaneAngleMeasure | null, RotationalDisplacementRY: IfcPlaneAngleMeasure | null, RotationalDisplacementRZ: IfcPlaneAngleMeasure | null)
	{
		this.Name = Name;
		this.DisplacementX = DisplacementX;
		this.DisplacementY = DisplacementY;
		this.DisplacementZ = DisplacementZ;
		this.RotationalDisplacementRX = RotationalDisplacementRX;
		this.RotationalDisplacementRY = RotationalDisplacementRY;
		this.RotationalDisplacementRZ = RotationalDisplacementRZ;
	}
	Name: IfcLabel | null;
	DisplacementX: IfcLengthMeasure | null;
	DisplacementY: IfcLengthMeasure | null;
	DisplacementZ: IfcLengthMeasure | null;
	RotationalDisplacementRX: IfcPlaneAngleMeasure | null;
	RotationalDisplacementRY: IfcPlaneAngleMeasure | null;
	RotationalDisplacementRZ: IfcPlaneAngleMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadSingleDisplacement
	{
		let Name = tape[0];
		let DisplacementX = tape[1];
		let DisplacementY = tape[2];
		let DisplacementZ = tape[3];
		let RotationalDisplacementRX = tape[4];
		let RotationalDisplacementRY = tape[5];
		let RotationalDisplacementRZ = tape[6];
		return new IfcStructuralLoadSingleDisplacement(Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DisplacementX){
		args.push(REAL)
		args.push(this.DisplacementX)
		}
		else{ args.push(EMPTY); }
		if(this.DisplacementY){
		args.push(REAL)
		args.push(this.DisplacementY)
		}
		else{ args.push(EMPTY); }
		if(this.DisplacementZ){
		args.push(REAL)
		args.push(this.DisplacementZ)
		}
		else{ args.push(EMPTY); }
		if(this.RotationalDisplacementRX){
		args.push(REAL)
		args.push(this.RotationalDisplacementRX)
		}
		else{ args.push(EMPTY); }
		if(this.RotationalDisplacementRY){
		args.push(REAL)
		args.push(this.RotationalDisplacementRY)
		}
		else{ args.push(EMPTY); }
		if(this.RotationalDisplacementRZ){
		args.push(REAL)
		args.push(this.RotationalDisplacementRZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadSingleDisplacementDistortion {
	constructor(Name: IfcLabel | null, DisplacementX: IfcLengthMeasure | null, DisplacementY: IfcLengthMeasure | null, DisplacementZ: IfcLengthMeasure | null, RotationalDisplacementRX: IfcPlaneAngleMeasure | null, RotationalDisplacementRY: IfcPlaneAngleMeasure | null, RotationalDisplacementRZ: IfcPlaneAngleMeasure | null, Distortion: IfcCurvatureMeasure | null)
	{
		this.Name = Name;
		this.DisplacementX = DisplacementX;
		this.DisplacementY = DisplacementY;
		this.DisplacementZ = DisplacementZ;
		this.RotationalDisplacementRX = RotationalDisplacementRX;
		this.RotationalDisplacementRY = RotationalDisplacementRY;
		this.RotationalDisplacementRZ = RotationalDisplacementRZ;
		this.Distortion = Distortion;
	}
	Name: IfcLabel | null;
	DisplacementX: IfcLengthMeasure | null;
	DisplacementY: IfcLengthMeasure | null;
	DisplacementZ: IfcLengthMeasure | null;
	RotationalDisplacementRX: IfcPlaneAngleMeasure | null;
	RotationalDisplacementRY: IfcPlaneAngleMeasure | null;
	RotationalDisplacementRZ: IfcPlaneAngleMeasure | null;
	Distortion: IfcCurvatureMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadSingleDisplacementDistortion
	{
		let Name = tape[0];
		let DisplacementX = tape[1];
		let DisplacementY = tape[2];
		let DisplacementZ = tape[3];
		let RotationalDisplacementRX = tape[4];
		let RotationalDisplacementRY = tape[5];
		let RotationalDisplacementRZ = tape[6];
		let Distortion = tape[7];
		return new IfcStructuralLoadSingleDisplacementDistortion(Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DisplacementX){
		args.push(REAL)
		args.push(this.DisplacementX)
		}
		else{ args.push(EMPTY); }
		if(this.DisplacementY){
		args.push(REAL)
		args.push(this.DisplacementY)
		}
		else{ args.push(EMPTY); }
		if(this.DisplacementZ){
		args.push(REAL)
		args.push(this.DisplacementZ)
		}
		else{ args.push(EMPTY); }
		if(this.RotationalDisplacementRX){
		args.push(REAL)
		args.push(this.RotationalDisplacementRX)
		}
		else{ args.push(EMPTY); }
		if(this.RotationalDisplacementRY){
		args.push(REAL)
		args.push(this.RotationalDisplacementRY)
		}
		else{ args.push(EMPTY); }
		if(this.RotationalDisplacementRZ){
		args.push(REAL)
		args.push(this.RotationalDisplacementRZ)
		}
		else{ args.push(EMPTY); }
		if(this.Distortion){
		args.push(REAL)
		args.push(this.Distortion)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadSingleForce {
	constructor(Name: IfcLabel | null, ForceX: IfcForceMeasure | null, ForceY: IfcForceMeasure | null, ForceZ: IfcForceMeasure | null, MomentX: IfcTorqueMeasure | null, MomentY: IfcTorqueMeasure | null, MomentZ: IfcTorqueMeasure | null)
	{
		this.Name = Name;
		this.ForceX = ForceX;
		this.ForceY = ForceY;
		this.ForceZ = ForceZ;
		this.MomentX = MomentX;
		this.MomentY = MomentY;
		this.MomentZ = MomentZ;
	}
	Name: IfcLabel | null;
	ForceX: IfcForceMeasure | null;
	ForceY: IfcForceMeasure | null;
	ForceZ: IfcForceMeasure | null;
	MomentX: IfcTorqueMeasure | null;
	MomentY: IfcTorqueMeasure | null;
	MomentZ: IfcTorqueMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadSingleForce
	{
		let Name = tape[0];
		let ForceX = tape[1];
		let ForceY = tape[2];
		let ForceZ = tape[3];
		let MomentX = tape[4];
		let MomentY = tape[5];
		let MomentZ = tape[6];
		return new IfcStructuralLoadSingleForce(Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.ForceX){
		args.push(REAL)
		args.push(this.ForceX)
		}
		else{ args.push(EMPTY); }
		if(this.ForceY){
		args.push(REAL)
		args.push(this.ForceY)
		}
		else{ args.push(EMPTY); }
		if(this.ForceZ){
		args.push(REAL)
		args.push(this.ForceZ)
		}
		else{ args.push(EMPTY); }
		if(this.MomentX){
		args.push(REAL)
		args.push(this.MomentX)
		}
		else{ args.push(EMPTY); }
		if(this.MomentY){
		args.push(REAL)
		args.push(this.MomentY)
		}
		else{ args.push(EMPTY); }
		if(this.MomentZ){
		args.push(REAL)
		args.push(this.MomentZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadSingleForceWarping {
	constructor(Name: IfcLabel | null, ForceX: IfcForceMeasure | null, ForceY: IfcForceMeasure | null, ForceZ: IfcForceMeasure | null, MomentX: IfcTorqueMeasure | null, MomentY: IfcTorqueMeasure | null, MomentZ: IfcTorqueMeasure | null, WarpingMoment: IfcWarpingMomentMeasure | null)
	{
		this.Name = Name;
		this.ForceX = ForceX;
		this.ForceY = ForceY;
		this.ForceZ = ForceZ;
		this.MomentX = MomentX;
		this.MomentY = MomentY;
		this.MomentZ = MomentZ;
		this.WarpingMoment = WarpingMoment;
	}
	Name: IfcLabel | null;
	ForceX: IfcForceMeasure | null;
	ForceY: IfcForceMeasure | null;
	ForceZ: IfcForceMeasure | null;
	MomentX: IfcTorqueMeasure | null;
	MomentY: IfcTorqueMeasure | null;
	MomentZ: IfcTorqueMeasure | null;
	WarpingMoment: IfcWarpingMomentMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadSingleForceWarping
	{
		let Name = tape[0];
		let ForceX = tape[1];
		let ForceY = tape[2];
		let ForceZ = tape[3];
		let MomentX = tape[4];
		let MomentY = tape[5];
		let MomentZ = tape[6];
		let WarpingMoment = tape[7];
		return new IfcStructuralLoadSingleForceWarping(Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.ForceX){
		args.push(REAL)
		args.push(this.ForceX)
		}
		else{ args.push(EMPTY); }
		if(this.ForceY){
		args.push(REAL)
		args.push(this.ForceY)
		}
		else{ args.push(EMPTY); }
		if(this.ForceZ){
		args.push(REAL)
		args.push(this.ForceZ)
		}
		else{ args.push(EMPTY); }
		if(this.MomentX){
		args.push(REAL)
		args.push(this.MomentX)
		}
		else{ args.push(EMPTY); }
		if(this.MomentY){
		args.push(REAL)
		args.push(this.MomentY)
		}
		else{ args.push(EMPTY); }
		if(this.MomentZ){
		args.push(REAL)
		args.push(this.MomentZ)
		}
		else{ args.push(EMPTY); }
		if(this.WarpingMoment){
		args.push(REAL)
		args.push(this.WarpingMoment)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadStatic {
	constructor(Name: IfcLabel | null)
	{
		this.Name = Name;
	}
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcStructuralLoadStatic
	{
		let Name = tape[0];
		return new IfcStructuralLoadStatic(Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralLoadTemperature {
	constructor(Name: IfcLabel | null, DeltaTConstant: IfcThermodynamicTemperatureMeasure | null, DeltaTY: IfcThermodynamicTemperatureMeasure | null, DeltaTZ: IfcThermodynamicTemperatureMeasure | null)
	{
		this.Name = Name;
		this.DeltaTConstant = DeltaTConstant;
		this.DeltaTY = DeltaTY;
		this.DeltaTZ = DeltaTZ;
	}
	Name: IfcLabel | null;
	DeltaTConstant: IfcThermodynamicTemperatureMeasure | null;
	DeltaTY: IfcThermodynamicTemperatureMeasure | null;
	DeltaTZ: IfcThermodynamicTemperatureMeasure | null;
	static FromTape(tape: any[]): IfcStructuralLoadTemperature
	{
		let Name = tape[0];
		let DeltaTConstant = tape[1];
		let DeltaTY = tape[2];
		let DeltaTZ = tape[3];
		return new IfcStructuralLoadTemperature(Name, DeltaTConstant, DeltaTY, DeltaTZ);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DeltaTConstant){
		args.push(REAL)
		args.push(this.DeltaTConstant)
		}
		else{ args.push(EMPTY); }
		if(this.DeltaTY){
		args.push(REAL)
		args.push(this.DeltaTY)
		}
		else{ args.push(EMPTY); }
		if(this.DeltaTZ){
		args.push(REAL)
		args.push(this.DeltaTZ)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralMember {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	static FromTape(tape: any[]): IfcStructuralMember
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		return new IfcStructuralMember(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralPlanarAction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , DestabilizingLoad: IfcBoolean | null, ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null, PredefinedType: IfcStructuralSurfaceActivityTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.DestabilizingLoad = DestabilizingLoad;
		this.ProjectedOrTrue = ProjectedOrTrue;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	DestabilizingLoad: IfcBoolean | null;
	ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null;
	PredefinedType: IfcStructuralSurfaceActivityTypeEnum ;
	static FromTape(tape: any[]): IfcStructuralPlanarAction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let DestabilizingLoad = tape[9];
		let ProjectedOrTrue = tape[10];
		let PredefinedType = tape[11];
		return new IfcStructuralPlanarAction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		if(this.DestabilizingLoad){
		}
		else{ args.push(EMPTY); }
		if(this.ProjectedOrTrue){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralPointAction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , DestabilizingLoad: IfcBoolean | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.DestabilizingLoad = DestabilizingLoad;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	DestabilizingLoad: IfcBoolean | null;
	static FromTape(tape: any[]): IfcStructuralPointAction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let DestabilizingLoad = tape[9];
		return new IfcStructuralPointAction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		if(this.DestabilizingLoad){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralPointConnection {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedCondition: Handle<IfcBoundaryCondition> | null, ConditionCoordinateSystem: Handle<IfcAxis2Placement3D> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedCondition = AppliedCondition;
		this.ConditionCoordinateSystem = ConditionCoordinateSystem;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedCondition: Handle<IfcBoundaryCondition> | null;
	ConditionCoordinateSystem: Handle<IfcAxis2Placement3D> | null;
	static FromTape(tape: any[]): IfcStructuralPointConnection
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedCondition = tape[7];
		let ConditionCoordinateSystem = tape[8];
		return new IfcStructuralPointConnection(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.AppliedCondition){
		args.push(REF)
		args.push(this.AppliedCondition.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.ConditionCoordinateSystem){
		args.push(REF)
		args.push(this.ConditionCoordinateSystem.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralPointReaction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	static FromTape(tape: any[]): IfcStructuralPointReaction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		return new IfcStructuralPointReaction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		return args;
	}
};
export class IfcStructuralReaction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	static FromTape(tape: any[]): IfcStructuralReaction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		return new IfcStructuralReaction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		return args;
	}
};
export class IfcStructuralResultGroup {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, TheoryType: IfcAnalysisTheoryTypeEnum , ResultForLoadGroup: Handle<IfcStructuralLoadGroup> | null, IsLinear: IfcBoolean )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.TheoryType = TheoryType;
		this.ResultForLoadGroup = ResultForLoadGroup;
		this.IsLinear = IsLinear;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	TheoryType: IfcAnalysisTheoryTypeEnum ;
	ResultForLoadGroup: Handle<IfcStructuralLoadGroup> | null;
	IsLinear: IfcBoolean ;
	static FromTape(tape: any[]): IfcStructuralResultGroup
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let TheoryType = tape[5];
		let ResultForLoadGroup = tape[6];
		let IsLinear = tape[7];
		return new IfcStructuralResultGroup(GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ResultForLoadGroup){
		args.push(REF)
		args.push(this.ResultForLoadGroup.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralSurfaceAction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , DestabilizingLoad: IfcBoolean | null, ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null, PredefinedType: IfcStructuralSurfaceActivityTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.DestabilizingLoad = DestabilizingLoad;
		this.ProjectedOrTrue = ProjectedOrTrue;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	DestabilizingLoad: IfcBoolean | null;
	ProjectedOrTrue: IfcProjectedOrTrueLengthEnum | null;
	PredefinedType: IfcStructuralSurfaceActivityTypeEnum ;
	static FromTape(tape: any[]): IfcStructuralSurfaceAction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let DestabilizingLoad = tape[9];
		let ProjectedOrTrue = tape[10];
		let PredefinedType = tape[11];
		return new IfcStructuralSurfaceAction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		if(this.DestabilizingLoad){
		}
		else{ args.push(EMPTY); }
		if(this.ProjectedOrTrue){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralSurfaceConnection {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedCondition: Handle<IfcBoundaryCondition> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedCondition = AppliedCondition;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedCondition: Handle<IfcBoundaryCondition> | null;
	static FromTape(tape: any[]): IfcStructuralSurfaceConnection
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedCondition = tape[7];
		return new IfcStructuralSurfaceConnection(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.AppliedCondition){
		args.push(REF)
		args.push(this.AppliedCondition.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralSurfaceMember {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, PredefinedType: IfcStructuralSurfaceMemberTypeEnum , Thickness: IfcPositiveLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.PredefinedType = PredefinedType;
		this.Thickness = Thickness;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	PredefinedType: IfcStructuralSurfaceMemberTypeEnum ;
	Thickness: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcStructuralSurfaceMember
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let PredefinedType = tape[7];
		let Thickness = tape[8];
		return new IfcStructuralSurfaceMember(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Thickness){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralSurfaceMemberVarying {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, PredefinedType: IfcStructuralSurfaceMemberTypeEnum , Thickness: IfcPositiveLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.PredefinedType = PredefinedType;
		this.Thickness = Thickness;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	PredefinedType: IfcStructuralSurfaceMemberTypeEnum ;
	Thickness: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcStructuralSurfaceMemberVarying
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let PredefinedType = tape[7];
		let Thickness = tape[8];
		return new IfcStructuralSurfaceMemberVarying(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Thickness){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStructuralSurfaceReaction {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, AppliedLoad: Handle<IfcStructuralLoad> , GlobalOrLocal: IfcGlobalOrLocalEnum , PredefinedType: IfcStructuralSurfaceActivityTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.AppliedLoad = AppliedLoad;
		this.GlobalOrLocal = GlobalOrLocal;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	AppliedLoad: Handle<IfcStructuralLoad> ;
	GlobalOrLocal: IfcGlobalOrLocalEnum ;
	PredefinedType: IfcStructuralSurfaceActivityTypeEnum ;
	static FromTape(tape: any[]): IfcStructuralSurfaceReaction
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let AppliedLoad = tape[7];
		let GlobalOrLocal = tape[8];
		let PredefinedType = tape[9];
		return new IfcStructuralSurfaceReaction(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AppliedLoad.expressID)
		return args;
	}
};
export class IfcStyleModel {
	constructor(ContextOfItems: Handle<IfcRepresentationContext> , RepresentationIdentifier: IfcLabel | null, RepresentationType: IfcLabel | null, Items: Handle<IfcRepresentationItem>[] )
	{
		this.ContextOfItems = ContextOfItems;
		this.RepresentationIdentifier = RepresentationIdentifier;
		this.RepresentationType = RepresentationType;
		this.Items = Items;
	}
	ContextOfItems: Handle<IfcRepresentationContext> ;
	RepresentationIdentifier: IfcLabel | null;
	RepresentationType: IfcLabel | null;
	Items: Handle<IfcRepresentationItem>[] ;
	static FromTape(tape: any[]): IfcStyleModel
	{
		let ContextOfItems = tape[0];
		let RepresentationIdentifier = tape[1];
		let RepresentationType = tape[2];
		let Items = tape[3];
		return new IfcStyleModel(ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ContextOfItems.expressID)
		if(this.RepresentationIdentifier){
		args.push(STRING)
		args.push(this.RepresentationIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationType){
		args.push(STRING)
		args.push(this.RepresentationType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Items.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcStyledItem {
	constructor(Item: Handle<IfcRepresentationItem> | null, Styles: IfcStyleAssignmentSelect[] , Name: IfcLabel | null)
	{
		this.Item = Item;
		this.Styles = Styles;
		this.Name = Name;
	}
	Item: Handle<IfcRepresentationItem> | null;
	Styles: IfcStyleAssignmentSelect[] ;
	Name: IfcLabel | null;
	static FromTape(tape: any[]): IfcStyledItem
	{
		let Item = tape[0];
		let Styles = tape[1];
		let Name = tape[2];
		return new IfcStyledItem(Item, Styles, Name);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Item){
		args.push(REF)
		args.push(this.Item.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcStyledRepresentation {
	constructor(ContextOfItems: Handle<IfcRepresentationContext> , RepresentationIdentifier: IfcLabel | null, RepresentationType: IfcLabel | null, Items: Handle<IfcRepresentationItem>[] )
	{
		this.ContextOfItems = ContextOfItems;
		this.RepresentationIdentifier = RepresentationIdentifier;
		this.RepresentationType = RepresentationType;
		this.Items = Items;
	}
	ContextOfItems: Handle<IfcRepresentationContext> ;
	RepresentationIdentifier: IfcLabel | null;
	RepresentationType: IfcLabel | null;
	Items: Handle<IfcRepresentationItem>[] ;
	static FromTape(tape: any[]): IfcStyledRepresentation
	{
		let ContextOfItems = tape[0];
		let RepresentationIdentifier = tape[1];
		let RepresentationType = tape[2];
		let Items = tape[3];
		return new IfcStyledRepresentation(ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ContextOfItems.expressID)
		if(this.RepresentationIdentifier){
		args.push(STRING)
		args.push(this.RepresentationIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationType){
		args.push(STRING)
		args.push(this.RepresentationType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Items.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSubContractResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Usage: Handle<IfcResourceTime> | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcSubContractResourceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Usage = Usage;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Usage: Handle<IfcResourceTime> | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcSubContractResourceTypeEnum | null;
	static FromTape(tape: any[]): IfcSubContractResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Usage = tape[7];
		let BaseCosts = tape[8];
		let BaseQuantity = tape[9];
		let PredefinedType = tape[10];
		return new IfcSubContractResource(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Usage){
		args.push(REF)
		args.push(this.Usage.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSubContractResourceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null, BaseCosts: Handle<IfcAppliedValue>[] | null, BaseQuantity: Handle<IfcPhysicalQuantity> | null, PredefinedType: IfcSubContractResourceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
		this.BaseCosts = BaseCosts;
		this.BaseQuantity = BaseQuantity;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	BaseCosts: Handle<IfcAppliedValue>[] | null;
	BaseQuantity: Handle<IfcPhysicalQuantity> | null;
	PredefinedType: IfcSubContractResourceTypeEnum ;
	static FromTape(tape: any[]): IfcSubContractResourceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		let BaseCosts = tape[9];
		let BaseQuantity = tape[10];
		let PredefinedType = tape[11];
		return new IfcSubContractResourceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		if(this.BaseCosts){
		args.push(SET_BEGIN)
		this.BaseCosts.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.BaseQuantity){
		args.push(REF)
		args.push(this.BaseQuantity.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSubedge {
	constructor(EdgeStart: Handle<IfcVertex> , EdgeEnd: Handle<IfcVertex> , ParentEdge: Handle<IfcEdge> )
	{
		this.EdgeStart = EdgeStart;
		this.EdgeEnd = EdgeEnd;
		this.ParentEdge = ParentEdge;
	}
	EdgeStart: Handle<IfcVertex> ;
	EdgeEnd: Handle<IfcVertex> ;
	ParentEdge: Handle<IfcEdge> ;
	static FromTape(tape: any[]): IfcSubedge
	{
		let EdgeStart = tape[0];
		let EdgeEnd = tape[1];
		let ParentEdge = tape[2];
		return new IfcSubedge(EdgeStart, EdgeEnd, ParentEdge);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.EdgeStart.expressID)
		args.push(REF)
		args.push(this.EdgeEnd.expressID)
		args.push(REF)
		args.push(this.ParentEdge.expressID)
		return args;
	}
};
export class IfcSurface {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcSurface
	{
		return new IfcSurface();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcSurfaceCurve {
	constructor(Curve3D: Handle<IfcCurve> , AssociatedGeometry: Handle<IfcPcurve>[] , MasterRepresentation: IfcPreferredSurfaceCurveRepresentation )
	{
		this.Curve3D = Curve3D;
		this.AssociatedGeometry = AssociatedGeometry;
		this.MasterRepresentation = MasterRepresentation;
	}
	Curve3D: Handle<IfcCurve> ;
	AssociatedGeometry: Handle<IfcPcurve>[] ;
	MasterRepresentation: IfcPreferredSurfaceCurveRepresentation ;
	static FromTape(tape: any[]): IfcSurfaceCurve
	{
		let Curve3D = tape[0];
		let AssociatedGeometry = tape[1];
		let MasterRepresentation = tape[2];
		return new IfcSurfaceCurve(Curve3D, AssociatedGeometry, MasterRepresentation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Curve3D.expressID)
		args.push(SET_BEGIN)
		this.AssociatedGeometry.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSurfaceCurveSweptAreaSolid {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, Directrix: Handle<IfcCurve> , StartParam: IfcParameterValue | null, EndParam: IfcParameterValue | null, ReferenceSurface: Handle<IfcSurface> )
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
		this.Directrix = Directrix;
		this.StartParam = StartParam;
		this.EndParam = EndParam;
		this.ReferenceSurface = ReferenceSurface;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	Directrix: Handle<IfcCurve> ;
	StartParam: IfcParameterValue | null;
	EndParam: IfcParameterValue | null;
	ReferenceSurface: Handle<IfcSurface> ;
	static FromTape(tape: any[]): IfcSurfaceCurveSweptAreaSolid
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		let Directrix = tape[2];
		let StartParam = tape[3];
		let EndParam = tape[4];
		let ReferenceSurface = tape[5];
		return new IfcSurfaceCurveSweptAreaSolid(SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Directrix.expressID)
		if(this.StartParam){
		args.push(REAL)
		args.push(this.StartParam)
		}
		else{ args.push(EMPTY); }
		if(this.EndParam){
		args.push(REAL)
		args.push(this.EndParam)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ReferenceSurface.expressID)
		return args;
	}
};
export class IfcSurfaceFeature {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSurfaceFeatureTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSurfaceFeatureTypeEnum | null;
	static FromTape(tape: any[]): IfcSurfaceFeature
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSurfaceFeature(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSurfaceOfLinearExtrusion {
	constructor(SweptCurve: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, ExtrudedDirection: Handle<IfcDirection> , Depth: IfcLengthMeasure )
	{
		this.SweptCurve = SweptCurve;
		this.Position = Position;
		this.ExtrudedDirection = ExtrudedDirection;
		this.Depth = Depth;
	}
	SweptCurve: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	ExtrudedDirection: Handle<IfcDirection> ;
	Depth: IfcLengthMeasure ;
	static FromTape(tape: any[]): IfcSurfaceOfLinearExtrusion
	{
		let SweptCurve = tape[0];
		let Position = tape[1];
		let ExtrudedDirection = tape[2];
		let Depth = tape[3];
		return new IfcSurfaceOfLinearExtrusion(SweptCurve, Position, ExtrudedDirection, Depth);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptCurve.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.ExtrudedDirection.expressID)
		args.push(REAL)
		args.push(this.Depth)
		return args;
	}
};
export class IfcSurfaceOfRevolution {
	constructor(SweptCurve: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null, AxisPosition: Handle<IfcAxis1Placement> )
	{
		this.SweptCurve = SweptCurve;
		this.Position = Position;
		this.AxisPosition = AxisPosition;
	}
	SweptCurve: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	AxisPosition: Handle<IfcAxis1Placement> ;
	static FromTape(tape: any[]): IfcSurfaceOfRevolution
	{
		let SweptCurve = tape[0];
		let Position = tape[1];
		let AxisPosition = tape[2];
		return new IfcSurfaceOfRevolution(SweptCurve, Position, AxisPosition);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptCurve.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.AxisPosition.expressID)
		return args;
	}
};
export class IfcSurfaceReinforcementArea {
	constructor(Name: IfcLabel | null, SurfaceReinforcement1: IfcLengthMeasure[] | null, SurfaceReinforcement2: IfcLengthMeasure[] | null, ShearReinforcement: IfcRatioMeasure | null)
	{
		this.Name = Name;
		this.SurfaceReinforcement1 = SurfaceReinforcement1;
		this.SurfaceReinforcement2 = SurfaceReinforcement2;
		this.ShearReinforcement = ShearReinforcement;
	}
	Name: IfcLabel | null;
	SurfaceReinforcement1: IfcLengthMeasure[] | null;
	SurfaceReinforcement2: IfcLengthMeasure[] | null;
	ShearReinforcement: IfcRatioMeasure | null;
	static FromTape(tape: any[]): IfcSurfaceReinforcementArea
	{
		let Name = tape[0];
		let SurfaceReinforcement1 = tape[1];
		let SurfaceReinforcement2 = tape[2];
		let ShearReinforcement = tape[3];
		return new IfcSurfaceReinforcementArea(Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.SurfaceReinforcement1){
		args.push(REAL)
		args.push(...this.SurfaceReinforcement1)
		}
		else{ args.push(EMPTY); }
		if(this.SurfaceReinforcement2){
		args.push(REAL)
		args.push(...this.SurfaceReinforcement2)
		}
		else{ args.push(EMPTY); }
		if(this.ShearReinforcement){
		args.push(REAL)
		args.push(this.ShearReinforcement)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSurfaceStyle {
	constructor(Name: IfcLabel | null, Side: IfcSurfaceSide , Styles: IfcSurfaceStyleElementSelect[] )
	{
		this.Name = Name;
		this.Side = Side;
		this.Styles = Styles;
	}
	Name: IfcLabel | null;
	Side: IfcSurfaceSide ;
	Styles: IfcSurfaceStyleElementSelect[] ;
	static FromTape(tape: any[]): IfcSurfaceStyle
	{
		let Name = tape[0];
		let Side = tape[1];
		let Styles = tape[2];
		return new IfcSurfaceStyle(Name, Side, Styles);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSurfaceStyleLighting {
	constructor(DiffuseTransmissionColour: Handle<IfcColourRgb> , DiffuseReflectionColour: Handle<IfcColourRgb> , TransmissionColour: Handle<IfcColourRgb> , ReflectanceColour: Handle<IfcColourRgb> )
	{
		this.DiffuseTransmissionColour = DiffuseTransmissionColour;
		this.DiffuseReflectionColour = DiffuseReflectionColour;
		this.TransmissionColour = TransmissionColour;
		this.ReflectanceColour = ReflectanceColour;
	}
	DiffuseTransmissionColour: Handle<IfcColourRgb> ;
	DiffuseReflectionColour: Handle<IfcColourRgb> ;
	TransmissionColour: Handle<IfcColourRgb> ;
	ReflectanceColour: Handle<IfcColourRgb> ;
	static FromTape(tape: any[]): IfcSurfaceStyleLighting
	{
		let DiffuseTransmissionColour = tape[0];
		let DiffuseReflectionColour = tape[1];
		let TransmissionColour = tape[2];
		let ReflectanceColour = tape[3];
		return new IfcSurfaceStyleLighting(DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.DiffuseTransmissionColour.expressID)
		args.push(REF)
		args.push(this.DiffuseReflectionColour.expressID)
		args.push(REF)
		args.push(this.TransmissionColour.expressID)
		args.push(REF)
		args.push(this.ReflectanceColour.expressID)
		return args;
	}
};
export class IfcSurfaceStyleRefraction {
	constructor(RefractionIndex: IfcReal | null, DispersionFactor: IfcReal | null)
	{
		this.RefractionIndex = RefractionIndex;
		this.DispersionFactor = DispersionFactor;
	}
	RefractionIndex: IfcReal | null;
	DispersionFactor: IfcReal | null;
	static FromTape(tape: any[]): IfcSurfaceStyleRefraction
	{
		let RefractionIndex = tape[0];
		let DispersionFactor = tape[1];
		return new IfcSurfaceStyleRefraction(RefractionIndex, DispersionFactor);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.RefractionIndex){
		args.push(REAL)
		args.push(this.RefractionIndex)
		}
		else{ args.push(EMPTY); }
		if(this.DispersionFactor){
		args.push(REAL)
		args.push(this.DispersionFactor)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSurfaceStyleRendering {
	constructor(SurfaceColour: Handle<IfcColourRgb> , Transparency: IfcNormalisedRatioMeasure | null, DiffuseColour: IfcColourOrFactor | null, TransmissionColour: IfcColourOrFactor | null, DiffuseTransmissionColour: IfcColourOrFactor | null, ReflectionColour: IfcColourOrFactor | null, SpecularColour: IfcColourOrFactor | null, SpecularHighlight: IfcSpecularHighlightSelect | null, ReflectanceMethod: IfcReflectanceMethodEnum )
	{
		this.SurfaceColour = SurfaceColour;
		this.Transparency = Transparency;
		this.DiffuseColour = DiffuseColour;
		this.TransmissionColour = TransmissionColour;
		this.DiffuseTransmissionColour = DiffuseTransmissionColour;
		this.ReflectionColour = ReflectionColour;
		this.SpecularColour = SpecularColour;
		this.SpecularHighlight = SpecularHighlight;
		this.ReflectanceMethod = ReflectanceMethod;
	}
	SurfaceColour: Handle<IfcColourRgb> ;
	Transparency: IfcNormalisedRatioMeasure | null;
	DiffuseColour: IfcColourOrFactor | null;
	TransmissionColour: IfcColourOrFactor | null;
	DiffuseTransmissionColour: IfcColourOrFactor | null;
	ReflectionColour: IfcColourOrFactor | null;
	SpecularColour: IfcColourOrFactor | null;
	SpecularHighlight: IfcSpecularHighlightSelect | null;
	ReflectanceMethod: IfcReflectanceMethodEnum ;
	static FromTape(tape: any[]): IfcSurfaceStyleRendering
	{
		let SurfaceColour = tape[0];
		let Transparency = tape[1];
		let DiffuseColour = tape[2];
		let TransmissionColour = tape[3];
		let DiffuseTransmissionColour = tape[4];
		let ReflectionColour = tape[5];
		let SpecularColour = tape[6];
		let SpecularHighlight = tape[7];
		let ReflectanceMethod = tape[8];
		return new IfcSurfaceStyleRendering(SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SurfaceColour.expressID)
		if(this.Transparency){
		}
		else{ args.push(EMPTY); }
		if(this.DiffuseColour){
		}
		else{ args.push(EMPTY); }
		if(this.TransmissionColour){
		}
		else{ args.push(EMPTY); }
		if(this.DiffuseTransmissionColour){
		}
		else{ args.push(EMPTY); }
		if(this.ReflectionColour){
		}
		else{ args.push(EMPTY); }
		if(this.SpecularColour){
		}
		else{ args.push(EMPTY); }
		if(this.SpecularHighlight){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSurfaceStyleShading {
	constructor(SurfaceColour: Handle<IfcColourRgb> , Transparency: IfcNormalisedRatioMeasure | null)
	{
		this.SurfaceColour = SurfaceColour;
		this.Transparency = Transparency;
	}
	SurfaceColour: Handle<IfcColourRgb> ;
	Transparency: IfcNormalisedRatioMeasure | null;
	static FromTape(tape: any[]): IfcSurfaceStyleShading
	{
		let SurfaceColour = tape[0];
		let Transparency = tape[1];
		return new IfcSurfaceStyleShading(SurfaceColour, Transparency);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SurfaceColour.expressID)
		if(this.Transparency){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSurfaceStyleWithTextures {
	constructor(Textures: Handle<IfcSurfaceTexture>[] )
	{
		this.Textures = Textures;
	}
	Textures: Handle<IfcSurfaceTexture>[] ;
	static FromTape(tape: any[]): IfcSurfaceStyleWithTextures
	{
		let Textures = tape[0];
		return new IfcSurfaceStyleWithTextures(Textures);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Textures.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcSurfaceTexture {
	constructor(RepeatS: IfcBoolean , RepeatT: IfcBoolean , Mode: IfcIdentifier | null, TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null, Parameter: IfcIdentifier[] | null)
	{
		this.RepeatS = RepeatS;
		this.RepeatT = RepeatT;
		this.Mode = Mode;
		this.TextureTransform = TextureTransform;
		this.Parameter = Parameter;
	}
	RepeatS: IfcBoolean ;
	RepeatT: IfcBoolean ;
	Mode: IfcIdentifier | null;
	TextureTransform: Handle<IfcCartesianTransformationOperator2D> | null;
	Parameter: IfcIdentifier[] | null;
	static FromTape(tape: any[]): IfcSurfaceTexture
	{
		let RepeatS = tape[0];
		let RepeatT = tape[1];
		let Mode = tape[2];
		let TextureTransform = tape[3];
		let Parameter = tape[4];
		return new IfcSurfaceTexture(RepeatS, RepeatT, Mode, TextureTransform, Parameter);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Mode){
		args.push(STRING)
		args.push(this.Mode)
		}
		else{ args.push(EMPTY); }
		if(this.TextureTransform){
		args.push(REF)
		args.push(this.TextureTransform.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Parameter){
		args.push(STRING)
		args.push(...this.Parameter)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSweptAreaSolid {
	constructor(SweptArea: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null)
	{
		this.SweptArea = SweptArea;
		this.Position = Position;
	}
	SweptArea: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	static FromTape(tape: any[]): IfcSweptAreaSolid
	{
		let SweptArea = tape[0];
		let Position = tape[1];
		return new IfcSweptAreaSolid(SweptArea, Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptArea.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSweptDiskSolid {
	constructor(Directrix: Handle<IfcCurve> , Radius: IfcPositiveLengthMeasure , InnerRadius: IfcPositiveLengthMeasure | null, StartParam: IfcParameterValue | null, EndParam: IfcParameterValue | null)
	{
		this.Directrix = Directrix;
		this.Radius = Radius;
		this.InnerRadius = InnerRadius;
		this.StartParam = StartParam;
		this.EndParam = EndParam;
	}
	Directrix: Handle<IfcCurve> ;
	Radius: IfcPositiveLengthMeasure ;
	InnerRadius: IfcPositiveLengthMeasure | null;
	StartParam: IfcParameterValue | null;
	EndParam: IfcParameterValue | null;
	static FromTape(tape: any[]): IfcSweptDiskSolid
	{
		let Directrix = tape[0];
		let Radius = tape[1];
		let InnerRadius = tape[2];
		let StartParam = tape[3];
		let EndParam = tape[4];
		return new IfcSweptDiskSolid(Directrix, Radius, InnerRadius, StartParam, EndParam);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Directrix.expressID)
		if(this.InnerRadius){
		}
		else{ args.push(EMPTY); }
		if(this.StartParam){
		args.push(REAL)
		args.push(this.StartParam)
		}
		else{ args.push(EMPTY); }
		if(this.EndParam){
		args.push(REAL)
		args.push(this.EndParam)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSweptDiskSolidPolygonal {
	constructor(Directrix: Handle<IfcCurve> , Radius: IfcPositiveLengthMeasure , InnerRadius: IfcPositiveLengthMeasure | null, StartParam: IfcParameterValue | null, EndParam: IfcParameterValue | null, FilletRadius: IfcPositiveLengthMeasure | null)
	{
		this.Directrix = Directrix;
		this.Radius = Radius;
		this.InnerRadius = InnerRadius;
		this.StartParam = StartParam;
		this.EndParam = EndParam;
		this.FilletRadius = FilletRadius;
	}
	Directrix: Handle<IfcCurve> ;
	Radius: IfcPositiveLengthMeasure ;
	InnerRadius: IfcPositiveLengthMeasure | null;
	StartParam: IfcParameterValue | null;
	EndParam: IfcParameterValue | null;
	FilletRadius: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcSweptDiskSolidPolygonal
	{
		let Directrix = tape[0];
		let Radius = tape[1];
		let InnerRadius = tape[2];
		let StartParam = tape[3];
		let EndParam = tape[4];
		let FilletRadius = tape[5];
		return new IfcSweptDiskSolidPolygonal(Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Directrix.expressID)
		if(this.InnerRadius){
		}
		else{ args.push(EMPTY); }
		if(this.StartParam){
		args.push(REAL)
		args.push(this.StartParam)
		}
		else{ args.push(EMPTY); }
		if(this.EndParam){
		args.push(REAL)
		args.push(this.EndParam)
		}
		else{ args.push(EMPTY); }
		if(this.FilletRadius){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSweptSurface {
	constructor(SweptCurve: Handle<IfcProfileDef> , Position: Handle<IfcAxis2Placement3D> | null)
	{
		this.SweptCurve = SweptCurve;
		this.Position = Position;
	}
	SweptCurve: Handle<IfcProfileDef> ;
	Position: Handle<IfcAxis2Placement3D> | null;
	static FromTape(tape: any[]): IfcSweptSurface
	{
		let SweptCurve = tape[0];
		let Position = tape[1];
		return new IfcSweptSurface(SweptCurve, Position);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.SweptCurve.expressID)
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSwitchingDevice {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSwitchingDeviceTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSwitchingDeviceTypeEnum | null;
	static FromTape(tape: any[]): IfcSwitchingDevice
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSwitchingDevice(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSwitchingDeviceType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSwitchingDeviceTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSwitchingDeviceTypeEnum ;
	static FromTape(tape: any[]): IfcSwitchingDeviceType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSwitchingDeviceType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSystem {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	static FromTape(tape: any[]): IfcSystem
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		return new IfcSystem(GlobalId, OwnerHistory, Name, Description, ObjectType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSystemFurnitureElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcSystemFurnitureElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcSystemFurnitureElementTypeEnum | null;
	static FromTape(tape: any[]): IfcSystemFurnitureElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcSystemFurnitureElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcSystemFurnitureElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcSystemFurnitureElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcSystemFurnitureElementTypeEnum | null;
	static FromTape(tape: any[]): IfcSystemFurnitureElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcSystemFurnitureElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Depth: IfcPositiveLengthMeasure , FlangeWidth: IfcPositiveLengthMeasure , WebThickness: IfcPositiveLengthMeasure , FlangeThickness: IfcPositiveLengthMeasure , FilletRadius: IfcNonNegativeLengthMeasure | null, FlangeEdgeRadius: IfcNonNegativeLengthMeasure | null, WebEdgeRadius: IfcNonNegativeLengthMeasure | null, WebSlope: IfcPlaneAngleMeasure | null, FlangeSlope: IfcPlaneAngleMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Depth = Depth;
		this.FlangeWidth = FlangeWidth;
		this.WebThickness = WebThickness;
		this.FlangeThickness = FlangeThickness;
		this.FilletRadius = FilletRadius;
		this.FlangeEdgeRadius = FlangeEdgeRadius;
		this.WebEdgeRadius = WebEdgeRadius;
		this.WebSlope = WebSlope;
		this.FlangeSlope = FlangeSlope;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Depth: IfcPositiveLengthMeasure ;
	FlangeWidth: IfcPositiveLengthMeasure ;
	WebThickness: IfcPositiveLengthMeasure ;
	FlangeThickness: IfcPositiveLengthMeasure ;
	FilletRadius: IfcNonNegativeLengthMeasure | null;
	FlangeEdgeRadius: IfcNonNegativeLengthMeasure | null;
	WebEdgeRadius: IfcNonNegativeLengthMeasure | null;
	WebSlope: IfcPlaneAngleMeasure | null;
	FlangeSlope: IfcPlaneAngleMeasure | null;
	static FromTape(tape: any[]): IfcTShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Depth = tape[3];
		let FlangeWidth = tape[4];
		let WebThickness = tape[5];
		let FlangeThickness = tape[6];
		let FilletRadius = tape[7];
		let FlangeEdgeRadius = tape[8];
		let WebEdgeRadius = tape[9];
		let WebSlope = tape[10];
		let FlangeSlope = tape[11];
		return new IfcTShapeProfileDef(ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.FilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.FlangeEdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.WebEdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.WebSlope){
		args.push(REAL)
		args.push(this.WebSlope)
		}
		else{ args.push(EMPTY); }
		if(this.FlangeSlope){
		args.push(REAL)
		args.push(this.FlangeSlope)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTable {
	constructor(Name: IfcLabel | null, Rows: Handle<IfcTableRow>[] | null, Columns: Handle<IfcTableColumn>[] | null)
	{
		this.Name = Name;
		this.Rows = Rows;
		this.Columns = Columns;
	}
	Name: IfcLabel | null;
	Rows: Handle<IfcTableRow>[] | null;
	Columns: Handle<IfcTableColumn>[] | null;
	static FromTape(tape: any[]): IfcTable
	{
		let Name = tape[0];
		let Rows = tape[1];
		let Columns = tape[2];
		return new IfcTable(Name, Rows, Columns);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Rows){
		args.push(SET_BEGIN)
		this.Rows.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Columns){
		args.push(SET_BEGIN)
		this.Columns.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTableColumn {
	constructor(Identifier: IfcIdentifier | null, Name: IfcLabel | null, Description: IfcText | null, Unit: IfcUnit | null, ReferencePath: Handle<IfcReference> | null)
	{
		this.Identifier = Identifier;
		this.Name = Name;
		this.Description = Description;
		this.Unit = Unit;
		this.ReferencePath = ReferencePath;
	}
	Identifier: IfcIdentifier | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	Unit: IfcUnit | null;
	ReferencePath: Handle<IfcReference> | null;
	static FromTape(tape: any[]): IfcTableColumn
	{
		let Identifier = tape[0];
		let Name = tape[1];
		let Description = tape[2];
		let Unit = tape[3];
		let ReferencePath = tape[4];
		return new IfcTableColumn(Identifier, Name, Description, Unit, ReferencePath);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Identifier){
		args.push(STRING)
		args.push(this.Identifier)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		if(this.ReferencePath){
		args.push(REF)
		args.push(this.ReferencePath.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTableRow {
	constructor(RowCells: IfcValue[] | null, IsHeading: IfcBoolean | null)
	{
		this.RowCells = RowCells;
		this.IsHeading = IsHeading;
	}
	RowCells: IfcValue[] | null;
	IsHeading: IfcBoolean | null;
	static FromTape(tape: any[]): IfcTableRow
	{
		let RowCells = tape[0] ? { t: tape[0], v: tape[1][0]} as any : null;
		let IsHeading = tape[2];
		return new IfcTableRow(RowCells, IsHeading);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.RowCells){
		}
		else{ args.push(EMPTY); }
		if(this.IsHeading){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTank {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcTankTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcTankTypeEnum | null;
	static FromTape(tape: any[]): IfcTank
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcTank(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTankType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTankTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTankTypeEnum ;
	static FromTape(tape: any[]): IfcTankType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcTankType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTask {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, Status: IfcLabel | null, WorkMethod: IfcLabel | null, IsMilestone: IfcBoolean , Priority: IfcInteger | null, TaskTime: Handle<IfcTaskTime> | null, PredefinedType: IfcTaskTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.Status = Status;
		this.WorkMethod = WorkMethod;
		this.IsMilestone = IsMilestone;
		this.Priority = Priority;
		this.TaskTime = TaskTime;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	Status: IfcLabel | null;
	WorkMethod: IfcLabel | null;
	IsMilestone: IfcBoolean ;
	Priority: IfcInteger | null;
	TaskTime: Handle<IfcTaskTime> | null;
	PredefinedType: IfcTaskTypeEnum | null;
	static FromTape(tape: any[]): IfcTask
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let LongDescription = tape[6];
		let Status = tape[7];
		let WorkMethod = tape[8];
		let IsMilestone = tape[9];
		let Priority = tape[10];
		let TaskTime = tape[11];
		let PredefinedType = tape[12];
		return new IfcTask(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.Status){
		args.push(STRING)
		args.push(this.Status)
		}
		else{ args.push(EMPTY); }
		if(this.WorkMethod){
		args.push(STRING)
		args.push(this.WorkMethod)
		}
		else{ args.push(EMPTY); }
		if(this.Priority){
		args.push(REAL)
		args.push(this.Priority)
		}
		else{ args.push(EMPTY); }
		if(this.TaskTime){
		args.push(REF)
		args.push(this.TaskTime.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTaskTime {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null, DurationType: IfcTaskDurationEnum | null, ScheduleDuration: IfcDuration | null, ScheduleStart: IfcDateTime | null, ScheduleFinish: IfcDateTime | null, EarlyStart: IfcDateTime | null, EarlyFinish: IfcDateTime | null, LateStart: IfcDateTime | null, LateFinish: IfcDateTime | null, FreeFloat: IfcDuration | null, TotalFloat: IfcDuration | null, IsCritical: IfcBoolean | null, StatusTime: IfcDateTime | null, ActualDuration: IfcDuration | null, ActualStart: IfcDateTime | null, ActualFinish: IfcDateTime | null, RemainingTime: IfcDuration | null, Completion: IfcPositiveRatioMeasure | null)
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.DurationType = DurationType;
		this.ScheduleDuration = ScheduleDuration;
		this.ScheduleStart = ScheduleStart;
		this.ScheduleFinish = ScheduleFinish;
		this.EarlyStart = EarlyStart;
		this.EarlyFinish = EarlyFinish;
		this.LateStart = LateStart;
		this.LateFinish = LateFinish;
		this.FreeFloat = FreeFloat;
		this.TotalFloat = TotalFloat;
		this.IsCritical = IsCritical;
		this.StatusTime = StatusTime;
		this.ActualDuration = ActualDuration;
		this.ActualStart = ActualStart;
		this.ActualFinish = ActualFinish;
		this.RemainingTime = RemainingTime;
		this.Completion = Completion;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	DurationType: IfcTaskDurationEnum | null;
	ScheduleDuration: IfcDuration | null;
	ScheduleStart: IfcDateTime | null;
	ScheduleFinish: IfcDateTime | null;
	EarlyStart: IfcDateTime | null;
	EarlyFinish: IfcDateTime | null;
	LateStart: IfcDateTime | null;
	LateFinish: IfcDateTime | null;
	FreeFloat: IfcDuration | null;
	TotalFloat: IfcDuration | null;
	IsCritical: IfcBoolean | null;
	StatusTime: IfcDateTime | null;
	ActualDuration: IfcDuration | null;
	ActualStart: IfcDateTime | null;
	ActualFinish: IfcDateTime | null;
	RemainingTime: IfcDuration | null;
	Completion: IfcPositiveRatioMeasure | null;
	static FromTape(tape: any[]): IfcTaskTime
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		let DurationType = tape[3];
		let ScheduleDuration = tape[4];
		let ScheduleStart = tape[5];
		let ScheduleFinish = tape[6];
		let EarlyStart = tape[7];
		let EarlyFinish = tape[8];
		let LateStart = tape[9];
		let LateFinish = tape[10];
		let FreeFloat = tape[11];
		let TotalFloat = tape[12];
		let IsCritical = tape[13];
		let StatusTime = tape[14];
		let ActualDuration = tape[15];
		let ActualStart = tape[16];
		let ActualFinish = tape[17];
		let RemainingTime = tape[18];
		let Completion = tape[19];
		return new IfcTaskTime(Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.DurationType){
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleDuration){
		args.push(STRING)
		args.push(this.ScheduleDuration)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleStart){
		args.push(STRING)
		args.push(this.ScheduleStart)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleFinish){
		args.push(STRING)
		args.push(this.ScheduleFinish)
		}
		else{ args.push(EMPTY); }
		if(this.EarlyStart){
		args.push(STRING)
		args.push(this.EarlyStart)
		}
		else{ args.push(EMPTY); }
		if(this.EarlyFinish){
		args.push(STRING)
		args.push(this.EarlyFinish)
		}
		else{ args.push(EMPTY); }
		if(this.LateStart){
		args.push(STRING)
		args.push(this.LateStart)
		}
		else{ args.push(EMPTY); }
		if(this.LateFinish){
		args.push(STRING)
		args.push(this.LateFinish)
		}
		else{ args.push(EMPTY); }
		if(this.FreeFloat){
		args.push(STRING)
		args.push(this.FreeFloat)
		}
		else{ args.push(EMPTY); }
		if(this.TotalFloat){
		args.push(STRING)
		args.push(this.TotalFloat)
		}
		else{ args.push(EMPTY); }
		if(this.IsCritical){
		}
		else{ args.push(EMPTY); }
		if(this.StatusTime){
		args.push(STRING)
		args.push(this.StatusTime)
		}
		else{ args.push(EMPTY); }
		if(this.ActualDuration){
		args.push(STRING)
		args.push(this.ActualDuration)
		}
		else{ args.push(EMPTY); }
		if(this.ActualStart){
		args.push(STRING)
		args.push(this.ActualStart)
		}
		else{ args.push(EMPTY); }
		if(this.ActualFinish){
		args.push(STRING)
		args.push(this.ActualFinish)
		}
		else{ args.push(EMPTY); }
		if(this.RemainingTime){
		args.push(STRING)
		args.push(this.RemainingTime)
		}
		else{ args.push(EMPTY); }
		if(this.Completion){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTaskTimeRecurring {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null, DurationType: IfcTaskDurationEnum | null, ScheduleDuration: IfcDuration | null, ScheduleStart: IfcDateTime | null, ScheduleFinish: IfcDateTime | null, EarlyStart: IfcDateTime | null, EarlyFinish: IfcDateTime | null, LateStart: IfcDateTime | null, LateFinish: IfcDateTime | null, FreeFloat: IfcDuration | null, TotalFloat: IfcDuration | null, IsCritical: IfcBoolean | null, StatusTime: IfcDateTime | null, ActualDuration: IfcDuration | null, ActualStart: IfcDateTime | null, ActualFinish: IfcDateTime | null, RemainingTime: IfcDuration | null, Completion: IfcPositiveRatioMeasure | null, Recurrence: Handle<IfcRecurrencePattern> )
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.DurationType = DurationType;
		this.ScheduleDuration = ScheduleDuration;
		this.ScheduleStart = ScheduleStart;
		this.ScheduleFinish = ScheduleFinish;
		this.EarlyStart = EarlyStart;
		this.EarlyFinish = EarlyFinish;
		this.LateStart = LateStart;
		this.LateFinish = LateFinish;
		this.FreeFloat = FreeFloat;
		this.TotalFloat = TotalFloat;
		this.IsCritical = IsCritical;
		this.StatusTime = StatusTime;
		this.ActualDuration = ActualDuration;
		this.ActualStart = ActualStart;
		this.ActualFinish = ActualFinish;
		this.RemainingTime = RemainingTime;
		this.Completion = Completion;
		this.Recurrence = Recurrence;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	DurationType: IfcTaskDurationEnum | null;
	ScheduleDuration: IfcDuration | null;
	ScheduleStart: IfcDateTime | null;
	ScheduleFinish: IfcDateTime | null;
	EarlyStart: IfcDateTime | null;
	EarlyFinish: IfcDateTime | null;
	LateStart: IfcDateTime | null;
	LateFinish: IfcDateTime | null;
	FreeFloat: IfcDuration | null;
	TotalFloat: IfcDuration | null;
	IsCritical: IfcBoolean | null;
	StatusTime: IfcDateTime | null;
	ActualDuration: IfcDuration | null;
	ActualStart: IfcDateTime | null;
	ActualFinish: IfcDateTime | null;
	RemainingTime: IfcDuration | null;
	Completion: IfcPositiveRatioMeasure | null;
	Recurrence: Handle<IfcRecurrencePattern> ;
	static FromTape(tape: any[]): IfcTaskTimeRecurring
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		let DurationType = tape[3];
		let ScheduleDuration = tape[4];
		let ScheduleStart = tape[5];
		let ScheduleFinish = tape[6];
		let EarlyStart = tape[7];
		let EarlyFinish = tape[8];
		let LateStart = tape[9];
		let LateFinish = tape[10];
		let FreeFloat = tape[11];
		let TotalFloat = tape[12];
		let IsCritical = tape[13];
		let StatusTime = tape[14];
		let ActualDuration = tape[15];
		let ActualStart = tape[16];
		let ActualFinish = tape[17];
		let RemainingTime = tape[18];
		let Completion = tape[19];
		let Recurrence = tape[20];
		return new IfcTaskTimeRecurring(Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.DurationType){
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleDuration){
		args.push(STRING)
		args.push(this.ScheduleDuration)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleStart){
		args.push(STRING)
		args.push(this.ScheduleStart)
		}
		else{ args.push(EMPTY); }
		if(this.ScheduleFinish){
		args.push(STRING)
		args.push(this.ScheduleFinish)
		}
		else{ args.push(EMPTY); }
		if(this.EarlyStart){
		args.push(STRING)
		args.push(this.EarlyStart)
		}
		else{ args.push(EMPTY); }
		if(this.EarlyFinish){
		args.push(STRING)
		args.push(this.EarlyFinish)
		}
		else{ args.push(EMPTY); }
		if(this.LateStart){
		args.push(STRING)
		args.push(this.LateStart)
		}
		else{ args.push(EMPTY); }
		if(this.LateFinish){
		args.push(STRING)
		args.push(this.LateFinish)
		}
		else{ args.push(EMPTY); }
		if(this.FreeFloat){
		args.push(STRING)
		args.push(this.FreeFloat)
		}
		else{ args.push(EMPTY); }
		if(this.TotalFloat){
		args.push(STRING)
		args.push(this.TotalFloat)
		}
		else{ args.push(EMPTY); }
		if(this.IsCritical){
		}
		else{ args.push(EMPTY); }
		if(this.StatusTime){
		args.push(STRING)
		args.push(this.StatusTime)
		}
		else{ args.push(EMPTY); }
		if(this.ActualDuration){
		args.push(STRING)
		args.push(this.ActualDuration)
		}
		else{ args.push(EMPTY); }
		if(this.ActualStart){
		args.push(STRING)
		args.push(this.ActualStart)
		}
		else{ args.push(EMPTY); }
		if(this.ActualFinish){
		args.push(STRING)
		args.push(this.ActualFinish)
		}
		else{ args.push(EMPTY); }
		if(this.RemainingTime){
		args.push(STRING)
		args.push(this.RemainingTime)
		}
		else{ args.push(EMPTY); }
		if(this.Completion){
		}
		else{ args.push(EMPTY); }
		args.push(REF)
		args.push(this.Recurrence.expressID)
		return args;
	}
};
export class IfcTaskType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ProcessType: IfcLabel | null, PredefinedType: IfcTaskTypeEnum , WorkMethod: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ProcessType = ProcessType;
		this.PredefinedType = PredefinedType;
		this.WorkMethod = WorkMethod;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ProcessType: IfcLabel | null;
	PredefinedType: IfcTaskTypeEnum ;
	WorkMethod: IfcLabel | null;
	static FromTape(tape: any[]): IfcTaskType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ProcessType = tape[8];
		let PredefinedType = tape[9];
		let WorkMethod = tape[10];
		return new IfcTaskType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ProcessType){
		args.push(STRING)
		args.push(this.ProcessType)
		}
		else{ args.push(EMPTY); }
		if(this.WorkMethod){
		args.push(STRING)
		args.push(this.WorkMethod)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTelecomAddress {
	constructor(Purpose: IfcAddressTypeEnum | null, Description: IfcText | null, UserDefinedPurpose: IfcLabel | null, TelephoneNumbers: IfcLabel[] | null, FacsimileNumbers: IfcLabel[] | null, PagerNumber: IfcLabel | null, ElectronicMailAddresses: IfcLabel[] | null, WWWHomePageURL: IfcURIReference | null, MessagingIDs: IfcURIReference[] | null)
	{
		this.Purpose = Purpose;
		this.Description = Description;
		this.UserDefinedPurpose = UserDefinedPurpose;
		this.TelephoneNumbers = TelephoneNumbers;
		this.FacsimileNumbers = FacsimileNumbers;
		this.PagerNumber = PagerNumber;
		this.ElectronicMailAddresses = ElectronicMailAddresses;
		this.WWWHomePageURL = WWWHomePageURL;
		this.MessagingIDs = MessagingIDs;
	}
	Purpose: IfcAddressTypeEnum | null;
	Description: IfcText | null;
	UserDefinedPurpose: IfcLabel | null;
	TelephoneNumbers: IfcLabel[] | null;
	FacsimileNumbers: IfcLabel[] | null;
	PagerNumber: IfcLabel | null;
	ElectronicMailAddresses: IfcLabel[] | null;
	WWWHomePageURL: IfcURIReference | null;
	MessagingIDs: IfcURIReference[] | null;
	static FromTape(tape: any[]): IfcTelecomAddress
	{
		let Purpose = tape[0];
		let Description = tape[1];
		let UserDefinedPurpose = tape[2];
		let TelephoneNumbers = tape[3];
		let FacsimileNumbers = tape[4];
		let PagerNumber = tape[5];
		let ElectronicMailAddresses = tape[6];
		let WWWHomePageURL = tape[7];
		let MessagingIDs = tape[8];
		return new IfcTelecomAddress(Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Purpose){
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedPurpose){
		args.push(STRING)
		args.push(this.UserDefinedPurpose)
		}
		else{ args.push(EMPTY); }
		if(this.TelephoneNumbers){
		args.push(STRING)
		args.push(...this.TelephoneNumbers)
		}
		else{ args.push(EMPTY); }
		if(this.FacsimileNumbers){
		args.push(STRING)
		args.push(...this.FacsimileNumbers)
		}
		else{ args.push(EMPTY); }
		if(this.PagerNumber){
		args.push(STRING)
		args.push(this.PagerNumber)
		}
		else{ args.push(EMPTY); }
		if(this.ElectronicMailAddresses){
		args.push(STRING)
		args.push(...this.ElectronicMailAddresses)
		}
		else{ args.push(EMPTY); }
		if(this.WWWHomePageURL){
		args.push(STRING)
		args.push(this.WWWHomePageURL)
		}
		else{ args.push(EMPTY); }
		if(this.MessagingIDs){
		args.push(STRING)
		args.push(...this.MessagingIDs)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTendon {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, SteelGrade: IfcLabel | null, PredefinedType: IfcTendonTypeEnum | null, NominalDiameter: IfcPositiveLengthMeasure | null, CrossSectionArea: IfcAreaMeasure | null, TensionForce: IfcForceMeasure | null, PreStress: IfcPressureMeasure | null, FrictionCoefficient: IfcNormalisedRatioMeasure | null, AnchorageSlip: IfcPositiveLengthMeasure | null, MinCurvatureRadius: IfcPositiveLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.SteelGrade = SteelGrade;
		this.PredefinedType = PredefinedType;
		this.NominalDiameter = NominalDiameter;
		this.CrossSectionArea = CrossSectionArea;
		this.TensionForce = TensionForce;
		this.PreStress = PreStress;
		this.FrictionCoefficient = FrictionCoefficient;
		this.AnchorageSlip = AnchorageSlip;
		this.MinCurvatureRadius = MinCurvatureRadius;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	SteelGrade: IfcLabel | null;
	PredefinedType: IfcTendonTypeEnum | null;
	NominalDiameter: IfcPositiveLengthMeasure | null;
	CrossSectionArea: IfcAreaMeasure | null;
	TensionForce: IfcForceMeasure | null;
	PreStress: IfcPressureMeasure | null;
	FrictionCoefficient: IfcNormalisedRatioMeasure | null;
	AnchorageSlip: IfcPositiveLengthMeasure | null;
	MinCurvatureRadius: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcTendon
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let SteelGrade = tape[8];
		let PredefinedType = tape[9];
		let NominalDiameter = tape[10];
		let CrossSectionArea = tape[11];
		let TensionForce = tape[12];
		let PreStress = tape[13];
		let FrictionCoefficient = tape[14];
		let AnchorageSlip = tape[15];
		let MinCurvatureRadius = tape[16];
		return new IfcTendon(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.SteelGrade){
		args.push(STRING)
		args.push(this.SteelGrade)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.NominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.CrossSectionArea){
		args.push(REAL)
		args.push(this.CrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.TensionForce){
		args.push(REAL)
		args.push(this.TensionForce)
		}
		else{ args.push(EMPTY); }
		if(this.PreStress){
		args.push(REAL)
		args.push(this.PreStress)
		}
		else{ args.push(EMPTY); }
		if(this.FrictionCoefficient){
		}
		else{ args.push(EMPTY); }
		if(this.AnchorageSlip){
		}
		else{ args.push(EMPTY); }
		if(this.MinCurvatureRadius){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTendonAnchor {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, SteelGrade: IfcLabel | null, PredefinedType: IfcTendonAnchorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.SteelGrade = SteelGrade;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	SteelGrade: IfcLabel | null;
	PredefinedType: IfcTendonAnchorTypeEnum | null;
	static FromTape(tape: any[]): IfcTendonAnchor
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let SteelGrade = tape[8];
		let PredefinedType = tape[9];
		return new IfcTendonAnchor(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.SteelGrade){
		args.push(STRING)
		args.push(this.SteelGrade)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTendonAnchorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTendonAnchorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTendonAnchorTypeEnum ;
	static FromTape(tape: any[]): IfcTendonAnchorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcTendonAnchorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTendonConduit {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, SteelGrade: IfcLabel | null, PredefinedType: IfcTendonConduitTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.SteelGrade = SteelGrade;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	SteelGrade: IfcLabel | null;
	PredefinedType: IfcTendonConduitTypeEnum ;
	static FromTape(tape: any[]): IfcTendonConduit
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let SteelGrade = tape[8];
		let PredefinedType = tape[9];
		return new IfcTendonConduit(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.SteelGrade){
		args.push(STRING)
		args.push(this.SteelGrade)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTendonConduitType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTendonConduitTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTendonConduitTypeEnum ;
	static FromTape(tape: any[]): IfcTendonConduitType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcTendonConduitType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTendonType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTendonTypeEnum , NominalDiameter: IfcPositiveLengthMeasure | null, CrossSectionArea: IfcAreaMeasure | null, SheathDiameter: IfcPositiveLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.NominalDiameter = NominalDiameter;
		this.CrossSectionArea = CrossSectionArea;
		this.SheathDiameter = SheathDiameter;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTendonTypeEnum ;
	NominalDiameter: IfcPositiveLengthMeasure | null;
	CrossSectionArea: IfcAreaMeasure | null;
	SheathDiameter: IfcPositiveLengthMeasure | null;
	static FromTape(tape: any[]): IfcTendonType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let NominalDiameter = tape[10];
		let CrossSectionArea = tape[11];
		let SheathDiameter = tape[12];
		return new IfcTendonType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.NominalDiameter){
		}
		else{ args.push(EMPTY); }
		if(this.CrossSectionArea){
		args.push(REAL)
		args.push(this.CrossSectionArea)
		}
		else{ args.push(EMPTY); }
		if(this.SheathDiameter){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTessellatedFaceSet {
	constructor(Coordinates: Handle<IfcCartesianPointList3D> )
	{
		this.Coordinates = Coordinates;
	}
	Coordinates: Handle<IfcCartesianPointList3D> ;
	static FromTape(tape: any[]): IfcTessellatedFaceSet
	{
		let Coordinates = tape[0];
		return new IfcTessellatedFaceSet(Coordinates);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Coordinates.expressID)
		return args;
	}
};
export class IfcTessellatedItem {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcTessellatedItem
	{
		return new IfcTessellatedItem();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcTextLiteral {
	constructor(Literal: IfcPresentableText , Placement: IfcAxis2Placement , Path: IfcTextPath )
	{
		this.Literal = Literal;
		this.Placement = Placement;
		this.Path = Path;
	}
	Literal: IfcPresentableText ;
	Placement: IfcAxis2Placement ;
	Path: IfcTextPath ;
	static FromTape(tape: any[]): IfcTextLiteral
	{
		let Literal = tape[0];
		let Placement = tape[1];
		let Path = tape[2];
		return new IfcTextLiteral(Literal, Placement, Path);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Literal)
		return args;
	}
};
export class IfcTextLiteralWithExtent {
	constructor(Literal: IfcPresentableText , Placement: IfcAxis2Placement , Path: IfcTextPath , Extent: Handle<IfcPlanarExtent> , BoxAlignment: IfcBoxAlignment )
	{
		this.Literal = Literal;
		this.Placement = Placement;
		this.Path = Path;
		this.Extent = Extent;
		this.BoxAlignment = BoxAlignment;
	}
	Literal: IfcPresentableText ;
	Placement: IfcAxis2Placement ;
	Path: IfcTextPath ;
	Extent: Handle<IfcPlanarExtent> ;
	BoxAlignment: IfcBoxAlignment ;
	static FromTape(tape: any[]): IfcTextLiteralWithExtent
	{
		let Literal = tape[0];
		let Placement = tape[1];
		let Path = tape[2];
		let Extent = tape[3];
		let BoxAlignment = tape[4];
		return new IfcTextLiteralWithExtent(Literal, Placement, Path, Extent, BoxAlignment);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Literal)
		args.push(REF)
		args.push(this.Extent.expressID)
		return args;
	}
};
export class IfcTextStyle {
	constructor(Name: IfcLabel | null, TextCharacterAppearance: Handle<IfcTextStyleForDefinedFont> | null, TextStyle: Handle<IfcTextStyleTextModel> | null, TextFontStyle: IfcTextFontSelect , ModelOrDraughting: IfcBoolean | null)
	{
		this.Name = Name;
		this.TextCharacterAppearance = TextCharacterAppearance;
		this.TextStyle = TextStyle;
		this.TextFontStyle = TextFontStyle;
		this.ModelOrDraughting = ModelOrDraughting;
	}
	Name: IfcLabel | null;
	TextCharacterAppearance: Handle<IfcTextStyleForDefinedFont> | null;
	TextStyle: Handle<IfcTextStyleTextModel> | null;
	TextFontStyle: IfcTextFontSelect ;
	ModelOrDraughting: IfcBoolean | null;
	static FromTape(tape: any[]): IfcTextStyle
	{
		let Name = tape[0];
		let TextCharacterAppearance = tape[1];
		let TextStyle = tape[2];
		let TextFontStyle = tape[3];
		let ModelOrDraughting = tape[4];
		return new IfcTextStyle(Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.TextCharacterAppearance){
		args.push(REF)
		args.push(this.TextCharacterAppearance.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.TextStyle){
		args.push(REF)
		args.push(this.TextStyle.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.ModelOrDraughting){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTextStyleFontModel {
	constructor(Name: IfcLabel , FontFamily: IfcTextFontName[] , FontStyle: IfcFontStyle | null, FontVariant: IfcFontVariant | null, FontWeight: IfcFontWeight | null, FontSize: IfcSizeSelect )
	{
		this.Name = Name;
		this.FontFamily = FontFamily;
		this.FontStyle = FontStyle;
		this.FontVariant = FontVariant;
		this.FontWeight = FontWeight;
		this.FontSize = FontSize;
	}
	Name: IfcLabel ;
	FontFamily: IfcTextFontName[] ;
	FontStyle: IfcFontStyle | null;
	FontVariant: IfcFontVariant | null;
	FontWeight: IfcFontWeight | null;
	FontSize: IfcSizeSelect ;
	static FromTape(tape: any[]): IfcTextStyleFontModel
	{
		let Name = tape[0];
		let FontFamily = tape[1];
		let FontStyle = tape[2];
		let FontVariant = tape[3];
		let FontWeight = tape[4];
		let FontSize = tape[5];
		return new IfcTextStyleFontModel(Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		args.push(STRING)
		args.push(...this.FontFamily)
		if(this.FontStyle){
		args.push(STRING)
		args.push(this.FontStyle)
		}
		else{ args.push(EMPTY); }
		if(this.FontVariant){
		args.push(STRING)
		args.push(this.FontVariant)
		}
		else{ args.push(EMPTY); }
		if(this.FontWeight){
		args.push(STRING)
		args.push(this.FontWeight)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTextStyleForDefinedFont {
	constructor(Colour: IfcColour , BackgroundColour: IfcColour | null)
	{
		this.Colour = Colour;
		this.BackgroundColour = BackgroundColour;
	}
	Colour: IfcColour ;
	BackgroundColour: IfcColour | null;
	static FromTape(tape: any[]): IfcTextStyleForDefinedFont
	{
		let Colour = tape[0];
		let BackgroundColour = tape[1];
		return new IfcTextStyleForDefinedFont(Colour, BackgroundColour);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.BackgroundColour){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTextStyleTextModel {
	constructor(TextIndent: IfcSizeSelect | null, TextAlign: IfcTextAlignment | null, TextDecoration: IfcTextDecoration | null, LetterSpacing: IfcSizeSelect | null, WordSpacing: IfcSizeSelect | null, TextTransform: IfcTextTransformation | null, LineHeight: IfcSizeSelect | null)
	{
		this.TextIndent = TextIndent;
		this.TextAlign = TextAlign;
		this.TextDecoration = TextDecoration;
		this.LetterSpacing = LetterSpacing;
		this.WordSpacing = WordSpacing;
		this.TextTransform = TextTransform;
		this.LineHeight = LineHeight;
	}
	TextIndent: IfcSizeSelect | null;
	TextAlign: IfcTextAlignment | null;
	TextDecoration: IfcTextDecoration | null;
	LetterSpacing: IfcSizeSelect | null;
	WordSpacing: IfcSizeSelect | null;
	TextTransform: IfcTextTransformation | null;
	LineHeight: IfcSizeSelect | null;
	static FromTape(tape: any[]): IfcTextStyleTextModel
	{
		let TextIndent = tape[0];
		let TextAlign = tape[1];
		let TextDecoration = tape[2];
		let LetterSpacing = tape[3];
		let WordSpacing = tape[4];
		let TextTransform = tape[5];
		let LineHeight = tape[6];
		return new IfcTextStyleTextModel(TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.TextIndent){
		}
		else{ args.push(EMPTY); }
		if(this.TextAlign){
		args.push(STRING)
		args.push(this.TextAlign)
		}
		else{ args.push(EMPTY); }
		if(this.TextDecoration){
		args.push(STRING)
		args.push(this.TextDecoration)
		}
		else{ args.push(EMPTY); }
		if(this.LetterSpacing){
		}
		else{ args.push(EMPTY); }
		if(this.WordSpacing){
		}
		else{ args.push(EMPTY); }
		if(this.TextTransform){
		args.push(STRING)
		args.push(this.TextTransform)
		}
		else{ args.push(EMPTY); }
		if(this.LineHeight){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTextureCoordinate {
	constructor(Maps: Handle<IfcSurfaceTexture>[] )
	{
		this.Maps = Maps;
	}
	Maps: Handle<IfcSurfaceTexture>[] ;
	static FromTape(tape: any[]): IfcTextureCoordinate
	{
		let Maps = tape[0];
		return new IfcTextureCoordinate(Maps);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Maps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcTextureCoordinateGenerator {
	constructor(Maps: Handle<IfcSurfaceTexture>[] , Mode: IfcLabel , Parameter: IfcReal[] | null)
	{
		this.Maps = Maps;
		this.Mode = Mode;
		this.Parameter = Parameter;
	}
	Maps: Handle<IfcSurfaceTexture>[] ;
	Mode: IfcLabel ;
	Parameter: IfcReal[] | null;
	static FromTape(tape: any[]): IfcTextureCoordinateGenerator
	{
		let Maps = tape[0];
		let Mode = tape[1];
		let Parameter = tape[2];
		return new IfcTextureCoordinateGenerator(Maps, Mode, Parameter);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Maps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(STRING)
		args.push(this.Mode)
		if(this.Parameter){
		args.push(REAL)
		args.push(...this.Parameter)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTextureMap {
	constructor(Maps: Handle<IfcSurfaceTexture>[] , Vertices: Handle<IfcTextureVertex>[] , MappedTo: Handle<IfcFace> )
	{
		this.Maps = Maps;
		this.Vertices = Vertices;
		this.MappedTo = MappedTo;
	}
	Maps: Handle<IfcSurfaceTexture>[] ;
	Vertices: Handle<IfcTextureVertex>[] ;
	MappedTo: Handle<IfcFace> ;
	static FromTape(tape: any[]): IfcTextureMap
	{
		let Maps = tape[0];
		let Vertices = tape[1];
		let MappedTo = tape[2];
		return new IfcTextureMap(Maps, Vertices, MappedTo);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.Maps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(SET_BEGIN)
		this.Vertices.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REF)
		args.push(this.MappedTo.expressID)
		return args;
	}
};
export class IfcTextureVertex {
	constructor(Coordinates: IfcParameterValue[] )
	{
		this.Coordinates = Coordinates;
	}
	Coordinates: IfcParameterValue[] ;
	static FromTape(tape: any[]): IfcTextureVertex
	{
		let Coordinates = tape[0];
		return new IfcTextureVertex(Coordinates);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(...this.Coordinates)
		return args;
	}
};
export class IfcTextureVertexList {
	constructor(TexCoordsList: IfcParameterValue[] )
	{
		this.TexCoordsList = TexCoordsList;
	}
	TexCoordsList: IfcParameterValue[] ;
	static FromTape(tape: any[]): IfcTextureVertexList
	{
		let TexCoordsList = tape[0];
		return new IfcTextureVertexList(TexCoordsList);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REAL)
		args.push(...this.TexCoordsList)
		return args;
	}
};
export class IfcTimePeriod {
	constructor(StartTime: IfcTime , EndTime: IfcTime )
	{
		this.StartTime = StartTime;
		this.EndTime = EndTime;
	}
	StartTime: IfcTime ;
	EndTime: IfcTime ;
	static FromTape(tape: any[]): IfcTimePeriod
	{
		let StartTime = tape[0];
		let EndTime = tape[1];
		return new IfcTimePeriod(StartTime, EndTime);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.StartTime)
		args.push(STRING)
		args.push(this.EndTime)
		return args;
	}
};
export class IfcTimeSeries {
	constructor(Name: IfcLabel , Description: IfcText | null, StartTime: IfcDateTime , EndTime: IfcDateTime , TimeSeriesDataType: IfcTimeSeriesDataTypeEnum , DataOrigin: IfcDataOriginEnum , UserDefinedDataOrigin: IfcLabel | null, Unit: IfcUnit | null)
	{
		this.Name = Name;
		this.Description = Description;
		this.StartTime = StartTime;
		this.EndTime = EndTime;
		this.TimeSeriesDataType = TimeSeriesDataType;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.Unit = Unit;
	}
	Name: IfcLabel ;
	Description: IfcText | null;
	StartTime: IfcDateTime ;
	EndTime: IfcDateTime ;
	TimeSeriesDataType: IfcTimeSeriesDataTypeEnum ;
	DataOrigin: IfcDataOriginEnum ;
	UserDefinedDataOrigin: IfcLabel | null;
	Unit: IfcUnit | null;
	static FromTape(tape: any[]): IfcTimeSeries
	{
		let Name = tape[0];
		let Description = tape[1];
		let StartTime = tape[2];
		let EndTime = tape[3];
		let TimeSeriesDataType = tape[4];
		let DataOrigin = tape[5];
		let UserDefinedDataOrigin = tape[6];
		let Unit = tape[7];
		return new IfcTimeSeries(Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.Name)
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.StartTime)
		args.push(STRING)
		args.push(this.EndTime)
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.Unit){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTimeSeriesValue {
	constructor(ListValues: IfcValue[] )
	{
		this.ListValues = ListValues;
	}
	ListValues: IfcValue[] ;
	static FromTape(tape: any[]): IfcTimeSeriesValue
	{
		let ListValues = { t: tape[0], v: tape[1][0]} as any;
		return new IfcTimeSeriesValue(ListValues);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcTopologicalRepresentationItem {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcTopologicalRepresentationItem
	{
		return new IfcTopologicalRepresentationItem();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcTopologyRepresentation {
	constructor(ContextOfItems: Handle<IfcRepresentationContext> , RepresentationIdentifier: IfcLabel | null, RepresentationType: IfcLabel | null, Items: Handle<IfcRepresentationItem>[] )
	{
		this.ContextOfItems = ContextOfItems;
		this.RepresentationIdentifier = RepresentationIdentifier;
		this.RepresentationType = RepresentationType;
		this.Items = Items;
	}
	ContextOfItems: Handle<IfcRepresentationContext> ;
	RepresentationIdentifier: IfcLabel | null;
	RepresentationType: IfcLabel | null;
	Items: Handle<IfcRepresentationItem>[] ;
	static FromTape(tape: any[]): IfcTopologyRepresentation
	{
		let ContextOfItems = tape[0];
		let RepresentationIdentifier = tape[1];
		let RepresentationType = tape[2];
		let Items = tape[3];
		return new IfcTopologyRepresentation(ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.ContextOfItems.expressID)
		if(this.RepresentationIdentifier){
		args.push(STRING)
		args.push(this.RepresentationIdentifier)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationType){
		args.push(STRING)
		args.push(this.RepresentationType)
		}
		else{ args.push(EMPTY); }
		args.push(SET_BEGIN)
		this.Items.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		return args;
	}
};
export class IfcToroidalSurface {
	constructor(Position: Handle<IfcAxis2Placement3D> , MajorRadius: IfcPositiveLengthMeasure , MinorRadius: IfcPositiveLengthMeasure )
	{
		this.Position = Position;
		this.MajorRadius = MajorRadius;
		this.MinorRadius = MinorRadius;
	}
	Position: Handle<IfcAxis2Placement3D> ;
	MajorRadius: IfcPositiveLengthMeasure ;
	MinorRadius: IfcPositiveLengthMeasure ;
	static FromTape(tape: any[]): IfcToroidalSurface
	{
		let Position = tape[0];
		let MajorRadius = tape[1];
		let MinorRadius = tape[2];
		return new IfcToroidalSurface(Position, MajorRadius, MinorRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Position.expressID)
		return args;
	}
};
export class IfcTransformer {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcTransformerTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcTransformerTypeEnum | null;
	static FromTape(tape: any[]): IfcTransformer
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcTransformer(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTransformerType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTransformerTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTransformerTypeEnum ;
	static FromTape(tape: any[]): IfcTransformerType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcTransformerType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTransitionCurveSegment2D {
	constructor(StartPoint: Handle<IfcCartesianPoint> , StartDirection: IfcPlaneAngleMeasure , SegmentLength: IfcPositiveLengthMeasure , StartRadius: IfcPositiveLengthMeasure | null, EndRadius: IfcPositiveLengthMeasure | null, IsStartRadiusCCW: IfcBoolean , IsEndRadiusCCW: IfcBoolean , TransitionCurveType: IfcTransitionCurveType )
	{
		this.StartPoint = StartPoint;
		this.StartDirection = StartDirection;
		this.SegmentLength = SegmentLength;
		this.StartRadius = StartRadius;
		this.EndRadius = EndRadius;
		this.IsStartRadiusCCW = IsStartRadiusCCW;
		this.IsEndRadiusCCW = IsEndRadiusCCW;
		this.TransitionCurveType = TransitionCurveType;
	}
	StartPoint: Handle<IfcCartesianPoint> ;
	StartDirection: IfcPlaneAngleMeasure ;
	SegmentLength: IfcPositiveLengthMeasure ;
	StartRadius: IfcPositiveLengthMeasure | null;
	EndRadius: IfcPositiveLengthMeasure | null;
	IsStartRadiusCCW: IfcBoolean ;
	IsEndRadiusCCW: IfcBoolean ;
	TransitionCurveType: IfcTransitionCurveType ;
	static FromTape(tape: any[]): IfcTransitionCurveSegment2D
	{
		let StartPoint = tape[0];
		let StartDirection = tape[1];
		let SegmentLength = tape[2];
		let StartRadius = tape[3];
		let EndRadius = tape[4];
		let IsStartRadiusCCW = tape[5];
		let IsEndRadiusCCW = tape[6];
		let TransitionCurveType = tape[7];
		return new IfcTransitionCurveSegment2D(StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.StartPoint.expressID)
		args.push(REAL)
		args.push(this.StartDirection)
		if(this.StartRadius){
		}
		else{ args.push(EMPTY); }
		if(this.EndRadius){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTransportElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcTransportElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcTransportElementTypeEnum | null;
	static FromTape(tape: any[]): IfcTransportElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcTransportElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTransportElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTransportElementTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTransportElementTypeEnum ;
	static FromTape(tape: any[]): IfcTransportElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcTransportElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTrapeziumProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, BottomXDim: IfcPositiveLengthMeasure , TopXDim: IfcPositiveLengthMeasure , YDim: IfcPositiveLengthMeasure , TopXOffset: IfcLengthMeasure )
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.BottomXDim = BottomXDim;
		this.TopXDim = TopXDim;
		this.YDim = YDim;
		this.TopXOffset = TopXOffset;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	BottomXDim: IfcPositiveLengthMeasure ;
	TopXDim: IfcPositiveLengthMeasure ;
	YDim: IfcPositiveLengthMeasure ;
	TopXOffset: IfcLengthMeasure ;
	static FromTape(tape: any[]): IfcTrapeziumProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let BottomXDim = tape[3];
		let TopXDim = tape[4];
		let YDim = tape[5];
		let TopXOffset = tape[6];
		return new IfcTrapeziumProfileDef(ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(this.TopXOffset)
		return args;
	}
};
export class IfcTriangulatedFaceSet {
	constructor(Coordinates: Handle<IfcCartesianPointList3D> , Normals: IfcParameterValue[] | null, Closed: IfcBoolean | null, CoordIndex: IfcPositiveInteger[] , PnIndex: IfcPositiveInteger[] | null)
	{
		this.Coordinates = Coordinates;
		this.Normals = Normals;
		this.Closed = Closed;
		this.CoordIndex = CoordIndex;
		this.PnIndex = PnIndex;
	}
	Coordinates: Handle<IfcCartesianPointList3D> ;
	Normals: IfcParameterValue[] | null;
	Closed: IfcBoolean | null;
	CoordIndex: IfcPositiveInteger[] ;
	PnIndex: IfcPositiveInteger[] | null;
	static FromTape(tape: any[]): IfcTriangulatedFaceSet
	{
		let Coordinates = tape[0];
		let Normals = tape[1];
		let Closed = tape[2];
		let CoordIndex = tape[3];
		let PnIndex = tape[4];
		return new IfcTriangulatedFaceSet(Coordinates, Normals, Closed, CoordIndex, PnIndex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Coordinates.expressID)
		if(this.Normals){
		args.push(REAL)
		args.push(...this.Normals)
		}
		else{ args.push(EMPTY); }
		if(this.Closed){
		}
		else{ args.push(EMPTY); }
		if(this.PnIndex){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTriangulatedIrregularNetwork {
	constructor(Coordinates: Handle<IfcCartesianPointList3D> , Normals: IfcParameterValue[] | null, Closed: IfcBoolean | null, CoordIndex: IfcPositiveInteger[] , PnIndex: IfcPositiveInteger[] | null, Flags: IfcInteger[] )
	{
		this.Coordinates = Coordinates;
		this.Normals = Normals;
		this.Closed = Closed;
		this.CoordIndex = CoordIndex;
		this.PnIndex = PnIndex;
		this.Flags = Flags;
	}
	Coordinates: Handle<IfcCartesianPointList3D> ;
	Normals: IfcParameterValue[] | null;
	Closed: IfcBoolean | null;
	CoordIndex: IfcPositiveInteger[] ;
	PnIndex: IfcPositiveInteger[] | null;
	Flags: IfcInteger[] ;
	static FromTape(tape: any[]): IfcTriangulatedIrregularNetwork
	{
		let Coordinates = tape[0];
		let Normals = tape[1];
		let Closed = tape[2];
		let CoordIndex = tape[3];
		let PnIndex = tape[4];
		let Flags = tape[5];
		return new IfcTriangulatedIrregularNetwork(Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Coordinates.expressID)
		if(this.Normals){
		args.push(REAL)
		args.push(...this.Normals)
		}
		else{ args.push(EMPTY); }
		if(this.Closed){
		}
		else{ args.push(EMPTY); }
		if(this.PnIndex){
		}
		else{ args.push(EMPTY); }
		args.push(REAL)
		args.push(...this.Flags)
		return args;
	}
};
export class IfcTrimmedCurve {
	constructor(BasisCurve: Handle<IfcCurve> , Trim1: IfcTrimmingSelect[] , Trim2: IfcTrimmingSelect[] , SenseAgreement: IfcBoolean , MasterRepresentation: IfcTrimmingPreference )
	{
		this.BasisCurve = BasisCurve;
		this.Trim1 = Trim1;
		this.Trim2 = Trim2;
		this.SenseAgreement = SenseAgreement;
		this.MasterRepresentation = MasterRepresentation;
	}
	BasisCurve: Handle<IfcCurve> ;
	Trim1: IfcTrimmingSelect[] ;
	Trim2: IfcTrimmingSelect[] ;
	SenseAgreement: IfcBoolean ;
	MasterRepresentation: IfcTrimmingPreference ;
	static FromTape(tape: any[]): IfcTrimmedCurve
	{
		let BasisCurve = tape[0];
		let Trim1 = tape[1];
		let Trim2 = tape[2];
		let SenseAgreement = tape[3];
		let MasterRepresentation = tape[4];
		return new IfcTrimmedCurve(BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.BasisCurve.expressID)
		return args;
	}
};
export class IfcTubeBundle {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcTubeBundleTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcTubeBundleTypeEnum | null;
	static FromTape(tape: any[]): IfcTubeBundle
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcTubeBundle(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTubeBundleType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcTubeBundleTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcTubeBundleTypeEnum ;
	static FromTape(tape: any[]): IfcTubeBundleType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcTubeBundleType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTypeObject {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	static FromTape(tape: any[]): IfcTypeObject
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		return new IfcTypeObject(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTypeProcess {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ProcessType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ProcessType = ProcessType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ProcessType: IfcLabel | null;
	static FromTape(tape: any[]): IfcTypeProcess
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ProcessType = tape[8];
		return new IfcTypeProcess(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ProcessType){
		args.push(STRING)
		args.push(this.ProcessType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTypeProduct {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	static FromTape(tape: any[]): IfcTypeProduct
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		return new IfcTypeProduct(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcTypeResource {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, Identification: IfcIdentifier | null, LongDescription: IfcText | null, ResourceType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.Identification = Identification;
		this.LongDescription = LongDescription;
		this.ResourceType = ResourceType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	Identification: IfcIdentifier | null;
	LongDescription: IfcText | null;
	ResourceType: IfcLabel | null;
	static FromTape(tape: any[]): IfcTypeResource
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let Identification = tape[6];
		let LongDescription = tape[7];
		let ResourceType = tape[8];
		return new IfcTypeResource(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.LongDescription){
		args.push(STRING)
		args.push(this.LongDescription)
		}
		else{ args.push(EMPTY); }
		if(this.ResourceType){
		args.push(STRING)
		args.push(this.ResourceType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcUShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Depth: IfcPositiveLengthMeasure , FlangeWidth: IfcPositiveLengthMeasure , WebThickness: IfcPositiveLengthMeasure , FlangeThickness: IfcPositiveLengthMeasure , FilletRadius: IfcNonNegativeLengthMeasure | null, EdgeRadius: IfcNonNegativeLengthMeasure | null, FlangeSlope: IfcPlaneAngleMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Depth = Depth;
		this.FlangeWidth = FlangeWidth;
		this.WebThickness = WebThickness;
		this.FlangeThickness = FlangeThickness;
		this.FilletRadius = FilletRadius;
		this.EdgeRadius = EdgeRadius;
		this.FlangeSlope = FlangeSlope;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Depth: IfcPositiveLengthMeasure ;
	FlangeWidth: IfcPositiveLengthMeasure ;
	WebThickness: IfcPositiveLengthMeasure ;
	FlangeThickness: IfcPositiveLengthMeasure ;
	FilletRadius: IfcNonNegativeLengthMeasure | null;
	EdgeRadius: IfcNonNegativeLengthMeasure | null;
	FlangeSlope: IfcPlaneAngleMeasure | null;
	static FromTape(tape: any[]): IfcUShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Depth = tape[3];
		let FlangeWidth = tape[4];
		let WebThickness = tape[5];
		let FlangeThickness = tape[6];
		let FilletRadius = tape[7];
		let EdgeRadius = tape[8];
		let FlangeSlope = tape[9];
		return new IfcUShapeProfileDef(ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.FilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.EdgeRadius){
		}
		else{ args.push(EMPTY); }
		if(this.FlangeSlope){
		args.push(REAL)
		args.push(this.FlangeSlope)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcUnitAssignment {
	constructor(Units: IfcUnit[] )
	{
		this.Units = Units;
	}
	Units: IfcUnit[] ;
	static FromTape(tape: any[]): IfcUnitAssignment
	{
		let Units = tape[0];
		return new IfcUnitAssignment(Units);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcUnitaryControlElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcUnitaryControlElementTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcUnitaryControlElementTypeEnum | null;
	static FromTape(tape: any[]): IfcUnitaryControlElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcUnitaryControlElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcUnitaryControlElementType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcUnitaryControlElementTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcUnitaryControlElementTypeEnum ;
	static FromTape(tape: any[]): IfcUnitaryControlElementType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcUnitaryControlElementType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcUnitaryEquipment {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcUnitaryEquipmentTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcUnitaryEquipmentTypeEnum | null;
	static FromTape(tape: any[]): IfcUnitaryEquipment
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcUnitaryEquipment(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcUnitaryEquipmentType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcUnitaryEquipmentTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcUnitaryEquipmentTypeEnum ;
	static FromTape(tape: any[]): IfcUnitaryEquipmentType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcUnitaryEquipmentType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcValve {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcValveTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcValveTypeEnum | null;
	static FromTape(tape: any[]): IfcValve
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcValve(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcValveType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcValveTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcValveTypeEnum ;
	static FromTape(tape: any[]): IfcValveType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcValveType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcVector {
	constructor(Orientation: Handle<IfcDirection> , Magnitude: IfcLengthMeasure )
	{
		this.Orientation = Orientation;
		this.Magnitude = Magnitude;
	}
	Orientation: Handle<IfcDirection> ;
	Magnitude: IfcLengthMeasure ;
	static FromTape(tape: any[]): IfcVector
	{
		let Orientation = tape[0];
		let Magnitude = tape[1];
		return new IfcVector(Orientation, Magnitude);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.Orientation.expressID)
		args.push(REAL)
		args.push(this.Magnitude)
		return args;
	}
};
export class IfcVertex {
	constructor()
	{
	}
	static FromTape(tape: any[]): IfcVertex
	{
		return new IfcVertex();
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		return args;
	}
};
export class IfcVertexLoop {
	constructor(LoopVertex: Handle<IfcVertex> )
	{
		this.LoopVertex = LoopVertex;
	}
	LoopVertex: Handle<IfcVertex> ;
	static FromTape(tape: any[]): IfcVertexLoop
	{
		let LoopVertex = tape[0];
		return new IfcVertexLoop(LoopVertex);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.LoopVertex.expressID)
		return args;
	}
};
export class IfcVertexPoint {
	constructor(VertexGeometry: Handle<IfcPoint> )
	{
		this.VertexGeometry = VertexGeometry;
	}
	VertexGeometry: Handle<IfcPoint> ;
	static FromTape(tape: any[]): IfcVertexPoint
	{
		let VertexGeometry = tape[0];
		return new IfcVertexPoint(VertexGeometry);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(REF)
		args.push(this.VertexGeometry.expressID)
		return args;
	}
};
export class IfcVibrationDamper {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcVibrationDamperTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcVibrationDamperTypeEnum | null;
	static FromTape(tape: any[]): IfcVibrationDamper
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcVibrationDamper(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcVibrationDamperType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcVibrationDamperTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcVibrationDamperTypeEnum | null;
	static FromTape(tape: any[]): IfcVibrationDamperType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcVibrationDamperType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcVibrationIsolator {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcVibrationIsolatorTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcVibrationIsolatorTypeEnum | null;
	static FromTape(tape: any[]): IfcVibrationIsolator
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcVibrationIsolator(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcVibrationIsolatorType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcVibrationIsolatorTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcVibrationIsolatorTypeEnum ;
	static FromTape(tape: any[]): IfcVibrationIsolatorType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcVibrationIsolatorType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcVirtualElement {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	static FromTape(tape: any[]): IfcVirtualElement
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		return new IfcVirtualElement(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcVirtualGridIntersection {
	constructor(IntersectingAxes: Handle<IfcGridAxis>[] , OffsetDistances: IfcLengthMeasure[] )
	{
		this.IntersectingAxes = IntersectingAxes;
		this.OffsetDistances = OffsetDistances;
	}
	IntersectingAxes: Handle<IfcGridAxis>[] ;
	OffsetDistances: IfcLengthMeasure[] ;
	static FromTape(tape: any[]): IfcVirtualGridIntersection
	{
		let IntersectingAxes = tape[0];
		let OffsetDistances = tape[1];
		return new IfcVirtualGridIntersection(IntersectingAxes, OffsetDistances);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(SET_BEGIN)
		this.IntersectingAxes.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		args.push(REAL)
		args.push(...this.OffsetDistances)
		return args;
	}
};
export class IfcVoidingFeature {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcVoidingFeatureTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcVoidingFeatureTypeEnum | null;
	static FromTape(tape: any[]): IfcVoidingFeature
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcVoidingFeature(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWall {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcWallTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcWallTypeEnum | null;
	static FromTape(tape: any[]): IfcWall
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcWall(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWallElementedCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcWallTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcWallTypeEnum | null;
	static FromTape(tape: any[]): IfcWallElementedCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcWallElementedCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWallStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcWallTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcWallTypeEnum | null;
	static FromTape(tape: any[]): IfcWallStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcWallStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWallType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcWallTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcWallTypeEnum ;
	static FromTape(tape: any[]): IfcWallType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcWallType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWasteTerminal {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, PredefinedType: IfcWasteTerminalTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	PredefinedType: IfcWasteTerminalTypeEnum | null;
	static FromTape(tape: any[]): IfcWasteTerminal
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let PredefinedType = tape[8];
		return new IfcWasteTerminal(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWasteTerminalType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcWasteTerminalTypeEnum )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcWasteTerminalTypeEnum ;
	static FromTape(tape: any[]): IfcWasteTerminalType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		return new IfcWasteTerminalType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWindow {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, OverallHeight: IfcPositiveLengthMeasure | null, OverallWidth: IfcPositiveLengthMeasure | null, PredefinedType: IfcWindowTypeEnum | null, PartitioningType: IfcWindowTypePartitioningEnum | null, UserDefinedPartitioningType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.OverallHeight = OverallHeight;
		this.OverallWidth = OverallWidth;
		this.PredefinedType = PredefinedType;
		this.PartitioningType = PartitioningType;
		this.UserDefinedPartitioningType = UserDefinedPartitioningType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	OverallHeight: IfcPositiveLengthMeasure | null;
	OverallWidth: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcWindowTypeEnum | null;
	PartitioningType: IfcWindowTypePartitioningEnum | null;
	UserDefinedPartitioningType: IfcLabel | null;
	static FromTape(tape: any[]): IfcWindow
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let OverallHeight = tape[8];
		let OverallWidth = tape[9];
		let PredefinedType = tape[10];
		let PartitioningType = tape[11];
		let UserDefinedPartitioningType = tape[12];
		return new IfcWindow(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.OverallHeight){
		}
		else{ args.push(EMPTY); }
		if(this.OverallWidth){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.PartitioningType){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedPartitioningType){
		args.push(STRING)
		args.push(this.UserDefinedPartitioningType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWindowLiningProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, LiningDepth: IfcPositiveLengthMeasure | null, LiningThickness: IfcNonNegativeLengthMeasure | null, TransomThickness: IfcNonNegativeLengthMeasure | null, MullionThickness: IfcNonNegativeLengthMeasure | null, FirstTransomOffset: IfcNormalisedRatioMeasure | null, SecondTransomOffset: IfcNormalisedRatioMeasure | null, FirstMullionOffset: IfcNormalisedRatioMeasure | null, SecondMullionOffset: IfcNormalisedRatioMeasure | null, ShapeAspectStyle: Handle<IfcShapeAspect> | null, LiningOffset: IfcLengthMeasure | null, LiningToPanelOffsetX: IfcLengthMeasure | null, LiningToPanelOffsetY: IfcLengthMeasure | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.LiningDepth = LiningDepth;
		this.LiningThickness = LiningThickness;
		this.TransomThickness = TransomThickness;
		this.MullionThickness = MullionThickness;
		this.FirstTransomOffset = FirstTransomOffset;
		this.SecondTransomOffset = SecondTransomOffset;
		this.FirstMullionOffset = FirstMullionOffset;
		this.SecondMullionOffset = SecondMullionOffset;
		this.ShapeAspectStyle = ShapeAspectStyle;
		this.LiningOffset = LiningOffset;
		this.LiningToPanelOffsetX = LiningToPanelOffsetX;
		this.LiningToPanelOffsetY = LiningToPanelOffsetY;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	LiningDepth: IfcPositiveLengthMeasure | null;
	LiningThickness: IfcNonNegativeLengthMeasure | null;
	TransomThickness: IfcNonNegativeLengthMeasure | null;
	MullionThickness: IfcNonNegativeLengthMeasure | null;
	FirstTransomOffset: IfcNormalisedRatioMeasure | null;
	SecondTransomOffset: IfcNormalisedRatioMeasure | null;
	FirstMullionOffset: IfcNormalisedRatioMeasure | null;
	SecondMullionOffset: IfcNormalisedRatioMeasure | null;
	ShapeAspectStyle: Handle<IfcShapeAspect> | null;
	LiningOffset: IfcLengthMeasure | null;
	LiningToPanelOffsetX: IfcLengthMeasure | null;
	LiningToPanelOffsetY: IfcLengthMeasure | null;
	static FromTape(tape: any[]): IfcWindowLiningProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let LiningDepth = tape[4];
		let LiningThickness = tape[5];
		let TransomThickness = tape[6];
		let MullionThickness = tape[7];
		let FirstTransomOffset = tape[8];
		let SecondTransomOffset = tape[9];
		let FirstMullionOffset = tape[10];
		let SecondMullionOffset = tape[11];
		let ShapeAspectStyle = tape[12];
		let LiningOffset = tape[13];
		let LiningToPanelOffsetX = tape[14];
		let LiningToPanelOffsetY = tape[15];
		return new IfcWindowLiningProperties(GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.LiningDepth){
		}
		else{ args.push(EMPTY); }
		if(this.LiningThickness){
		}
		else{ args.push(EMPTY); }
		if(this.TransomThickness){
		}
		else{ args.push(EMPTY); }
		if(this.MullionThickness){
		}
		else{ args.push(EMPTY); }
		if(this.FirstTransomOffset){
		}
		else{ args.push(EMPTY); }
		if(this.SecondTransomOffset){
		}
		else{ args.push(EMPTY); }
		if(this.FirstMullionOffset){
		}
		else{ args.push(EMPTY); }
		if(this.SecondMullionOffset){
		}
		else{ args.push(EMPTY); }
		if(this.ShapeAspectStyle){
		args.push(REF)
		args.push(this.ShapeAspectStyle.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.LiningOffset){
		args.push(REAL)
		args.push(this.LiningOffset)
		}
		else{ args.push(EMPTY); }
		if(this.LiningToPanelOffsetX){
		args.push(REAL)
		args.push(this.LiningToPanelOffsetX)
		}
		else{ args.push(EMPTY); }
		if(this.LiningToPanelOffsetY){
		args.push(REAL)
		args.push(this.LiningToPanelOffsetY)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWindowPanelProperties {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, OperationType: IfcWindowPanelOperationEnum , PanelPosition: IfcWindowPanelPositionEnum , FrameDepth: IfcPositiveLengthMeasure | null, FrameThickness: IfcPositiveLengthMeasure | null, ShapeAspectStyle: Handle<IfcShapeAspect> | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.OperationType = OperationType;
		this.PanelPosition = PanelPosition;
		this.FrameDepth = FrameDepth;
		this.FrameThickness = FrameThickness;
		this.ShapeAspectStyle = ShapeAspectStyle;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	OperationType: IfcWindowPanelOperationEnum ;
	PanelPosition: IfcWindowPanelPositionEnum ;
	FrameDepth: IfcPositiveLengthMeasure | null;
	FrameThickness: IfcPositiveLengthMeasure | null;
	ShapeAspectStyle: Handle<IfcShapeAspect> | null;
	static FromTape(tape: any[]): IfcWindowPanelProperties
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let OperationType = tape[4];
		let PanelPosition = tape[5];
		let FrameDepth = tape[6];
		let FrameThickness = tape[7];
		let ShapeAspectStyle = tape[8];
		return new IfcWindowPanelProperties(GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.FrameDepth){
		}
		else{ args.push(EMPTY); }
		if(this.FrameThickness){
		}
		else{ args.push(EMPTY); }
		if(this.ShapeAspectStyle){
		args.push(REF)
		args.push(this.ShapeAspectStyle.expressID)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWindowStandardCase {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, ObjectPlacement: Handle<IfcObjectPlacement> | null, Representation: Handle<IfcProductRepresentation> | null, Tag: IfcIdentifier | null, OverallHeight: IfcPositiveLengthMeasure | null, OverallWidth: IfcPositiveLengthMeasure | null, PredefinedType: IfcWindowTypeEnum | null, PartitioningType: IfcWindowTypePartitioningEnum | null, UserDefinedPartitioningType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.ObjectPlacement = ObjectPlacement;
		this.Representation = Representation;
		this.Tag = Tag;
		this.OverallHeight = OverallHeight;
		this.OverallWidth = OverallWidth;
		this.PredefinedType = PredefinedType;
		this.PartitioningType = PartitioningType;
		this.UserDefinedPartitioningType = UserDefinedPartitioningType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	ObjectPlacement: Handle<IfcObjectPlacement> | null;
	Representation: Handle<IfcProductRepresentation> | null;
	Tag: IfcIdentifier | null;
	OverallHeight: IfcPositiveLengthMeasure | null;
	OverallWidth: IfcPositiveLengthMeasure | null;
	PredefinedType: IfcWindowTypeEnum | null;
	PartitioningType: IfcWindowTypePartitioningEnum | null;
	UserDefinedPartitioningType: IfcLabel | null;
	static FromTape(tape: any[]): IfcWindowStandardCase
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let ObjectPlacement = tape[5];
		let Representation = tape[6];
		let Tag = tape[7];
		let OverallHeight = tape[8];
		let OverallWidth = tape[9];
		let PredefinedType = tape[10];
		let PartitioningType = tape[11];
		let UserDefinedPartitioningType = tape[12];
		return new IfcWindowStandardCase(GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectPlacement){
		args.push(REF)
		args.push(this.ObjectPlacement.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Representation){
		args.push(REF)
		args.push(this.Representation.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.OverallHeight){
		}
		else{ args.push(EMPTY); }
		if(this.OverallWidth){
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		if(this.PartitioningType){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedPartitioningType){
		args.push(STRING)
		args.push(this.UserDefinedPartitioningType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWindowStyle {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ConstructionType: IfcWindowStyleConstructionEnum , OperationType: IfcWindowStyleOperationEnum , ParameterTakesPrecedence: IfcBoolean , Sizeable: IfcBoolean )
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ConstructionType = ConstructionType;
		this.OperationType = OperationType;
		this.ParameterTakesPrecedence = ParameterTakesPrecedence;
		this.Sizeable = Sizeable;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ConstructionType: IfcWindowStyleConstructionEnum ;
	OperationType: IfcWindowStyleOperationEnum ;
	ParameterTakesPrecedence: IfcBoolean ;
	Sizeable: IfcBoolean ;
	static FromTape(tape: any[]): IfcWindowStyle
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ConstructionType = tape[8];
		let OperationType = tape[9];
		let ParameterTakesPrecedence = tape[10];
		let Sizeable = tape[11];
		return new IfcWindowStyle(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWindowType {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ApplicableOccurrence: IfcIdentifier | null, HasPropertySets: Handle<IfcPropertySetDefinition>[] | null, RepresentationMaps: Handle<IfcRepresentationMap>[] | null, Tag: IfcLabel | null, ElementType: IfcLabel | null, PredefinedType: IfcWindowTypeEnum , PartitioningType: IfcWindowTypePartitioningEnum , ParameterTakesPrecedence: IfcBoolean | null, UserDefinedPartitioningType: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ApplicableOccurrence = ApplicableOccurrence;
		this.HasPropertySets = HasPropertySets;
		this.RepresentationMaps = RepresentationMaps;
		this.Tag = Tag;
		this.ElementType = ElementType;
		this.PredefinedType = PredefinedType;
		this.PartitioningType = PartitioningType;
		this.ParameterTakesPrecedence = ParameterTakesPrecedence;
		this.UserDefinedPartitioningType = UserDefinedPartitioningType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ApplicableOccurrence: IfcIdentifier | null;
	HasPropertySets: Handle<IfcPropertySetDefinition>[] | null;
	RepresentationMaps: Handle<IfcRepresentationMap>[] | null;
	Tag: IfcLabel | null;
	ElementType: IfcLabel | null;
	PredefinedType: IfcWindowTypeEnum ;
	PartitioningType: IfcWindowTypePartitioningEnum ;
	ParameterTakesPrecedence: IfcBoolean | null;
	UserDefinedPartitioningType: IfcLabel | null;
	static FromTape(tape: any[]): IfcWindowType
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ApplicableOccurrence = tape[4];
		let HasPropertySets = tape[5];
		let RepresentationMaps = tape[6];
		let Tag = tape[7];
		let ElementType = tape[8];
		let PredefinedType = tape[9];
		let PartitioningType = tape[10];
		let ParameterTakesPrecedence = tape[11];
		let UserDefinedPartitioningType = tape[12];
		return new IfcWindowType(GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ApplicableOccurrence){
		args.push(STRING)
		args.push(this.ApplicableOccurrence)
		}
		else{ args.push(EMPTY); }
		if(this.HasPropertySets){
		args.push(SET_BEGIN)
		this.HasPropertySets.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.RepresentationMaps){
		args.push(SET_BEGIN)
		this.RepresentationMaps.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Tag){
		args.push(STRING)
		args.push(this.Tag)
		}
		else{ args.push(EMPTY); }
		if(this.ElementType){
		args.push(STRING)
		args.push(this.ElementType)
		}
		else{ args.push(EMPTY); }
		if(this.ParameterTakesPrecedence){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedPartitioningType){
		args.push(STRING)
		args.push(this.UserDefinedPartitioningType)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWorkCalendar {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, WorkingTimes: Handle<IfcWorkTime>[] | null, ExceptionTimes: Handle<IfcWorkTime>[] | null, PredefinedType: IfcWorkCalendarTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.WorkingTimes = WorkingTimes;
		this.ExceptionTimes = ExceptionTimes;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	WorkingTimes: Handle<IfcWorkTime>[] | null;
	ExceptionTimes: Handle<IfcWorkTime>[] | null;
	PredefinedType: IfcWorkCalendarTypeEnum | null;
	static FromTape(tape: any[]): IfcWorkCalendar
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let WorkingTimes = tape[6];
		let ExceptionTimes = tape[7];
		let PredefinedType = tape[8];
		return new IfcWorkCalendar(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		if(this.WorkingTimes){
		args.push(SET_BEGIN)
		this.WorkingTimes.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.ExceptionTimes){
		args.push(SET_BEGIN)
		this.ExceptionTimes.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWorkControl {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, CreationDate: IfcDateTime , Creators: Handle<IfcPerson>[] | null, Purpose: IfcLabel | null, Duration: IfcDuration | null, TotalFloat: IfcDuration | null, StartTime: IfcDateTime , FinishTime: IfcDateTime | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.CreationDate = CreationDate;
		this.Creators = Creators;
		this.Purpose = Purpose;
		this.Duration = Duration;
		this.TotalFloat = TotalFloat;
		this.StartTime = StartTime;
		this.FinishTime = FinishTime;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	CreationDate: IfcDateTime ;
	Creators: Handle<IfcPerson>[] | null;
	Purpose: IfcLabel | null;
	Duration: IfcDuration | null;
	TotalFloat: IfcDuration | null;
	StartTime: IfcDateTime ;
	FinishTime: IfcDateTime | null;
	static FromTape(tape: any[]): IfcWorkControl
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let CreationDate = tape[6];
		let Creators = tape[7];
		let Purpose = tape[8];
		let Duration = tape[9];
		let TotalFloat = tape[10];
		let StartTime = tape[11];
		let FinishTime = tape[12];
		return new IfcWorkControl(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.CreationDate)
		if(this.Creators){
		args.push(SET_BEGIN)
		this.Creators.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Purpose){
		args.push(STRING)
		args.push(this.Purpose)
		}
		else{ args.push(EMPTY); }
		if(this.Duration){
		args.push(STRING)
		args.push(this.Duration)
		}
		else{ args.push(EMPTY); }
		if(this.TotalFloat){
		args.push(STRING)
		args.push(this.TotalFloat)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.StartTime)
		if(this.FinishTime){
		args.push(STRING)
		args.push(this.FinishTime)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWorkPlan {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, CreationDate: IfcDateTime , Creators: Handle<IfcPerson>[] | null, Purpose: IfcLabel | null, Duration: IfcDuration | null, TotalFloat: IfcDuration | null, StartTime: IfcDateTime , FinishTime: IfcDateTime | null, PredefinedType: IfcWorkPlanTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.CreationDate = CreationDate;
		this.Creators = Creators;
		this.Purpose = Purpose;
		this.Duration = Duration;
		this.TotalFloat = TotalFloat;
		this.StartTime = StartTime;
		this.FinishTime = FinishTime;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	CreationDate: IfcDateTime ;
	Creators: Handle<IfcPerson>[] | null;
	Purpose: IfcLabel | null;
	Duration: IfcDuration | null;
	TotalFloat: IfcDuration | null;
	StartTime: IfcDateTime ;
	FinishTime: IfcDateTime | null;
	PredefinedType: IfcWorkPlanTypeEnum | null;
	static FromTape(tape: any[]): IfcWorkPlan
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let CreationDate = tape[6];
		let Creators = tape[7];
		let Purpose = tape[8];
		let Duration = tape[9];
		let TotalFloat = tape[10];
		let StartTime = tape[11];
		let FinishTime = tape[12];
		let PredefinedType = tape[13];
		return new IfcWorkPlan(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.CreationDate)
		if(this.Creators){
		args.push(SET_BEGIN)
		this.Creators.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Purpose){
		args.push(STRING)
		args.push(this.Purpose)
		}
		else{ args.push(EMPTY); }
		if(this.Duration){
		args.push(STRING)
		args.push(this.Duration)
		}
		else{ args.push(EMPTY); }
		if(this.TotalFloat){
		args.push(STRING)
		args.push(this.TotalFloat)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.StartTime)
		if(this.FinishTime){
		args.push(STRING)
		args.push(this.FinishTime)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWorkSchedule {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, Identification: IfcIdentifier | null, CreationDate: IfcDateTime , Creators: Handle<IfcPerson>[] | null, Purpose: IfcLabel | null, Duration: IfcDuration | null, TotalFloat: IfcDuration | null, StartTime: IfcDateTime , FinishTime: IfcDateTime | null, PredefinedType: IfcWorkScheduleTypeEnum | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.Identification = Identification;
		this.CreationDate = CreationDate;
		this.Creators = Creators;
		this.Purpose = Purpose;
		this.Duration = Duration;
		this.TotalFloat = TotalFloat;
		this.StartTime = StartTime;
		this.FinishTime = FinishTime;
		this.PredefinedType = PredefinedType;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	Identification: IfcIdentifier | null;
	CreationDate: IfcDateTime ;
	Creators: Handle<IfcPerson>[] | null;
	Purpose: IfcLabel | null;
	Duration: IfcDuration | null;
	TotalFloat: IfcDuration | null;
	StartTime: IfcDateTime ;
	FinishTime: IfcDateTime | null;
	PredefinedType: IfcWorkScheduleTypeEnum | null;
	static FromTape(tape: any[]): IfcWorkSchedule
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let Identification = tape[5];
		let CreationDate = tape[6];
		let Creators = tape[7];
		let Purpose = tape[8];
		let Duration = tape[9];
		let TotalFloat = tape[10];
		let StartTime = tape[11];
		let FinishTime = tape[12];
		let PredefinedType = tape[13];
		return new IfcWorkSchedule(GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.Identification){
		args.push(STRING)
		args.push(this.Identification)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.CreationDate)
		if(this.Creators){
		args.push(SET_BEGIN)
		this.Creators.forEach((e) => { args.push(REF); args.push(e.expressID); });
		args.push(SET_END)
		}
		else{ args.push(EMPTY); }
		if(this.Purpose){
		args.push(STRING)
		args.push(this.Purpose)
		}
		else{ args.push(EMPTY); }
		if(this.Duration){
		args.push(STRING)
		args.push(this.Duration)
		}
		else{ args.push(EMPTY); }
		if(this.TotalFloat){
		args.push(STRING)
		args.push(this.TotalFloat)
		}
		else{ args.push(EMPTY); }
		args.push(STRING)
		args.push(this.StartTime)
		if(this.FinishTime){
		args.push(STRING)
		args.push(this.FinishTime)
		}
		else{ args.push(EMPTY); }
		if(this.PredefinedType){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcWorkTime {
	constructor(Name: IfcLabel | null, DataOrigin: IfcDataOriginEnum | null, UserDefinedDataOrigin: IfcLabel | null, RecurrencePattern: Handle<IfcRecurrencePattern> | null, Start: IfcDate | null, Finish: IfcDate | null)
	{
		this.Name = Name;
		this.DataOrigin = DataOrigin;
		this.UserDefinedDataOrigin = UserDefinedDataOrigin;
		this.RecurrencePattern = RecurrencePattern;
		this.Start = Start;
		this.Finish = Finish;
	}
	Name: IfcLabel | null;
	DataOrigin: IfcDataOriginEnum | null;
	UserDefinedDataOrigin: IfcLabel | null;
	RecurrencePattern: Handle<IfcRecurrencePattern> | null;
	Start: IfcDate | null;
	Finish: IfcDate | null;
	static FromTape(tape: any[]): IfcWorkTime
	{
		let Name = tape[0];
		let DataOrigin = tape[1];
		let UserDefinedDataOrigin = tape[2];
		let RecurrencePattern = tape[3];
		let Start = tape[4];
		let Finish = tape[5];
		return new IfcWorkTime(Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.DataOrigin){
		}
		else{ args.push(EMPTY); }
		if(this.UserDefinedDataOrigin){
		args.push(STRING)
		args.push(this.UserDefinedDataOrigin)
		}
		else{ args.push(EMPTY); }
		if(this.RecurrencePattern){
		args.push(REF)
		args.push(this.RecurrencePattern.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Start){
		args.push(STRING)
		args.push(this.Start)
		}
		else{ args.push(EMPTY); }
		if(this.Finish){
		args.push(STRING)
		args.push(this.Finish)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcZShapeProfileDef {
	constructor(ProfileType: IfcProfileTypeEnum , ProfileName: IfcLabel | null, Position: Handle<IfcAxis2Placement2D> | null, Depth: IfcPositiveLengthMeasure , FlangeWidth: IfcPositiveLengthMeasure , WebThickness: IfcPositiveLengthMeasure , FlangeThickness: IfcPositiveLengthMeasure , FilletRadius: IfcNonNegativeLengthMeasure | null, EdgeRadius: IfcNonNegativeLengthMeasure | null)
	{
		this.ProfileType = ProfileType;
		this.ProfileName = ProfileName;
		this.Position = Position;
		this.Depth = Depth;
		this.FlangeWidth = FlangeWidth;
		this.WebThickness = WebThickness;
		this.FlangeThickness = FlangeThickness;
		this.FilletRadius = FilletRadius;
		this.EdgeRadius = EdgeRadius;
	}
	ProfileType: IfcProfileTypeEnum ;
	ProfileName: IfcLabel | null;
	Position: Handle<IfcAxis2Placement2D> | null;
	Depth: IfcPositiveLengthMeasure ;
	FlangeWidth: IfcPositiveLengthMeasure ;
	WebThickness: IfcPositiveLengthMeasure ;
	FlangeThickness: IfcPositiveLengthMeasure ;
	FilletRadius: IfcNonNegativeLengthMeasure | null;
	EdgeRadius: IfcNonNegativeLengthMeasure | null;
	static FromTape(tape: any[]): IfcZShapeProfileDef
	{
		let ProfileType = tape[0];
		let ProfileName = tape[1];
		let Position = tape[2];
		let Depth = tape[3];
		let FlangeWidth = tape[4];
		let WebThickness = tape[5];
		let FlangeThickness = tape[6];
		let FilletRadius = tape[7];
		let EdgeRadius = tape[8];
		return new IfcZShapeProfileDef(ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		if(this.ProfileName){
		args.push(STRING)
		args.push(this.ProfileName)
		}
		else{ args.push(EMPTY); }
		if(this.Position){
		args.push(REF)
		args.push(this.Position.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.FilletRadius){
		}
		else{ args.push(EMPTY); }
		if(this.EdgeRadius){
		}
		else{ args.push(EMPTY); }
		return args;
	}
};
export class IfcZone {
	constructor(GlobalId: IfcGloballyUniqueId , OwnerHistory: Handle<IfcOwnerHistory> | null, Name: IfcLabel | null, Description: IfcText | null, ObjectType: IfcLabel | null, LongName: IfcLabel | null)
	{
		this.GlobalId = GlobalId;
		this.OwnerHistory = OwnerHistory;
		this.Name = Name;
		this.Description = Description;
		this.ObjectType = ObjectType;
		this.LongName = LongName;
	}
	GlobalId: IfcGloballyUniqueId ;
	OwnerHistory: Handle<IfcOwnerHistory> | null;
	Name: IfcLabel | null;
	Description: IfcText | null;
	ObjectType: IfcLabel | null;
	LongName: IfcLabel | null;
	static FromTape(tape: any[]): IfcZone
	{
		let GlobalId = tape[0];
		let OwnerHistory = tape[1];
		let Name = tape[2];
		let Description = tape[3];
		let ObjectType = tape[4];
		let LongName = tape[5];
		return new IfcZone(GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
	}
	ToTape(): any[]
	{
		let args: any[] = [];
		args.push(STRING)
		args.push(this.GlobalId)
		if(this.OwnerHistory){
		args.push(REF)
		args.push(this.OwnerHistory.expressID)
		}
		else{ args.push(EMPTY); }
		if(this.Name){
		args.push(STRING)
		args.push(this.Name)
		}
		else{ args.push(EMPTY); }
		if(this.Description){
		args.push(STRING)
		args.push(this.Description)
		}
		else{ args.push(EMPTY); }
		if(this.ObjectType){
		args.push(STRING)
		args.push(this.ObjectType)
		}
		else{ args.push(EMPTY); }
		if(this.LongName){
		args.push(STRING)
		args.push(this.LongName)
		}
		else{ args.push(EMPTY); }
		return args;
	}
};